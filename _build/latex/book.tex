%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Preface}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
%        \hypersetup{
%            pdfencoding=auto,
%            psdextra
%        }
        % End of preamble defined in sphinx-jupyterbook-latex %


\pgfplotsset{compat=1.15}

\title{A First Step to Quantum Computation with Qiskit.}
\date{Aug 22, 2022}
\release{}
\author{Ryoichi Kawai}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{cover::doc}}


\sphinxAtStartPar
\sphinxstylestrong{Ryoichi Kawai}

\sphinxAtStartPar
Department of Physics

\sphinxAtStartPar
University of Alabama at Birmingham

\sphinxAtStartPar
\sphinxurl{mailto:kawai@uab.edu}

\sphinxAtStartPar
\sphinxurl{https://kawaihome.link}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
I started writing this book in April, 2022.   I hope this book will be ready for the course in Fall 2022 or at latest, Spring 2023.  At the present, even the structure of book has not been fixed. You are free to read it but don’t give me any comment nor ask me any question until the first full draft is completed.

\sphinxAtStartPar
Thank you for your patience!

\sphinxAtStartPar
Ryoichi Kawai
\end{sphinxadmonition}

\sphinxstepscope


\part{Preface}

\sphinxstepscope


\chapter{Preface}
\label{\detokenize{preface:preface}}\label{\detokenize{preface::doc}}
\sphinxAtStartPar
This book is written for undergraduate physics students in junior or senior year.  Many students take quantum mechanics courses in senior years.  On the other hand, many contempolary topics in physics involve quantum mechanics.  If quantum mechanics is a prerequisite, many students have no chance to take the courses. Furthermore, the materials covered in traditional quantum mechanics courses are not sufficient to learn modern physics such as condensed matter physics and particle physics. It is a big challenge to expose the students to modern physics involving advanced topics in quantum mechanics.
Quantum information theory and quantum computation suffers greatly from these issues.  Most of physics students are not prepared to take courses on those topics.

\sphinxAtStartPar
Not only physics students are interested in quantum information theory and quantum computing.   Students in mathematics, computer science, eletric engineering, data science, …. are eager to learn them.  Obviously, most of them do not have experiences in quantum mechanics at all.  Therefore, it is necessary to teach quantum mechanics along with quantum information and quantum computing.  However, there is also time limit.  Idealy, every thing must fit to a semester\sphinxhyphen{}long course. We cannot spend too much time on quantum mechanics.

\sphinxAtStartPar
Furthremore, it is desired to use a computer programming language to exercise quantum computation.  In particular, python is apparently the preferred language in quantum computing.  Not all students have epxerience in python coding.

\sphinxAtStartPar
At the end, I found myself teaching quantum mechanics, mathematics, and programming language along with quatum compuation.  The contents of main topics, quantum computation, was necessarily squeezed into a very limited time.

\sphinxAtStartPar
Then, I found Jupyter Book.  If I write lecture notes in Jupyter Book, students can self\sphinxhyphen{}teach \sphinxstyleemphasis{prerequisites} through interactive online lecture notes.  So, my course is entirely written in Jupyter Book.  A problem is solved.

\sphinxAtStartPar
Since I do not assume prior experience in quamtum mechanics nor python language, the course can be taken by students outside of physics. I hope I can expose students in many different fields to quantum computation.

\sphinxAtStartPar
Another problem is what topics in quantum computation should be covered.  Despite that the quantum computation is rather young topics, it has made huge progresses and our knowledge still expanding rapidly.  Most of introductory level textbooks explain mostly famous alfgorithms such as the Shor’s algorithm, Grover’s algorithm, and Fourier Transforms.  However, I found very littel information about how to make your own algorithms.  Perhaps we can talk about simpler problems and solve them using quantum computers for the sake of learning how quantum gates work.  So, I put off discussion on \sphinxstyleemphasis{quantum supremacy} until students become familiar with quantum operations.  Due to the lack of my experience, I could not find small but interesting problems.  Nevertheless, you will find a few quantum computation with only a singe or two qubits.  I hope they help students gain
aptite to go further into quantum computation.

\sphinxAtStartPar
\sphinxstyleemphasis{Ryoichi Kawai, July 30, 2022}

\sphinxstepscope


\part{Preparation}

\sphinxstepscope


\chapter{Preparation}
\label{\detokenize{preparation/intro:preparation}}\label{\detokenize{preparation/intro:chap-prerequisites}}\label{\detokenize{preparation/intro::doc}}
\sphinxAtStartPar
This book is entirely written either in the Jupyter Notebook or Markdown. The online version is generated by Jupyter Book.  The first section of this chapter explains how the interactive book works.  In the rest of this chapter, software used in this book and online tools are introduced.

\sphinxAtStartPar
We will use computer software, \sphinxstyleemphasis{Python}, \sphinxstyleemphasis{JupyterLab}, and \sphinxstyleemphasis{Qiskit}.  In addition, we will use online tools and real quantum computers provided by \sphinxstyleemphasis{IBM Quantum Experience}.  No previous experience is needed.  However, you must train yourself as you read this book.

\sphinxAtStartPar
The use of Python, JupyterLab, Qiskit, and IBM Quantum Experience is absolutely required. If you do not have your own computer or the capacity of your computer is limited, free cloud\sphinxhyphen{}based online services, such as \sphinxstyleemphasis{IBM Quantum Lab} or \sphinxstyleemphasis{Google Colab} satisfies the requirement. Apart from some inconvenience, they work quite well.  However, it will be convenient to run codes on your computer.  Therefore, it is highly recommended to install required software on your computer.  Installation instruction is given in the following sections.

\sphinxstepscope


\section{About This Book}
\label{\detokenize{preparation/thisbook:about-this-book}}\label{\detokenize{preparation/thisbook:sec-thisbook}}\label{\detokenize{preparation/thisbook::doc}}
\sphinxAtStartPar
Each page of this book is a Jupyter Notebook file containing executable python codes.  The pages are written with \sphinxhref{https://jupyter.org/}{JupyterLab} and converted to web pages by \sphinxhref{https://jupyterbook.org/en/stable/intro.html}{Jupyter Book}.  This section explains how to use interactive feature of the book.


\subsection{Layout}
\label{\detokenize{preparation/thisbook:layout}}
\sphinxAtStartPar
You are presumably reading this book now.  You see three columns.  The left column contains the table of contents.  You can jump to any chapter and section at any time.  Above the table of contents, there is a search box.  You can search a word through the entire book.

\sphinxAtStartPar
On the right column, you see the contents of the current page.  You can jump within the page by clicking subsection title.

\sphinxAtStartPar
The center column is the actual content of the page.  At the upper\sphinxhyphen{}right corner, there are four icons.  The role of these icons is explained in next subsection.At the bottom, you see navigation arrows one to the previous page and the other to the next page. Footnotes are also shown at the bottom.

\sphinxAtStartPar
The main document consists of two types of blocks.  One is text block and the other is code block. A code block contains a python code and the output of the code appears below the code block  You can actually run the code on your computer or at Google Colab as explained below.

\sphinxAtStartPar
There is a square icon at the top of the page.  It toggles between full screen and window modes.


\subsection{Linked references}
\label{\detokenize{preparation/thisbook:linked-references}}
\sphinxAtStartPar
There are many references in the documents, references to equation, figure, table, chapter, section, footnote, bibliography citation, …  They are all linked to the actual target.  If you click the reference, the page jump to the target. For example, an equation number cited in a page is linked to the corresponding equation even it is in a different page. Clicking the cited equation number, the page containing the equation is shown  External URLs are also linked.

\sphinxAtStartPar
\sphinxincludegraphics{{buttons}.png}


\subsection{Downloading the page}
\label{\detokenize{preparation/thisbook:downloading-the-page}}
\sphinxAtStartPar
There is a download button at the upper\sphinxhyphen{}right corner.  You can download the original Jupyter notebook file (.ipynb) of the current page and the PDF version.  Click one of them with the left mouse button, download is supposed to start.  However, some web browser instead shows the contents in the browser.  If your browser does that, click “.ipynb” with the \sphinxstyleemphasis{right} mouse button and use “save link as …”. You can run the downloaded Jupyter notebook file on you computer using JupyterLab (See \hyperref[\detokenize{preparation/jupyter:sec-jupyter}]{Section \ref{\detokenize{preparation/jupyter:sec-jupyter}}}).
You can also download any page as PDF in the same way.  If you prefer to read it on paper, print the PDF file.


\subsection{Github}
\label{\detokenize{preparation/thisbook:github}}
\sphinxAtStartPar
The github button (octocat) is for the \sphinxhref{https://en.wikipedia.org/wiki/GitHub}{Github} connection.  It contains two items, \sphinxstyleemphasis{repository} and \sphinxstyleemphasis{open issue}.   You can view the source files of this book in the github repository and write bug reports and comments which can be viewed at the githut repository.


\subsection{Google Colab}
\label{\detokenize{preparation/thisbook:google-colab}}
\sphinxAtStartPar
The rocket icon at the top is known launch button.  Currently, there is only one item “Colab” in it.  This book is linked to \sphinxhref{https://colab.research.google.com/}{Google Colab}.  By clicking “Colab”, you open the current page in Google Colab where you can actually edit and run the page.  For example, there is an python code in the current page, you can run it on the google computer.   Furthermore, you can modify the code and run your own version.  See Section {\hyperref[\detokenize{preparation/cloud:sec-colab}]{\sphinxcrossref{\DUrole{std,std-ref}{Google Colab}}}} for more information about Google Colab.

\sphinxstepscope


\section{Python}
\label{\detokenize{preparation/python:python}}\label{\detokenize{preparation/python:sec-python}}\label{\detokenize{preparation/python::doc}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Python}} is a popular computer programming language. It is widely used in many different fields, scientific research, IT companies, financial institutions, \(\cdots\) .  The use of python is required in this short course. I hope that readers have a little bit of experience in coding with python. If you haven’t use it yet, you need to learn it a long with this course.  There are many online tutorials for self\sphinxhyphen{}studying.  Some of popular ones are listed at
\sphinxhref{https://sunscrapers.com/blog/12-best-python-tutorials-for-beginners/\#top-python-beginner-tutorials}{sunscrapers.com}.  You can pick one that matches to your level.  The following book will be useful in general.
\begin{quote}

\sphinxAtStartPar
Allen B. Downey: \sphinxstyleemphasis{Think Python \sphinxhyphen{} How to think like a computer scientist} (O’Reilly Media, 2016) or (Green Tea Press, 2012)
\end{quote}

\sphinxAtStartPar
which is freely available at \sphinxhref{https://greenteapress.com/wp/think-python/}{greenteapress.com}.  If you prefer a hard copy, You can buy a paperback at \sphinxhref{http://amzn.to/Owtmjy}{amazon.com}.

\sphinxAtStartPar
You must be able to execute python codes on a computer.  A computer provided by your school may have python on it.  You can also use online services such as Google Colab where you can run python codes for free.   However, school computers or online services often do not have modules you need.   It is highly recommended to have python on your own computer.  It is completely free but takes up some disk space (at least 5Gb).  In addition to basic installation, you need to install additional modules for quantum computing.  In this chapter, I explain how to install standard python.  Two additional modules, \sphinxcode{\sphinxupquote{jupyter}} and \sphinxcode{\sphinxupquote{qiskit}} will be introduced in the following sections.


\subsection{Installation \sphinxfootnotemark[1]}
\label{\detokenize{preparation/python:installation}}%
\begin{footnotetext}[1]\phantomsection\label{\thesphinxscope.1}%
\sphinxAtStartFootnote
If your computer does not have enough storage or power to run Python and JupyterLab, skip Installation.  Use an online IDE introduced in \hyperref[\detokenize{preparation/cloud:sec-cloud}]{Section \ref{\detokenize{preparation/cloud:sec-cloud}}}.
%
\end{footnotetext}\ignorespaces
\sphinxAtStartPar
There are many ways to install python.  One problem is that basic python (we shall call it \sphinxstyleemphasis{python platform}) is not enough to do almost anything. For example, the python platform does not provide any scientific function. We need to install many modules along with the python platform.  Fortunately, most of modules we need are managed by a package manager called \sphinxstyleemphasis{conda}.  Unless you are expert of python, I strongly recommend to use \sphinxstyleemphasis{conda}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Downloading anaconda package}Go to \sphinxhref{https://www.anaconda.com/}{anaconda.com} and download the installer for your OS .  Linux, Microsoft Windows, and Mac OS are all supported.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Run the installer}Execute the installer.  If the installer asks if it is for single user or multiple users, chose single user.  It also asks a location to install.  The default location is fine.

\item {}
\sphinxAtStartPar
\sphinxstylestrong{Launching anaconda}

\end{enumerate}

\sphinxAtStartPar
The way to launch anaconda depends on the OS.
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxstyleemphasis{Linux}Anaconda configuration is written in \sphinxcode{\sphinxupquote{.bashrc}}.  When you open a new terminal, anaconda is ready.

\item {}
\sphinxAtStartPar
\sphinxstyleemphasis{Windows}Open the Start Menu and pull down Anaconda3 menu. Click “Anaconda Prompt”  or “Anaconda Powershell Prompt”, whichever you like. Anaconda works only inside the Anaconda terminal window. You see another link in the menu: Anaconda Navigator.  You can launch major applications from the navigator including JupyterLab.  Since it must configure environment for each applications, the navigate starts slowly.

\item {}
\sphinxAtStartPar
\sphinxstyleemphasis{Mac OS}To be written.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\sphinxstylestrong{Updating the package}There may be newer version of packages.  To update installed packages,  run the following command inside the terminal window:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{update} \PYG{o}{\PYGZhy{}}\PYG{n+nb}{all}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now the basic installation is completed.  If you are interested in what packages are installed, use the following command.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n+nb}{list}
\end{sphinxVerbatim}

\sphinxAtStartPar
You will see hundreds of packages.  We will be using many of them even without knowing it.


\subsection{Using Python}
\label{\detokenize{preparation/python:using-python}}
\sphinxAtStartPar
You can use python interactively inside the text window.  Just use command \sphinxcode{\sphinxupquote{python}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\PYG{n}{Python} \PYG{l+m+mf}{3.9}\PYG{l+m+mf}{.12} \PYG{p}{(}\PYG{n}{main}\PYG{p}{,} \PYG{n}{Apr}  \PYG{l+m+mi}{4} \PYG{l+m+mi}{2022}\PYG{p}{,} \PYG{l+m+mi}{05}\PYG{p}{:}\PYG{l+m+mi}{22}\PYG{p}{:}\PYG{l+m+mi}{27}\PYG{p}{)} \PYG{p}{[}\PYG{n}{MSC} \PYG{n}{v}\PYG{l+m+mf}{.1916} \PYG{l+m+mi}{64} \PYG{n}{bit} \PYG{p}{(}\PYG{n}{AMD64}\PYG{p}{)}\PYG{p}{]} \PYG{p}{:}\PYG{p}{:} \PYG{n}{Anaconda}\PYG{p}{,} \PYG{n}{Inc}\PYG{o}{.} \PYG{n}{on} \PYG{n}{win32}
\PYG{n}{Type} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{help}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{copyright}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{credits}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o+ow}{or} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{license}\PYG{l+s+s2}{\PYGZdq{}} \PYG{k}{for} \PYG{n}{more} \PYG{n}{information}\PYG{o}{.}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
“>>>” is python prompt.  You enter a single line code here.  For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}
\PYG{g+go}{3  }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\end{sphinxVerbatim}

\sphinxAtStartPar
To exit from the python interactive mode, use the following exit function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{exit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We rarely use the interactive mode. Instead, we write a source code using a text editor and run it.  There are also so\sphinxhyphen{}called integrated development environment (IDE). \sphinxcode{\sphinxupquote{spyder}} and \sphinxcode{\sphinxupquote{jupyter}} are the two most popular IDEs for python.  We use\sphinxcode{\sphinxupquote{jupyter\sphinxhyphen{}lab}} to develop python codes.  Actually, this textbook is entirely written with \sphinxcode{\sphinxupquote{jupyter\sphinxhyphen{}lab}}.


\subsection{Numpy}
\label{\detokenize{preparation/python:numpy}}
\sphinxAtStartPar
Unlike other computer languages such as C++, Python platform is not capable of mathematical calculation. Mathematical modules are provided by various packages.  Among them, \sphinxstyleemphasis{Numpy} is commonly used.  Free documentation and tutorial are available at \sphinxhref{https://numpy.org/learn/}{numpy.org}.

\sphinxAtStartPar
To use it, we must \sphinxstyleemphasis{import} the module to your code.  In this book, we import it as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{np}} is a shorthand of \sphinxcode{\sphinxupquote{numpy}}.  You can access methods (functions) and attributes associated with the numpy class using the shorthand.  For example, we calculate \(\cos(\pi)\) as

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}1.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Notice \sphinxcode{\sphinxupquote{np.}} attached to \sphinxcode{\sphinxupquote{cos()}} and \sphinxcode{\sphinxupquote{pi}}.  We must tell python platform that the mathematical expressions are defined in numpy.

\begin{sphinxadmonition}{note}{Running python codes on your computer}

\sphinxAtStartPar
You can copy the python code to the clipboard on your computer.  Move the cursor to the top\sphinxhyphen{}right corner of the code block.  Copy icon shows up.  Just click it.  The content of the code block is copied.  You can paste it to your jupyter\sphinxhyphen{}lab (or a python source file) and run it.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Running python codes at Google Colab}

\sphinxAtStartPar
Launch Google Colab from the launch button at the top of the page.  This page is automatically transferred to Colab.  Sign in to Colab if you haven’t yet.  Now, you can run the python code by clicking a little triangle button at the upper\sphinxhyphen{}left corner of the code block.  You can modify the code and run your own version.
\end{sphinxadmonition}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{preparation/intro:chap-prerequisites}]{\ref{\detokenize{preparation/intro:chap-prerequisites}}}.1   Calculate \(\sin\left(\frac{\pi}{2}\right)\) using python.


\bigskip\hrule\bigskip



\subsection{Matplotlib}
\label{\detokenize{preparation/python:matplotlib}}
\sphinxAtStartPar
When we want to show results of computation as graphs, we use a plotting module \sphinxcode{\sphinxupquote{matplotlib}}.  It is a powerful visualization package for scientific research.  Free documentation and tutorials are available at
\sphinxhref{https://matplotlib.org/}{matplotlib.org}.

\sphinxAtStartPar
In this book we import it as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{plt}} is a shorthand.
The following example plots \(\sin(x)\) for \(x \in [0,2\pi]\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}   \PYG{c+c1}{\PYGZsh{} visualization tools}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}  \PYG{c+c1}{\PYGZsh{} numerical math package}
\PYG{n}{x}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} generates 100 points betwee 0 and 2pi}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x7f4a78ee7b80\PYGZgt{}]
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{python_11_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{preparation/intro:chap-prerequisites}]{\ref{\detokenize{preparation/intro:chap-prerequisites}}}.2   Calculate \(\cos(x)\) for \(x \in [-\pi,+\pi]\) using python.


\bigskip\hrule\bigskip


\sphinxAtStartPar
Lat modified on June 4, 2022.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{JupyterLab}
\label{\detokenize{preparation/jupyter:jupyterlab}}\label{\detokenize{preparation/jupyter:sec-jupyter}}\label{\detokenize{preparation/jupyter::doc}}
\sphinxAtStartPar
Jupyter is a project to develop an interactive environment for data science and scientific computing. (See \sphinxhref{https://jupyter.org/}{jupyter.org}.)  It provides a popular web\sphinxhyphen{}based interactive development environment (IDE), \sphinxstyleemphasis{Jupyter Notebook}.  We use a next\sphinxhyphen{}generation of notebook called \sphinxstyleemphasis{JupyterLab} in this book.  With JupyterLab, you can create an interactive document consisting of texts written in \sphinxstyleemphasis{Markdown} and Python codes.  In fact, this book is entirely written in JupyterLab. Since it runs in a web browser, you can use JupyterLab running on remote computers.  There are free online services that allow anyone to use their JupyterLab.  However, it is convenient to have it on your own computer since we use some extensions which may not be available at the free services.


\subsection{Installation  \sphinxfootnotemark[1]}
\label{\detokenize{preparation/jupyter:installation}}%
\begin{footnotetext}[1]\phantomsection\label{\thesphinxscope.1}%
\sphinxAtStartFootnote
If your computer does not have enough storage or power to run Python and JupyterLab, skip Installation.  Use an online IDE introduced in \hyperref[\detokenize{preparation/cloud:sec-cloud}]{Section \ref{\detokenize{preparation/cloud:sec-cloud}}}.
%
\end{footnotetext}\ignorespaces
\sphinxAtStartPar
Anaconda install JupyterLab by default.  However, certain extensions used in this book are not automatically installed.  To install them, open an Anaconda terminal window and install them as shown below.
\begin{itemize}
\item {}
\sphinxAtStartPar
nbextensions

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{jupyter}\PYG{o}{\PYGZhy{}}\PYG{n}{contrib}\PYG{o}{\PYGZhy{}}\PYG{n}{nbextensions}
\PYG{n}{jupyter} \PYG{n}{contrib} \PYG{n}{nbextension} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user}
\end{sphinxVerbatim}
\begin{itemize}
\item {}
\sphinxAtStartPar
spellchecker

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{jupyterlab}\PYG{o}{\PYGZhy{}}\PYG{n}{spellchecker}
\end{sphinxVerbatim}
\begin{itemize}
\item {}
\sphinxAtStartPar
mathjax

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{jupyter}\PYG{o}{\PYGZhy{}}\PYG{n}{serever}\PYG{o}{\PYGZhy{}}\PYG{n}{mathjax}
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{jupyterlab}\PYG{o}{\PYGZhy{}}\PYG{n}{mathjax3}
\end{sphinxVerbatim}


\subsection{Launching}
\label{\detokenize{preparation/jupyter:launching}}
\sphinxAtStartPar
There are several different ways to launch JupyterLab depending on the OS.  On any OS, you can launch it from the Anaconda terminal:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{jupyter}\PYG{o}{\PYGZhy{}}\PYG{n}{lab}
\end{sphinxVerbatim}

\sphinxAtStartPar
This opens an default web browser and JupyterLab appears in it.  If the web browser is already opened, it appears in a new tab.

\sphinxAtStartPar
On MS Windows, you can start Anaconda Navigator from Start Menu.  It takes a minute to launch the navigator.  Just click JupyterLab shown inside the navigator.  Anaconda does not provide an icon to launch JupyterLab but you find one for Jupyter Notebook in Start Menu.  You can copy it to desktop and modify it.  Simply replace notebook with lab in the target.

\sphinxAtStartPar
On Linux, you can create a desktop application file easily.  The actual name of executable is jupyter\sphinxhyphen{}lab and it is located in \textasciitilde{}/anaconda3/bin.  Depending on the Linux distribution, notebook files with “.ipynb” extension is associated with jupyter\sphinxhyphen{}lab.  If you click a notebook file in a file manager,  jupyter\sphinxhyphen{}lab is automatically launched. (It seems difficult to do it on MS Windows.)


\subsection{Usage}
\label{\detokenize{preparation/jupyter:usage}}
\sphinxAtStartPar
JupyterLab create a notebook consisting of three types of blocks, Markdown block, input code block, and output code block.  In a Markdown block, you write texts, tables, images, and equations using Markdown. Markdown is used in many other applications such as wikipedia and github. Most of formatting methods used in github also work in JupyterLab.  See \sphinxhref{https://docs.github.com/en/get-started/writing-on-github}{writing\sphinxhyphen{}on\sphinxhyphen{}github} for the formatting syntax.

\sphinxAtStartPar
In a code block, you write python codes. They are computed right a way. Right now, I am in Markdown block.  The next block is an input code block.  You see a python code in it and its output appears in output block right below the input code block.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{2}
\PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{3}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x\PYGZca{}2+y\PYGZca{}2=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{y}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x\PYGZca{}2+y\PYGZca{}2= 13
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Mathematical expression}
\label{\detokenize{preparation/jupyter:mathematical-expression}}
\sphinxAtStartPar
For us, ability to write mathematical expression is important.  Here are examples.  You can write mathematical equation using LaTeX.  An in\sphinxhyphen{}line equation start with \sphinxcode{\sphinxupquote{\$}} and another \sphinxcode{\sphinxupquote{\$}} after the equation. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYGZbs{}int \PYGZbs{}cos x dx = \PYGZbs{}sin x\PYGZdl{}
\end{sphinxVerbatim}

\sphinxAtStartPar
is rendered as \( \int \cos x dx = \sin x\).

\sphinxAtStartPar
A display equation begins with \sphinxcode{\sphinxupquote{\$\$}} which start a equation environment.  In a new line, you write an equation.  Then, another \sphinxcode{\sphinxupquote{\$\$}} closes the environment.  For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYGZdl{}
\PYGZbs{}int\PYGZus{}0\PYGZca{}\PYGZbs{}infty e\PYGZca{}\PYGZob{}\PYGZhy{}x\PYGZcb{} dx = 1
\PYGZdl{}\PYGZdl{}
\end{sphinxVerbatim}

\sphinxAtStartPar
becomes
\begin{equation*}
\begin{split}
\int_0^\infty e^{-x} dx = 1
\end{split}
\end{equation*}

\subsection{Closing JupyterLab}
\label{\detokenize{preparation/jupyter:closing-jupyterlab}}
\sphinxAtStartPar
Just closing web browser does not stop JupyterLab.  It is still running in the background.  To close JupyterLab, use “shutdown” in “File”.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Qiskit}
\label{\detokenize{preparation/qiskit:qiskit}}\label{\detokenize{preparation/qiskit:sec-qiskit}}\label{\detokenize{preparation/qiskit::doc}}
\sphinxAtStartPar
Qiskit is an open\sphinxhyphen{}source software development kit (SDK) for quantum computation. It runs inside Python platform.

\sphinxAtStartPar
QIskit provides a large set of tools for
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
developing new quantum algorithms and exploring new idea

\item {}
\sphinxAtStartPar
constructing a quantum circuit and testing it by running simulation on a classical computer

\item {}
\sphinxAtStartPar
executing the circuit on a real quantum computer through IBM Quantum Experience.

\end{enumerate}

\sphinxAtStartPar
We will use QIskit for all these three important coding steps.

\sphinxAtStartPar
You can find useful information about Qiskit including tutorials and API documentation at \sphinxhref{https://qiskit.org}{qiskit.org}.


\subsection{Installation}
\label{\detokenize{preparation/qiskit:installation}}
\sphinxAtStartPar
It is a set of python libraries but not included in Anaconda.  We need to install them manually.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{qiskit}
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{qiskit}\PYG{p}{[}\PYG{n}{visualization}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Since conda does not manage these packages, you must update the package when a new version becomes available.  To check the current version, run the following command in the anaconda terminal window.

\sphinxAtStartPar
On MS Windows, use Anaconda Powershell Prompt.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n+nb}{list} \PYG{o}{|} \PYG{n}{select}\PYG{o}{\PYGZhy{}}\PYG{n}{string} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{qiskit}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{qiskit}                            \PYG{l+m+mf}{0.36}\PYG{l+m+mf}{.2}
\PYG{n}{qiskit}\PYG{o}{\PYGZhy{}}\PYG{n}{aer}                        \PYG{l+m+mf}{0.10}\PYG{l+m+mf}{.4}
\PYG{n}{qiskit}\PYG{o}{\PYGZhy{}}\PYG{n}{ibmq}\PYG{o}{\PYGZhy{}}\PYG{n}{provider}              \PYG{l+m+mf}{0.19}\PYG{l+m+mf}{.1}
\PYG{n}{qiskit}\PYG{o}{\PYGZhy{}}\PYG{n}{ignis}                      \PYG{l+m+mf}{0.7}\PYG{l+m+mf}{.1}
\PYG{n}{qiskit}\PYG{o}{\PYGZhy{}}\PYG{n}{terra}                      \PYG{l+m+mf}{0.20}\PYG{l+m+mf}{.2}
\end{sphinxVerbatim}

\sphinxAtStartPar
On Linux

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n+nb}{list} \PYG{o}{|} \PYG{n}{grep} \PYG{n}{qiskit}

\PYG{n}{qiskit}                            \PYG{l+m+mf}{0.36}\PYG{l+m+mf}{.2}
\PYG{n}{qiskit}\PYG{o}{\PYGZhy{}}\PYG{n}{aer}                        \PYG{l+m+mf}{0.10}\PYG{l+m+mf}{.4}
\PYG{n}{qiskit}\PYG{o}{\PYGZhy{}}\PYG{n}{ibmq}\PYG{o}{\PYGZhy{}}\PYG{n}{provider}              \PYG{l+m+mf}{0.19}\PYG{l+m+mf}{.1}
\PYG{n}{qiskit}\PYG{o}{\PYGZhy{}}\PYG{n}{ignis}                      \PYG{l+m+mf}{0.7}\PYG{l+m+mf}{.1}
\PYG{n}{qiskit}\PYG{o}{\PYGZhy{}}\PYG{n}{terra}                      \PYG{l+m+mf}{0.20}\PYG{l+m+mf}{.2}
\end{sphinxVerbatim}

\sphinxAtStartPar
To check if updates are available, the following command shows newer versions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} On MS Windows}
\PYG{n}{pip} \PYG{n+nb}{list} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{outdated} \PYG{o}{|} \PYG{n}{select}\PYG{o}{\PYGZhy{}}\PYG{n}{string} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{qiskit}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} On Linux}
\PYG{n}{pip} \PYG{n+nb}{list} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{outdated} \PYG{o}{|} \PYG{n}{grep} \PYG{n}{qiskit}
\end{sphinxVerbatim}


\subsection{IBM Quantum Experience}
\label{\detokenize{preparation/qiskit:ibm-quantum-experience}}
\sphinxAtStartPar
In order to take the full advantage of Qiskit, you must first create an IBM Quantum Experience account.  With IBMid, you can run Qiskit codes on real IBM quantum computers as well as on realistic simulations on your computer.  Go to
\sphinxhref{https://quantum-computing.ibm.com/}{quantum\sphinxhyphen{}computing.ibm.com} and set up an account.
Log in to your account and take a look at IBM Quantum Dashboard where you find many useful stuffs which we discuss in later chapters.


\subsection{API key}
\label{\detokenize{preparation/qiskit:api-key}}
\sphinxAtStartPar
Next, you need to obtain an API key and save it in a local computer.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Log in to IBM Quantum Experience at \sphinxhref{https://quantum-computing.ibm.com/}{quantum\sphinxhyphen{}computing.ibm.com}

\item {}
\sphinxAtStartPar
Click the user icon at the upper\sphinxhyphen{}right corner.

\item {}
\sphinxAtStartPar
Click “Account setting”.

\item {}
\sphinxAtStartPar
Click “Generate new token”

\item {}
\sphinxAtStartPar
Click copy icon at the right end of the token box.  Your token is copied to the clipboard.

\item {}
\sphinxAtStartPar
Open a text editor and paste the token.  Save it it to a temporary file so that you can copy the token at a later time if needed. Delete the file after the key is properly installed.

\item {}
\sphinxAtStartPar
Open an Anaconda terminal window.

\item {}
\sphinxAtStartPar
Start python and execute the following command at the python prompt:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{IBMQ}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{IBMQ}\PYG{o}{.}\PYG{n}{save\PYGZus{}account}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{past your token here}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The token must be inside the single quotes.  Now, we verify if the token works.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{IBMQ}\PYG{o}{.}\PYG{n}{load\PYGZus{}account}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
You should get the following response:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{AccountProvider} \PYG{k}{for} \PYG{n}{IBMQ}\PYG{p}{(}\PYG{n}{hub}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ibm\PYGZhy{}q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{group}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{open}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{project}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{main}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If it worked, delete the temporary file created at step 6.  Otherwise, something went wrong. Try step 8 again.  Make it sure that the whole key is pasted.

\sphinxAtStartPar
If you work on multiple computers, you have to install the same API on each machine.


\subsection{Using Qiskit}
\label{\detokenize{preparation/qiskit:using-qiskit}}
\sphinxAtStartPar
Since Qiskit is a collection of python modules, we must import it to your code before using it.  The package is so large that importing the entire package is not a good idea. In this book, we use only a small portion of it.  As you move on, this book introduces some basic modules absolutely necessary for quantum computing and explains how to use them step by step.


\subsection{Suggested Reading}
\label{\detokenize{preparation/qiskit:suggested-reading}}
\sphinxAtStartPar
As mentioned above, there are various online resources at \sphinxhref{https://qiskit.org}{qiskit.org} and \sphinxhref{https://quantum-computing.ibm.com/}{quantum\sphinxhyphen{}computing.ibm.com}. In particular, the following online textbook is recommended.
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxhref{https://qiskit.org/textbook/}{Learn Quantum Computation using Qiskit}

\end{itemize}

\sphinxAtStartPar
In addition, the following paperback book is recommended.
\begin{itemize}
\item {}
\sphinxAtStartPar
H. Norlén: \sphinxhref{https://www.packtpub.com/product/quantum-computing-in-practice-with-qiskit-and-ibm-quantum-experience/9781838828448}{\sphinxstyleemphasis{Quantum Computing in Practice with Qiskit and IBM Quantum Experience}} (Packt, 2020).
Source codes can be obtained at \sphinxhref{https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience}{github}.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{tools}\PYG{n+nn}{.}\PYG{n+nn}{jupyter}
\PYG{o}{\PYGZpc{}}\PYG{k}{qiskit\PYGZus{}version\PYGZus{}table}
\PYG{o}{\PYGZpc{}}\PYG{k}{qiskit\PYGZus{}copyright}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Cloud IDE}
\label{\detokenize{preparation/cloud:cloud-ide}}\label{\detokenize{preparation/cloud:sec-cloud}}\label{\detokenize{preparation/cloud::doc}}
\sphinxAtStartPar
If your computer does not have enough storage or power to run python and jupyter, you can develop python codes and run them on cloud\sphinxhyphen{}based online IDEs.  You can also upload the jupyter notebook files used in this book and run them.  The most popular one is \sphinxstyleemphasis{Google Colab}.  However, it is a general purpose IDE and some packages we use are not available.  You must install them manually each time you use their service.%
\begin{footnote}[1]\sphinxAtStartFootnote
There are methods to store packages permanently but the procedure is rather complicated.  Therefore, we do not discuss it here.
%
\end{footnote}  \sphinxstyleemphasis{IBM Quantum Lab} is another cloud\sphinxhyphen{}based online IDE and it is designed to work with IBM Quantum Computing service via Qiskit and thus all packages we need are preloaded.  For our purpose, IBM Quantum Lab works better than Google Colab.


\subsection{IBM Quantum Lab}
\label{\detokenize{preparation/cloud:ibm-quantum-lab}}\label{\detokenize{preparation/cloud:sec-ibmqlab}}
\sphinxAtStartPar
IBM Quantum Lab allows to run JupyterLab on their server.  It is designed for quantum computing and thus it is ready to run the codes in this book.  Then, upload it to IBM Quantum Lab.  You can run it on their server for free.

\sphinxAtStartPar
If you created your IBM Quantum Experience account as instructed in \hyperref[\detokenize{preparation/qiskit:sec-qiskit}]{Section \ref{\detokenize{preparation/qiskit:sec-qiskit}}}, you are ready to use IBM Quantum Lab.
Login to \sphinxhref{https://quantum-computing.ibm.com/}{IBM Quantum Dashboard}.  Click “Launch Lab”.  Then you enter IBM Quantum Lab, which is JupyterLab running on their computer.  On the left panel, you can create new folders, new files, or upload existing jupyter notebook files.


\subsection{Google Colab}
\label{\detokenize{preparation/cloud:google-colab}}\label{\detokenize{preparation/cloud:sec-colab}}
\sphinxAtStartPar
Google Colab also gives you a similar free development environment. It is not identical but compatible to JupyterLab.  However, it is for general purpose and you must install necessary python packages such as qiskit each time.  Nevertheless, it is convenient if you do not have access to a local jupyter environment.

\sphinxAtStartPar
You need to have a google account to use this free service. If you don’t have one yet, you can open an account at \sphinxhref{https://accounts.google.com/signup}{accounts.google.com}.  Once you obtained your account, sign in at \sphinxhref{https://colab.research.google.com/}{golan.research.google.com}.  You can start writing codes or upload jupyter notebook files.

\sphinxAtStartPar
Unfortunately, Colab does not have qiskit.  However, you can install it.  Add the following code block at the beginning.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
!pip install qiskit ipywidgets pylatexenc
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, your qiskit codes run in Colab.  The installation is only temporary.  When you close the session, qiskit is removed.  You must install it each time you start new Colab session.

\begin{sphinxadmonition}{note}{Running Qiskit on Google Colab}

\sphinxAtStartPar
If you want to run qiskit codes on Google Colab, you need to add the following command in a code block.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{!pip install qiskit ipywidgets pylatexenc}}
\end{sphinxadmonition}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Quantum Mechanics}
\label{\detokenize{qmsummary/intro:quantum-mechanics}}\label{\detokenize{qmsummary/intro:sec-quantum}}\label{\detokenize{qmsummary/intro::doc}}
\sphinxAtStartPar
Quantum computation obviously relies on the principles of quantum mechanics. You need to understand them to learn quantum computation.  However, traditional quantum mechanics courses usually do not cover the principles essential to quantum computation. Therefore, quantum mechanics is not prerequisite.  No prior knowledge in quantum mechanics is assumed and I introduce basic mathematical expressions of quantum mechanics in \hyperref[\detokenize{qmsummary/vectors:sec-statevectors}]{Section \ref{\detokenize{qmsummary/vectors:sec-statevectors}}} and \hyperref[\detokenize{qmsummary/operators:sec-operators}]{Section \ref{\detokenize{qmsummary/operators:sec-operators}}}.   If you wish to learn them in depth, the following book is recommended.
\begin{itemize}
\item {}
\sphinxAtStartPar
J. Audretsch: \sphinxstyleemphasis{Entangled Systems \sphinxhyphen{} New Directions in Quantum Physics} (Wiley\sphinxhyphen{}VCH, 2007)

\end{itemize}

\sphinxAtStartPar
The following book is the most popular book on quantum computation and contains a comprehensive introduction to quantum mechanics which covers everything you need to learn quantum computation. Advanced students are encourage to read it.
\begin{itemize}
\item {}
\sphinxAtStartPar
M. A. Nielsen and I. L. Chuang: \sphinxstyleemphasis{Quantum Computation and Quantum Information}

\end{itemize}

\sphinxstepscope


\section{State vectors}
\label{\detokenize{qmsummary/vectors:state-vectors}}\label{\detokenize{qmsummary/vectors:sec-statevectors}}\label{\detokenize{qmsummary/vectors::doc}}
\sphinxAtStartPar
The theory of quantum mechanics is built on linear algebra.  I hope that you have studied elementary linear algebra prior to this book.  While I briefly introduce necessary mathematics, I expect you to review the theory of complex vector spaces (Hilbert spaces).  You can find a good summary of mathematics is also given in this book
\begin{itemize}
\item {}
\sphinxAtStartPar
J. Audretsch: \sphinxstyleemphasis{Entangled Systems \sphinxhyphen{} New Directions in Quantum Physics} (Wiley\sphinxhyphen{}VCH, 2007)

\end{itemize}

\sphinxAtStartPar
which I already recommended in the previous section.

\sphinxAtStartPar
If you want to practice mathematical calculation in depth, there is an exercise book on quantum computation.
\begin{itemize}
\item {}
\sphinxAtStartPar
W.\sphinxhyphen{}H. Steeb and Y. Hardy: \sphinxstyleemphasis{Problems and Solutions in Quantum Computing and Quantum Information} (World Scientific, 2012).

\end{itemize}

\sphinxAtStartPar
The following is a summary of Hilbert space using abstract mathematical expressions.  The ket and bra notation of vectors may be new to you.  Otherwise, it is just a standard linear algebra.  I will discuss each item in later chapters with practical examples for quantum computation.  For now, refresh your understanding of linear algebra.


\subsection{Ket and bra}
\label{\detokenize{qmsummary/vectors:ket-and-bra}}
\sphinxAtStartPar
The state of a quantum object is mathematically described by a complex vector in a \sphinxstyleemphasis{Hilbert space}, which is called \sphinxstyleemphasis{state vector}. The state vector is denoted as \(|\bullet\rangle\), which is called \sphinxstyleemphasis{ket vector} or simply \sphinxstyleemphasis{ket}.  “\(\bullet\)” in the ket can be any symbol representing the state.  For example, an electron in a spin\sphinxhyphen{}up state is commonly expressed by \(\ket{\uparrow}\). We could use \(|\)♥ \(\rangle\), \(|\)♠\(\rangle\), \(|\)♦\(\rangle\), \(|\)♣\(\rangle\) to express the states of quantum cards (if they exist.)  We often write an arbitrary state as \(| \psi\rangle\).

\sphinxAtStartPar
For every ket \(|\psi\rangle\), there is a corresponding complex vector \(\langle\psi|\), which is known as \sphinxstyleemphasis{bra vector} or just \sphinxstyleemphasis{bra}. Mathematically, \(\langle\psi|\) is the \sphinxstyleemphasis{adjoint} or \sphinxstyleemphasis{dual} of \(|\psi\rangle\).
The corresponding bra with the same symbol as a ket represents the same state of the qubit.  For example, both \(|\uparrow\rangle\) and \(\langle\uparrow|\) represent the same spin\sphinxhyphen{}up state.
We need bra vectors to compute inner products (See subsection {\hyperref[\detokenize{qmsummary/vectors:subsec-innerproduct}]{\sphinxcrossref{\DUrole{std,std-ref}{Inner product}}}}).

\sphinxAtStartPar
You are familiar with Euclidean vectors such as forces and velocities and the rules of calculation with them.
Since kets and bras are vectors, they share the same mathematical operations with the Euclidean vectors, namely two basic mathematical operations, \sphinxstyleemphasis{addition} \(|a\rangle+|b\rangle\) and \sphinxstyleemphasis{scalar mulitplication} \(\lambda |a\rangle\) (\(\lambda\) is a complex number).  The regular rules of calculation are listed below.  The dual of the operations are \(\langle a| + \langle b|\) and \(\langle a | \lambda^*\) where \(\lambda^*\) is a complex conjugate of \(\lambda\).


\subsection{Addition}
\label{\detokenize{qmsummary/vectors:addition}}
\sphinxAtStartPar
The following statements are valid for any \(|a\rangle\), \(|b\rangle\), \(|c\rangle\) in the same vector space.
The same rules are applied to bra vectors.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar
rule
&\sphinxstyletheadfamily
\sphinxAtStartPar
mathematical expression
\\
\hline
\sphinxAtStartPar
closure
&
\sphinxAtStartPar
\(\lvert a \rangle + \lvert b\rangle\) is a ket in the same vector space.
\\
\hline
\sphinxAtStartPar
commutativity
&
\sphinxAtStartPar
\(\lvert a \rangle + \lvert b\rangle = \lvert b \rangle + \lvert a\rangle\)
\\
\hline
\sphinxAtStartPar
associativity
&
\sphinxAtStartPar
\((\lvert a \rangle + \lvert b\rangle) +  \lvert c\rangle =  \lvert a\rangle + (\lvert b \rangle + \lvert c\rangle)\)
\\
\hline
\sphinxAtStartPar
null vector
&
\sphinxAtStartPar
There exists null vector \(0\) such that \(\lvert a \rangle + 0 = \lvert a \rangle\)
\\
\hline
\sphinxAtStartPar
inverse
&
\sphinxAtStartPar
There exists inverse vector \(\lvert -a \rangle\) such that \(\lvert a \rangle + \lvert -a \rangle = 0\).  In a common expression, \(\lvert -a \rangle = - \lvert a \rangle\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Scalar multiplication}
\label{\detokenize{qmsummary/vectors:scalar-multiplication}}
\sphinxAtStartPar
The following statements are valid for any \(|a\rangle\) and \(|b\rangle\) in the same vector space and any complex numbers \(\alpha\) and \(\beta\).
The same rules are applied to bra vectors.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar
rule
&\sphinxstyletheadfamily
\sphinxAtStartPar
mathematical expression
\\
\hline
\sphinxAtStartPar
closure
&
\sphinxAtStartPar
\(\alpha \lvert a \rangle\) is another ket in the same vector space
\\
\hline
\sphinxAtStartPar
vector  distributivity
&
\sphinxAtStartPar
\(\alpha (\lvert a \rangle + \lvert b\rangle) = \alpha \lvert a \rangle + \alpha \lvert b \rangle\)
\\
\hline
\sphinxAtStartPar
scalar  distributivity
&
\sphinxAtStartPar
\((\alpha + \beta) \lvert a \rangle = \alpha \lvert a \rangle + \beta \lvert a \rangle\)
\\
\hline
\sphinxAtStartPar
associativity
&
\sphinxAtStartPar
\(\alpha (\beta \lvert a \rangle) = (\alpha\beta) \lvert a \rangle\)
\\
\hline
\sphinxAtStartPar
identity
&
\sphinxAtStartPar
There exists identity \(I\) such that \(I \lvert a \rangle = \lvert a \rangle\)  (We write \(I\) as \(1\).)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Superposition}
\label{\detokenize{qmsummary/vectors:superposition}}
\sphinxAtStartPar
Combining addition and scalar multiplication, we can construct a superposition of vectors,
\begin{equation*}
\begin{split}
|\psi\rangle = \alpha |a\rangle + \beta |b\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\alpha\) and \(\beta\) are complex numbers.  The corresponding bra is
\begin{equation*}
\begin{split}
\langle \psi | = \langle a | \alpha^* + \langle b | \beta^*.
\end{split}
\end{equation*}
\sphinxAtStartPar
Notice that the coefficients are complex conjugate of the original ones in the ket.
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/vectors:sec-statevectors}]{\ref{\detokenize{qmsummary/vectors:sec-statevectors}}}.1  Consider a superposition state \(\alpha |a\rangle + e^{i \theta} \alpha |b\rangle\) where \(\theta\) is real.  Find the corresponding bra vector.
\end{quote}


\subsection{Inner product}
\label{\detokenize{qmsummary/vectors:inner-product}}\label{\detokenize{qmsummary/vectors:subsec-innerproduct}}
\sphinxAtStartPar
In the Euclidean vector space, an inner product (dot product) \(\,\vec{a} \cdot \vec{b}\,\) is real and \(\,\vec{a} \cdot \vec{b} = \vec{b} \cdot \vec{a}\). The inner product in a Hilbert space differs in two points. Firstly, the inner product in a Hilbert space \(\langle a|b \rangle\) is complex.  Secondly, the inner product is not symmetric between \(a\) and \(b\), that is \(\langle a|b \rangle \ne \langle b|a \rangle\). Instead, the two inner products are complex conjugate to each other as \(\langle a|b \rangle^* = \langle b|a \rangle\).

\sphinxAtStartPar
The inner product between \(|c \rangle\) and a superposition state \(|\psi \rangle = \alpha |a \rangle + \beta |b \rangle\) can be computed with the distribution rule
\begin{equation*}
\begin{split}\begin{eqnarray}
\langle c|\psi \rangle &=& \bra{c} \left(\alpha |a \rangle + \beta |b \rangle\right) = \alpha \langle c|a \rangle + \beta \langle c|b \rangle\\
\langle \psi|c \rangle &=& \left(\alpha^* \langle a | + \beta^* \langle b |\right) \ket{c} = \alpha^* \langle a|c \rangle + \beta^* \langle b|c \rangle.
\end{eqnarray}
\end{split}
\end{equation*}\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/vectors:sec-statevectors}]{\ref{\detokenize{qmsummary/vectors:sec-statevectors}}}.2
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
In the above example of inner product, show that \(\langle c|\psi \rangle^* = \langle \psi|c \rangle\). (otherwise, the distribution rule does not work.)

\item {}
\sphinxAtStartPar
Show that \(\langle \psi|\psi \rangle\) is real  for any \(|\psi\rangle\).

\end{enumerate}
\end{quote}


\subsection{Orthogonality}
\label{\detokenize{qmsummary/vectors:orthogonality}}
\sphinxAtStartPar
The inner product of two Euclidean vectors \(\vec{a}\) and \(\vec{b}\) may be expressed as \(\vec{a}\cdot\vec{b} = a b \cos\theta\) where \(\theta\) is the angle between the two vectors. When \(\theta = \pm \frac{\pi}{2}\), the inner product vanishes.  Then, the two vectors are said to be orthogonal. Although no such angle can be defined between two kets, we say that \(|a\rangle\) and \(|a\rangle\) are \sphinxstyleemphasis{orthogonal} if \(\langle a | b \rangle = 0\).


\subsection{Norm and normarization}
\label{\detokenize{qmsummary/vectors:norm-and-normarization}}
\sphinxAtStartPar
Recall that the norm (magnitude) of an Euclidean vector is defined by \(\|\vec{a}\| = \sqrt{\vec{a}\cdot\vec{a}}\).
The norm of \(\ket{a}\) is defined in the same way.  Replacing the dot product with inner product, we have the norm of \(|a\rangle\) as
\begin{equation*}
\begin{split}
\|a\rangle\| = \sqrt{\langle a|a \rangle}  \ge 0.
\end{split}
\end{equation*}
\sphinxAtStartPar
When \(\langle a|a \rangle = 1\), the ket is said to be \sphinxstyleemphasis{normalized}.  Although we cannot express the ket as an arrow, physicists often use an imaginary arrow to represent a ket and the norm can be viewed as the length of the imaginary arrow.  This analogy works quite well.  So, the normalized ket is much like a unit vector.
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/vectors:sec-statevectors}]{\ref{\detokenize{qmsummary/vectors:sec-statevectors}}}.3    Show that \(|b\rangle = \frac{|a\rangle}{\sqrt{\langle a|a \rangle}}\) is normalized.
\end{quote}
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/vectors:sec-statevectors}]{\ref{\detokenize{qmsummary/vectors:sec-statevectors}}}.4     \(|a\rangle\) and \(|b\rangle\) are normalized and orthogonal to each other. Show that \(|\psi\rangle = |a\rangle + i |b \rangle\) and \(|\varphi\rangle = |a\rangle - i |b \rangle\) are orthogonal.
\end{quote}


\subsection{Global phase}
\label{\detokenize{qmsummary/vectors:global-phase}}
\sphinxAtStartPar
It is easy to show that if \(|\psi\rangle\) is normalized, \(e^{i \theta}|\psi\rangle,\,\theta \in \mathbb{R}\) is also normalized.
Although they are mathematically different, the two kets corresponds to the same physical state.  The factor \(e^{i \theta}\) is known as global phase and does not play any significant role in physics.  Hence, we can ignore it.  Quantum computation can be simplified by utilizing the freedom to chose any global phase.


\subsection{Basis sets}
\label{\detokenize{qmsummary/vectors:basis-sets}}
\sphinxAtStartPar
In a freshman physics course, perhaps you expressed a force vector in the three\sphinxhyphen{}dimensional Euclidean space as \(\vec{F} = F_x \vec{i} + F_y \vec{j} + F_z \vec{k}\).  In fact, any vector can be expressed in the same way using the basis vectors  \(\vec{i}\), \(\vec{j}\) and \(\vec{k}\).  These three vectors are orthogonal to each other and their magnitude is 1.  Hence they are \sphinxstyleemphasis{orthonormal basis}.

\sphinxAtStartPar
Similarly, a \(n\)\sphinxhyphen{}dimensional Hilbert space is \sphinxstyleemphasis{spanned} by a basis set \(\{\ket{e_0}, \ket{e_1}, \cdots, \ket{e_{n-1}}\}\).  We assume that the basis vectors are normized and orthogonal to each other.  Such basis set is called \sphinxstyleemphasis{orthonormal basis} and the basis vectors satisfy
\begin{equation}\label{equation:qmsummary/vectors:orthonormal}
\begin{split}
\langle e_i | e_j \rangle = \delta_{ij}
\end{split}
\end{equation}
\sphinxAtStartPar
where \(\delta_{ij}\) is the usual Kronecker’s delta.

\sphinxAtStartPar
The basis vectors are \sphinxstyleemphasis{linearly independent} and \sphinxstyleemphasis{complete}.  That means that any ket vector  can be expressed as a linear combination of the base vectors as
\begin{equation}\label{equation:qmsummary/vectors:basis_expansion}
\begin{split}
|\psi\rangle = c_0 |e_0\rangle + c_1 |e_1\rangle  \cdots c_{n-1} |e_{n-1}\rangle = \sum_{i=0}^{n-1} c_i |e_i\rangle
\end{split}
\end{equation}
\sphinxAtStartPar
where \(c_i\) is complex.
Using the orthonormality condition \eqref{equation:qmsummary/vectors:orthonormal} , we can find the expansion coefficient as \(c_i=\langle  e_i|\psi \rangle\) which is a crucial quantity in quantum mechanics.

\sphinxAtStartPar
The corresponding bra vector are expressed as
\begin{equation*}
\begin{split}
\langle \psi| = c^*_0 \langle e_0| + c^*_1 \langle e_1|  \cdots c^*_{n-1} \langle e_{n-1}| = \sum_{i=0}^{n-1} c^*_i \langle e_i|.
\end{split}
\end{equation*}
\sphinxAtStartPar
Notice that the expansion coefficients of the bra are complex conjugate of the coefficients of the ket.

\sphinxAtStartPar
If \(|\psi\rangle\) is normalized, the coefficients is normalized as \(\sum_j |c_j|^2 = 1\).


\subsection{Completeness}
\label{\detokenize{qmsummary/vectors:completeness}}
\sphinxAtStartPar
In Equation \eqref{equation:qmsummary/vectors:basis_expansion} we expanded an arbitrary vector in a complete basis set.  The following \sphinxstyleemphasis{closure relation} guarantees the completeness.
\begin{equation}\label{equation:qmsummary/vectors:completeness}
\begin{split}
|e_0\rangle\langle e_0| + |e_1\rangle\langle e_1| + \cdots + |e_{n-1}\rangle\langle e_{n-1}| = I
\end{split}
\end{equation}
\sphinxAtStartPar
where \(\{|e_i\rangle\}\) is an orthonormal basis.  \(|e_i\rangle\langle e_i|\) is a kind of operator called \sphinxstyleemphasis{projection operator}, which we study in XXX.  It acts on a ket as follows:
\begin{equation*}
\begin{split}
(|e_i\rangle\langle e_i|)\, |\psi\rangle =  |e_i\rangle (\langle e_i|\psi\rangle) = c_i e_i\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(c_i = \langle e_i|\psi\rangle\).


\subsection{Two\sphinxhyphen{}dimensional Hilbert space}
\label{\detokenize{qmsummary/vectors:two-dimensional-hilbert-space}}
\sphinxAtStartPar
In the theory of quantum computation, a two\sphinxhyphen{}dimensional Hilbert space denoted as \(\mathbb{C}^2\), appears quite often.  It is a convention to use a complete orthonormal basis set \(\{|0\rangle, |1\rangle\}\) known as \sphinxstyleemphasis{computational basis}.  We use this basis set extensively through out the book.  The orthonormality of this basis set is given by
\begin{equation}\label{equation:qmsummary/vectors:eq-comp-basis}
\begin{split}
\langle 0|0 \rangle = \langle 1|1 \rangle = 1, \quad \langle 0|1 \rangle = \langle 1|0 \rangle = 0
\end{split}
\end{equation}
\sphinxAtStartPar
Another basis set
\begin{equation}\label{equation:qmsummary/vectors:eq-plusminus-basis}
\begin{split}
|+\rangle = \frac{1}{\sqrt{2}} \left( |0\rangle + |1\rangle\right), \quad |-\rangle = \frac{1}{\sqrt{2}} \left( |0\rangle - |1\rangle\right)
\end{split}
\end{equation}
\sphinxAtStartPar
is also regularly used.
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/vectors:sec-statevectors}]{\ref{\detokenize{qmsummary/vectors:sec-statevectors}}}.5    \(|\pm\rangle\) are orthonormal.
\end{quote}

\sphinxstepscope


\section{Operators}
\label{\detokenize{qmsummary/operators:operators}}\label{\detokenize{qmsummary/operators:sec-operators}}\label{\detokenize{qmsummary/operators::doc}}
\sphinxAtStartPar
An operator is defined on a Hilbert space and acts on a vector in the same Hilbert space.  More precisely, we use \sphinxstyleemphasis{linear} operators.  In this section, we learn the following mathematical operations associated with operators.  Physical interpretations will be followed after this section.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar
operation
&\sphinxstyletheadfamily
\sphinxAtStartPar
mathematical expression
\\
\hline
\sphinxAtStartPar
operator times ket
&
\sphinxAtStartPar
\(A \ket{\psi}\)
\\
\hline
\sphinxAtStartPar
adjoint operator
&
\sphinxAtStartPar
\(\bra{\psi} A^\dagger\)
\\
\hline
\sphinxAtStartPar
scalar multiplication
&
\sphinxAtStartPar
\(\lambda A, \quad \lambda \in \mathbb{C}\)
\\
\hline
\sphinxAtStartPar
operator sum
&
\sphinxAtStartPar
\(A+B\)
\\
\hline
\sphinxAtStartPar
identity operator
&
\sphinxAtStartPar
\(I\)
\\
\hline
\sphinxAtStartPar
operator multiplication
&
\sphinxAtStartPar
\(AB\)
\\
\hline
\sphinxAtStartPar
commutation
&
\sphinxAtStartPar
\([A\, B]=AB-BA \)
\\
\hline
\sphinxAtStartPar
matrix element
&
\sphinxAtStartPar
\(\langle \psi \vert A \vert \varphi  \rangle\)
\\
\hline
\sphinxAtStartPar
trace
&
\sphinxAtStartPar
\(\text{tr} A\)
\\
\hline
\sphinxAtStartPar
dyad
&
\sphinxAtStartPar
\(\ket{\psi}\bra{\varphi}\)
\\
\hline
\sphinxAtStartPar
projection operator
&
\sphinxAtStartPar
\(P^2=P\)
\\
\hline
\sphinxAtStartPar
Self\sphinxhyphen{}adjoint operators
&
\sphinxAtStartPar
\(A^\dagger = A\)
\\
\hline
\sphinxAtStartPar
Unitary operator
&
\sphinxAtStartPar
\(U^\dagger U = I\)
\\
\hline
\sphinxAtStartPar
Eigenvalue and eigenvector
&
\sphinxAtStartPar
\(A \ket{a_i} = \lambda_i \ket{a_i}\)
\\
\hline
\sphinxAtStartPar
Pauli operator
&
\sphinxAtStartPar
\(X, Y, Z\)
\\
\hline
\sphinxAtStartPar
function of operator
&
\sphinxAtStartPar
\(f(A)\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Operator times ket}
\label{\detokenize{qmsummary/operators:operator-times-ket}}\label{\detokenize{qmsummary/operators:pp-times-ket}}
\sphinxAtStartPar
When a operator \(A\) acts on any ket in the Hilbert space, it transforms the ket to another ket in the same Hilbert space,
\begin{equation*}
\begin{split}
\ket{b} = A \ket{a}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Similarly every bra is transformed as
\begin{equation*}
\begin{split}
\bra{b} = \bra{a} A^\dagger
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(A^\dagger\) is \sphinxstyleemphasis{Hermite conjugate} or \sphinxstyleemphasis{adjoint} of \(A\).  The adjoint of the adjoint operator is the original operator, that is  \((A^\dagger)^\dagger = A\).

\sphinxAtStartPar
It is wrong to think that \(A^\dagger\) always act on bra.  It can be applied to ket and \(A^\dagger \ket{a}\) is perfectly OK.  However, in general \(A \ket{a} \ne A^\dagger \ket{A}\). Therefore \(A\) and \(A^\dagger\) are two different operators..  By definition, the adjoint expression of \(A^\dagger \ket{A}\) is \(\bra{a} (A^\dagger)^\dagger = \bra{a} A\).

\sphinxAtStartPar
\sphinxstylestrong{Example} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.1  Operator \(X\) transforms the basis vectors as \(X\ket{0} \equiv \ket{1}\) and \(X\ket{1} \equiv \ket{0}\).

\sphinxAtStartPar
\sphinxstylestrong{Example} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.2  Consider \(H\) transforms the basis vectors as \(H\ket{0} \equiv \ket{+}\) and \(H\ket{1} \equiv \ket{-}\).
(See \eqref{equation:qmsummary/vectors:eq-plusminus-basis} for the definition of \(\ket{\pm}\).)  \(H\) is known as \sphinxstyleemphasis{Hadamard} gate and one of the very important quantum gates.


\subsection{Scalar multiplication}
\label{\detokenize{qmsummary/operators:scalar-multiplication}}
\sphinxAtStartPar
\(\lambda A\) is another operator where \(\lambda\) is any complex number.  You can place the scalar in the either side of the operator, i.e., \(\lambda A = A \lambda\). The adjoint of \(\lambda A\) is \(\lambda^* A^\dagger\).  Notice that the complex conjugate of the scalar in the adjoint.

\sphinxAtStartPar
The following associativity holds:
\begin{equation*}
\begin{split}
(\lambda A) \ket{a} = \lambda (A \ket{a}) = A (\lambda \ket{a})
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
(\lambda \eta) A = \lambda (\eta A)
\end{split}
\end{equation*}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.1     Find the adjoint of \(\lambda A \ket{a}\).


\bigskip\hrule\bigskip



\subsection{Linearity}
\label{\detokenize{qmsummary/operators:linearity}}
\sphinxAtStartPar
When an operator acts on a superposition state, the following linearity holds:
\begin{equation*}
\begin{split}
A \left(\alpha \ket{\psi} + \beta\ket{\phi}\right) = \alpha A \ket{\psi} + \beta A \ket{\phi}
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\alpha, \beta \in \mathbb{C}\).


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.2     Show that \(H\ket{+} = \ket{0}\) and \(H \ket{-} = \ket{1}\) where \(H\) is the Hadamard gate.


\bigskip\hrule\bigskip



\subsection{Operator sum}
\label{\detokenize{qmsummary/operators:operator-sum}}
\sphinxAtStartPar
The sum of operators satisfies the following distributivity:
\begin{equation*}
\begin{split}
\left(A+B\right)\ket{\psi} = A \ket{\psi} + B \ket{\psi}.
\end{split}
\end{equation*}

\subsection{Operator products}
\label{\detokenize{qmsummary/operators:operator-products}}
\sphinxAtStartPar
For any operators \(P\) and \(Q\) in a Hilbert space, the product \(PQ\) is also an operator in the same Hilbert space. When \(Q\) is applied on \(\ket{a}\) and \(P\) is applied on the result of the first operation,  the final result is also a vector in the same Hilbert space:
\begin{equation*}
\begin{split}
P (Q\ket{a}) = P \ket{b} = \ket{c}
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\ket{b} = Q \ket{a}\). The associativity \(P (Q\ket{a}) = (PQ) \ket{a}\) holds.

\sphinxAtStartPar
Similarly, when we apply \(P\) on \(\ket{a}\) first and \(Q\) afterward, the associativity  \(Q (P\ket{a}) = (QP) \ket{a}\) holds as well.
In general the outcomes of these two operations are different and thus \(PQ \ne QP\).  In other words, \(P\) and \(Q\) do not \sphinxstyleemphasis{commute}.  The difference between \(PQ\) and \(QP\) is expressed with \sphinxstyleemphasis{commutator}
\begin{equation*}
\begin{split}
[P,Q] \equiv PQ - QP.
\end{split}
\end{equation*}
\sphinxAtStartPar
Only when \([P,Q]=0\), we can change the order of operations. The commutation relation is of fundamental importance in quantum mechanics.

\sphinxAtStartPar
For some operators, anti\sphinxhyphen{}commutation
\begin{equation*}
\begin{split}
\{P,Q\} \equiv PQ + QP
\end{split}
\end{equation*}
\sphinxAtStartPar
also plays an important role.

\sphinxAtStartPar
The dual of the above transformation is
\begin{equation*}
\begin{split}
\bra{c} = \bra{b}P^\dagger = (\bra{a} Q^\dagger) P^\dagger
\end{split}
\end{equation*}
\sphinxAtStartPar
Using the associativity \(PQ\), \(\bra{c} = \bra{a} (PQ)^\dagger\).  By direct comparison, we find
\begin{equation}\label{equation:qmsummary/operators:PQ_dagger}
\begin{split}
(PQ)^\dagger = Q^\dagger P^\dagger.
\end{split}
\end{equation}
\sphinxAtStartPar
We learned a similar relation in a linear algebra course: \((PQ)^T=Q^T P^T\) where \(P\) and \(Q\) are matrices and \(T\) is transpose.  We will see that this equality is indeed equivalent to \eqref{equation:qmsummary/operators:PQ_dagger}.


\subsection{Identity operator \protect\(I\protect\)}
\label{\detokenize{qmsummary/operators:identity-operator-i}}
\sphinxAtStartPar
The simplest operator is the \sphinxstyleemphasis{identity} operator \(I\) which transforms a vector to itself:
\begin{equation*}
\begin{split}
\ket{a} = I \ket{a}.
\end{split}
\end{equation*}
\sphinxAtStartPar
The adjoit of the transformation is given by
\begin{equation*}
\begin{split}
\bra{a} = \bra{a} I^\dagger
\end{split}
\end{equation*}
\sphinxAtStartPar
It is easy to show that for any operator \(A\),
\begin{equation*}
\begin{split}
A\,I = I\, A = A.
\end{split}
\end{equation*}
\sphinxAtStartPar
The identity operator looks trivial.  However, it is ubiquitous in quantum computation. First of all, it is needed to define inverse operators.  The inverse operator of \(A\) is defined by
\begin{equation*}
\begin{split}
A^{-1} A = A A^{-1} = I.
\end{split}
\end{equation*}
\sphinxAtStartPar
Not all operators have their inverse but most of operators we use in quantum computation do.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.3     The identity operator \(I\) satisfies \(I = I^{-1} = I^\dagger = I^2\).  Prove it.


\bigskip\hrule\bigskip



\subsection{Matrix elements}
\label{\detokenize{qmsummary/operators:matrix-elements}}
\sphinxAtStartPar
Consider an expression \(\langle a | A | b \rangle\).  It is not clear if \(A\) is acting on the ket or the bra. Let us assume that \(A\) acts on the ket as\(\langle b | (A | a \rangle)\).  Then, it is a regular inner product.  If \(A \ket{a}=\ket{c}\), it is indeed \(\langle  b|c \rangle\).  It turns out that when \(A\) can act on the bra, the same inner product is obtained.  Therefore, we don’t have to specify which way the operator acts.  The quantity \(\langle a | A | b \rangle\) is called \sphinxstyleemphasis{matrix element} of \(A\).

\sphinxAtStartPar
Most of mathematical objects we encounter in quantum mechanics are defined in some abstract space and they are not directly connected to what we see in the real world.  The inner products and also matrix elements are numbers we are familiar with.  Hence, abstract expressions of quantum mechanics and physical values we experience in the real world are connected through the inner product.  In this sense, the inner product is very essential.  Without it, quantum mechanics is completely separated from the real world and would be useless.

\sphinxAtStartPar
\sphinxstylestrong{Example} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.3     \(\bra{0}X\ket{0} = 0\).
\begin{quote}

\sphinxAtStartPar
Calculation: \(\bra{0}X\ket{0} = \langle 0 | 1 \rangle = 0\) where \(X\ket{0} = \ket{1}\) is used.
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Example} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.4     \(\bra{+}H\ket{+} = \frac{1}{\sqrt{2}}\).
\begin{quote}

\sphinxAtStartPar
Calculation: \(\bra{+}H\ket{+} = \langle + | 0 \rangle = \left(\frac{1}{\sqrt{2}}(\bra{0}+\bra{1}) \right) \ket{0} = \frac{1}{\sqrt{2}} \left(\langle 0|0 \rangle + \langle 1|0 \rangle \right)= \frac{1}{\sqrt{2}}.
\).
\end{quote}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.4     Evaluate matrix element \(\bra{+} H \ket{-}\).


\bigskip\hrule\bigskip



\subsection{Dyads}
\label{\detokenize{qmsummary/operators:dyads}}
\sphinxAtStartPar
A kind of product between a bra \(\bra{\psi}\) and a ket \(\ket{\varphi}\)
\begin{equation*}
\begin{split}
\ket{\varphi} \bra{\psi}
\end{split}
\end{equation*}
\sphinxAtStartPar
is an operator known as \sphinxstyleemphasis{dyad}.  In fact, it transforms a ket to another ket:
\begin{equation*}
\begin{split} \left(\ket{\varphi}\bra{\psi}\right) \ket{a} = \ket{\varphi} \langle \psi|a \rangle = \lambda \ket{\varphi}
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\lambda = \langle \psi|a \rangle\).

\sphinxAtStartPar
A special case of dyad, \(\ket{\psi}\bra{\psi}\) is known as \sphinxstyleemphasis{orthogonal projection operator}.  Assuming \(\ket{\psi}\) is normalized, it satisfies the idempotency \(P^2=P\). Mathematically, the idempotency is the definition of projection operators and the orthogonal projection operator is a special kind of projection operators. However, as in physics literature, we shall call it projection operator without “orthogonal”.  We have already encounter it in the closure relation of the complete basis set \eqref{equation:qmsummary/vectors:completeness}.


\subsection{Self\sphinxhyphen{}adjoint operators}
\label{\detokenize{qmsummary/operators:self-adjoint-operators}}
\sphinxAtStartPar
When \(A = A^\dagger\), operator \(A\) is self\sphinxhyphen{}adjoint (or Hermitian).  Identity \(I\) and projection operator \(P\) are self\sphinxhyphen{}adjoint.


\subsection{Unitary operators}
\label{\detokenize{qmsummary/operators:unitary-operators}}
\sphinxAtStartPar
When an operator transform a \sphinxstyleemphasis{state vector} to another \sphinxstyleemphasis{state vector}, the transformation should preserve the norm of the \sphinxstyleemphasis{stat vectors}.  Consider a transformation \(\ket{\psi'} = U \ket{\psi}\) and its adjoint \(\bra{\psi'} = \bra{\psi} U^\dagger\).  Since the norm must preserve, we have
\(\langle \psi'|\psi' \rangle = \bra{\psi} U^\dagger U \ket{\psi} = \langle \psi|\psi \rangle\), which indicates that
\begin{equation*}
\begin{split}
U^\dagger U = I.
\end{split}
\end{equation*}
\sphinxAtStartPar
Any operator that satisfies this condition is \sphinxstyleemphasis{unitary}. In quantum computation , we apply a set of gates on an input state vector and the outcome is also a state vector, quantum circuit must be unitary operators (unless quantum measurement is involved in it).

\sphinxAtStartPar
Unitary operators are conveniently written in the exponential form
\begin{equation*}
\begin{split}
U = e^{-i \theta A}
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(A\) is a self\sphinxhyphen{}adjoint operator and \(\theta\) is a real parameter.

\sphinxAtStartPar
Its adjoint is
\begin{equation*}
\begin{split}
U^\dagger = e^{i \theta A^\dagger} = e^{i \theta A}
\end{split}
\end{equation*}
\sphinxAtStartPar
which leads to \(U^\dagger U = I\) and thus \(U\) is unitary.

\sphinxAtStartPar
The operator exponential functions are used for time\sphinxhyphen{}evolution, space rotation, space translation, \(\cdots\) and they are a key mathematical component for symmetry groups and conservation laws.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.5     Show that \(U^\dagger U = e^{i \theta A^\dagger} e^{-i \theta A} = I\) if \(A\) is self\sphinxhyphen{}adjoint.


\bigskip\hrule\bigskip



\subsection{Eigenvalues and eigenvectors}
\label{\detokenize{qmsummary/operators:eigenvalues-and-eigenvectors}}
\sphinxAtStartPar
When an operator \(A\) and its adjoint \(A^\dagger\) commute, i.e. \([A,A^\dagger]=0\), \(A\) is a \sphinxstyleemphasis{normal} operator and there are special kets which are transformed to “itself”  by \(A\).  Mathematically, it is expressed by
\begin{equation}\label{equation:qmsummary/operators:eigeneq}
\begin{split}
A \ket{a} = \lambda \ket{a}
\end{split}
\end{equation}
\sphinxAtStartPar
where \(\lambda \in \mathbb{C}\).  The right hand side is not exactly the “itself” but multiplied by a constant \(\lambda\) which is called \sphinxstyleemphasis{eigenvalue}.  (In next section, we will see that \(\ket{a}\) and \(\lambda \ket{a}\) represent the same physical state.)  The ket \(\ket{a}\) is called \sphinxstyleemphasis{eigenvector} or \sphinxstyleemphasis{eigenket} of \(A\).

\sphinxAtStartPar
There are many such vectors.  More precisely, there are \(N\) eigenkets in \(N\)\sphinxhyphen{}dimensional Hilbert space.  Therefore, we write \eqref{equation:qmsummary/operators:eigeneq} as
\begin{equation*}
\begin{split}
A \ket{a_i} = \lambda_i \ket{a_i}, \quad i=1,\cdots, N.
\end{split}
\end{equation*}
\sphinxAtStartPar
When \(A\) is self\sphinxhyphen{}adjoint, the eigenvalues are all real, which is important when we discuss measurement of physical quantities in \{numref\}`sec\_measurement\}.


\subsection{Trace of operators}
\label{\detokenize{qmsummary/operators:trace-of-operators}}
\sphinxAtStartPar
Another operation on operators we often use is tracing.   For an operator \(A \in \mathcal{H}\), the trace of the operator is defined by
\begin{equation*}
\begin{split}
\text{tr} A = \sum_j  \bra{e_j} A  \ket{e_j}
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\{\ket{e_j}, \, j=1,n\}\) is a basis set in the Hilbert space.  \(\bra{e_j} A  \ket{e_j}\) is matrix element.

\sphinxAtStartPar
The following properties of the trace are useful.  (\(A\)and \(B\) are operators and \(\alpha, \beta \in \mathbb{C}\).)
\begin{itemize}
\item {}
\sphinxAtStartPar
linearity

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(\text{tr}\left(\alpha A\right) = \alpha\, \text{tr} A\)\(\text{tr} \left(\alpha A+\beta B\right) = \alpha\, \text{tr} A + \beta\, \text{tr} B\)
\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
cyclic permutations

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(\text{tr}\left(AB\right) = \text{tr}\left(BA\right)\)
\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
adjoint operator

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(\text{tr} A^\dagger = (\text{tr} A)^*\)
\end{quote}

\sphinxAtStartPar
The following trace formula for dyads are also usefull
\begin{quote}

\sphinxAtStartPar
\(\text{tr}\left(\ket{\varphi}\bra{\psi}\right) = \langle\psi|\varphi\rangle\).\(\text{tr}\left(A\ket{\varphi}\bra{\psi}\right) = \langle\psi|A|\varphi\rangle\).
\end{quote}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.6     Show that \(\text{tr} \left([A,B]\right) = 0\),  even when \([A,B]\ne 0\).


\bigskip\hrule\bigskip



\subsection{Pauli Operators}
\label{\detokenize{qmsummary/operators:pauli-operators}}\label{\detokenize{qmsummary/operators:sec-pauli-ops}}
\sphinxAtStartPar
Pauli operators \(\sigma_x\). \(\sigma_y\), and \(\sigma_z\) are originally used to express electron spin.  They plays very important roles in the qubit\sphinxhyphen{}based quantum computation.

\sphinxAtStartPar
Traditionally in literature on quantum computation, symbols \(X\equiv \sigma_x\), \(Y\equiv \sigma_y\), and \(Z\equiv \sigma_z\) are used.  By definition, the Pauli operators satisfy
\begin{itemize}
\item {}
\sphinxAtStartPar
commutation relation

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\([X,Y]=2 i Z, \qquad [Y,Z]=2 i X, \qquad [Z,X]=2 i Y\)
\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
anti\sphinxhyphen{}commutatioan relation

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(\{X,Y\} = \{Y,Z\} = \{Z,X\} = 0\)
\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
self\sphinxhyphen{}inverse

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(X^2 = Y^2 = Z^2 = I\)
\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
self\sphinxhyphen{}adjoint

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(X^\dagger=X, \qquad Y^\dagger=Y, \qquad Z^\dagger = Z\)
\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
unitary

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(X^\dagger X = Y^\dagger Y = Z^\dagger Z = I\)
\end{quote}

\sphinxAtStartPar
In \(\mathbb{C}^2\), any operator \(A\) can be written as
\begin{equation*}
\begin{split}
A = c_0 I + c_1 X + c_2 Y + c_3 Z
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(c_0 = \text{tr}(I A)\), \(c_1 = \text{tr}(X A)\), \(c_2 = \text{tr}(Y A)\), and \(c_3 = \text{tr}(Z A)\).  When \(A\) is self\sphinxhyphen{}adjoint, all the coefficients are real.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.7     Using the properties given above
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Show that \(X Y = i Z\),

\item {}
\sphinxAtStartPar
Show that \(XYZ = i I\),

\item {}
\sphinxAtStartPar
Show that \(\text{tr} X = \text{tr} Y = \text{tr} Z = 0\).

\end{enumerate}


\bigskip\hrule\bigskip


\sphinxAtStartPar
Among the three Pauli operators, \(X\) is the most important for quantum computation. Its main roles are:
\begin{itemize}
\item {}
\sphinxAtStartPar
\(X\) flips the computational basis.

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(X \ket{0} = \ket{1}, \qquad X \ket{1} = \ket{0}\).
\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
\(X\) swaps the coefficients in a superposition state.

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(X \left(c_0\ket{0} + c_1 \ket{1}\right) = c_1\ket{0} + c_0 \ket{1}\),
\end{quote}

\sphinxAtStartPar
\(Z\) does not flip the basis but change the relative phase.
\begin{itemize}
\item {}
\sphinxAtStartPar
\(Z\) does nothing on \(\ket{0}\)

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(Z \ket{0} = \ket{0}\).
\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
\(Z\) inverts the phase of \(\ket{1}\).

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(Z \ket{1} = - \ket{1}\).
\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
When acting on a superposition state \(Z\) changes the relative phase as

\end{itemize}
\begin{quote}

\sphinxAtStartPar
\(Z \left(c_0\ket{0} + c_1 \ket{1}\right) = c_0\ket{0} - c_1 \ket{1}\)
\end{quote}

\sphinxAtStartPar
When \(Z\) acts on \(\ket{1}\), the ket acquires a new phase “\(-\)”. Since the global phase is irrelevant, the operator essential does nothing thing to \(\ket{0}\) nor \(\ket{1}\). However, when it acts on a superposition state, the relative phase between \(\ket{0}\) and \(\ket{1}\) changes.

\sphinxAtStartPar
Any operator \(A\) In \(\mathbb{C}^2\) can be decomposed as
\begin{equation*}
\begin{split}
A = c_0 I + c_1 X + c_2 Y + c_3 Z
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(c_0 = \text{tr}(I A)\), \(c_1 = \text{tr}(X A)\), \(c_2 = \text{tr}(Y A)\), and \(c_3 = \text{tr}(Z A)\).  This decomposition suggests that we need only \(I\) and the Pauli operators to transform a qubit.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.8     Initially a qubit is in \(\ket{0}\). We want to transform it to \(\ket{-} = \frac{1}{\sqrt{2}} \left(\ket{0} - \ket{1}\right)\). In previous sections, we learn that the Hadamard gate transforms \(\ket{1}\) to \(\ket{-}\). Pick two operators from \(X\), \(Z\), \(H\), and construct a quantum circuit that transforms \(\ket{0}\) to \(\ket{-}\).  There are two possible combinations. Find both.  (The following Qiskit example veryify the solutions.

\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example}

\sphinxAtStartPar
We shall demonstrate the two solution to the above exercise using Qiskit.  We use two qubits.  Initially they are both in \(\ket{0}\).  Then, we apply different gates to them. At the end, both should be in \(\ket{-}\).  In this example, we use \sphinxcode{\sphinxupquote{statevector\_simulator}} which calculate the transformation exactly.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\PYG{c+c1}{\PYGZsh{} declare to use two qubit}
\PYG{n}{qr} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} reset a quantum circuit with the two qubit}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} We apply X and H on the first qubit}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} We apply H and Z on the second qubit}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{z}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show the circuit}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mpl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{operators_28_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} We use state vector simulator}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{statevector\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{=}\PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot\PYGZus{}bloch\PYGZus{}multivector plots Bloch vector for each qubit.}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}
\PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Find that both qubits are |\PYGZhy{}\PYGZgt{} }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{operators_29_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Qiskit note: Pauli Operators}

\sphinxAtStartPar
In \hyperref[\detokenize{qmsummary/vectors:sec-statevectors}]{Section \ref{\detokenize{qmsummary/vectors:sec-statevectors}}}, we calculated inner products of computational basis using \sphinxcode{\sphinxupquote{qiskit.opflow}} module.  The same module provides predefined Pauli operators  \sphinxcode{\sphinxupquote{I}}, \sphinxcode{\sphinxupquote{X}}, \sphinxcode{\sphinxupquote{Y}}, and \sphinxcode{\sphinxupquote{Z}}.   Applying operator on ket is done with “@”.  For example \(X \ket{0}\) is \sphinxcode{\sphinxupquote{(X@One).eval()}} in Qiskit.

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/apidoc/opflow.html}{QIskit API Reference: qiskit.opflow}
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{opflow} \PYG{k+kn}{import} \PYG{n}{Zero}\PYG{p}{,} \PYG{n}{One}\PYG{p}{,} \PYG{n}{I}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{Z}

\PYG{c+c1}{\PYGZsh{} Show that I|0\PYGZgt{}=|0\PYGZgt{} and (|1\PYGZgt{}=|1\PYGZgt{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I|0\PYGZgt{} == |0\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{I}\PYG{n+nd}{@Zero} \PYG{o}{==} \PYG{n}{Zero}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I|1\PYGZgt{} == |1\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{I}\PYG{n+nd}{@One} \PYG{o}{==} \PYG{n}{One}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show that Z|0\PYGZgt{}=|1\PYGZgt{} and X|1\PYGZgt{}=|0\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{} X*ket must be evaluated by .eval()}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X|0\PYGZgt{} == |1\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{X}\PYG{n+nd}{@One}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{Zero}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X|1\PYGZgt{} == |0\PYGZgt{} }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{X}\PYG{n+nd}{@Zero}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{One}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Check if X is self\PYGZhy{}sdjoint}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X is self\PYGZhy{}adjoint }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{o}{\PYGZti{}}\PYG{n}{X} \PYG{o}{==} \PYG{n}{X}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Check if X is unitary}
\PYG{c+c1}{\PYGZsh{} I and X are defined in different way, we need to eval() in both sieds.}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X is unitary }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{X} \PYG{o}{@} \PYG{n}{X}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{I}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
I|0\PYGZgt{} == |0\PYGZgt{}  True
I|1\PYGZgt{} == |1\PYGZgt{}  True

X|0\PYGZgt{} == |1\PYGZgt{}  True
X|1\PYGZgt{} == |0\PYGZgt{}  True

X is self\PYGZhy{}adjoint  True
X is unitary  True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.9     Demonstrate \(Z\ket{0}=\ket{0}\) and \(Z\ket{1}=-\ket{1}\) using the \sphinxcode{\sphinxupquote{qiskit.opflow}} module.


\bigskip\hrule\bigskip


\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}
\PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}\PYG{p}{(}\PYG{n}{One}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{operators_33_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Functions of operators}
\label{\detokenize{qmsummary/operators:functions-of-operators}}
\sphinxAtStartPar
A function \(f(x)\) maps an input value \(x\) to an output value \(f\).  Then what \(f(A)\) means if \(A\) is an operator? It is interpreted as a map from an operator \(A\) to another operator \(f\).  For example exponential function \(e^x\) is a number and \(e^A\) is an operator. But it is not clear how the function of of operator is applied to a vector?  We define \(e^A\) using a power series (Taylor expansion).  For example,
\begin{equation*}
\begin{split}
e^x = 1 + x + \frac{1}{2}x^2 + \cdots + \frac{1}{n!}x^n + \cdots
\end{split}
\end{equation*}
\sphinxAtStartPar
Now we replace 1 with \(I\) and \(x\) with \(A\).
\begin{equation*}
\begin{split}
e^A = I + A + \frac{1}{2} A^2 + \cdots \frac{1}{n!} A^n + \cdots
\end{split}
\end{equation*}
\sphinxAtStartPar
Since we know how to calcuate the product of operators, there is no problem with \(A^n\).  Hence, we evaluate
\begin{equation*}
\begin{split}
e^A \ket{\psi} = I \ket{\psi} + A \ket{\psi} + \cdots + \frac{1}{n!} A^n \ket{\psi} + \cdots.
\end{split}
\end{equation*}
\sphinxAtStartPar
For a general function \(f(A)\), we assume that \(f(x)\) is a nice smooth function which can be expanded in a power series.  Then, the function of opperator is understood as
\begin{equation*}
\begin{split}
f(A) = I + c_1 A + c_2 A^2 + \cdot + c_n A^n + \cdots, \qquad \text{where  } c_n = \frac{1}{n!} \frac{d f}{dx} \Big|_{x=0}
\end{split}
\end{equation*}
\sphinxAtStartPar
We don’t consider a function singular at \(x=0\) like \(\log{A}\).

\sphinxAtStartPar
A special care is required for a function of multiple operators.  For example we are familiar with  \(e^{x+y} = e^x e^y,\,\) if \(x\) and \(y\) are regular numbers.  In contrast,  \(e^{A+B} \ne e^A e^B,\,\,\) if \([A,B]\ne 0\).


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qmsummary/operators:sec-operators}]{\ref{\detokenize{qmsummary/operators:sec-operators}}}.10     For Pauli operator \(X\), show that \(\,e^{i \theta X} = I \cos \theta - i X \sin \theta \,\) where \(\theta\) is a real number. Hint: Use \(X^2=I\) in the power series.

\sphinxAtStartPar
When \(\theta=\frac{\pi}{4}\), the equality indicates that \(e^{i \frac{\pi}{4} X} = \frac{1}{\sqrt{2}}  ( I - i X)\).  Applying the operator on \(\ket{0}\) we obtain \(e^{i \frac{\pi}{4} X}\ket{0} = \frac{1}{\sqrt{2}} \left (\ket{0}  - i \ket{1} \right)\).
In the following Qiskit example, we will check it using \sphinxcode{\sphinxupquote{qiskit.opflow}} module.


\bigskip\hrule\bigskip


\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} import numpy}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} import qiskit.opflow}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{opflow} \PYG{k+kn}{import} \PYG{n}{Zero}\PYG{p}{,} \PYG{n}{One}\PYG{p}{,} \PYG{n}{I}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{Z}

\PYG{c+c1}{\PYGZsh{} we use Statevector class for vidualization}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c+c1}{\PYGZsh{} construct the exponential operator using a method exp\PYGZus{}i()}
\PYG{c+c1}{\PYGZsh{} X.exp\PYGZus{}i() creates exp(i X)}
\PYG{n}{expX}\PYG{o}{=}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{X}\PYG{p}{)}\PYG{o}{.}\PYG{n}{exp\PYGZus{}i}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} evaluate expX * Zero}
\PYG{n}{psi}\PYG{o}{=}\PYG{p}{(}\PYG{n}{expX}\PYG{n+nd}{@Zero}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} print out the results}
\PYG{c+c1}{\PYGZsh{} attribute \PYGZsq{}primitive\PYGZsq{} extracts the information of the vector}
\PYG{c+c1}{\PYGZsh{} method \PYGZsq{}draw(\PYGZsq{}latex\PYGZsq{})\PYGZsq{} print out the vector using LaTeX.}
\PYG{c+c1}{\PYGZsh{} The detailed usage of attributes and methods are given in later chapters.}
\PYG{n}{psi}\PYG{o}{.}\PYG{n}{primitive}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\frac{\sqrt{2}}{2} |0\rangle- \frac{\sqrt{2} i}{2} |1\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
Version 0.8.0:   Last modified on May 3, 2022

\sphinxstepscope


\section{Time\sphinxhyphen{}evolution}
\label{\detokenize{qmsummary/evolution:time-evolution}}\label{\detokenize{qmsummary/evolution:chap-time-evolution}}\label{\detokenize{qmsummary/evolution::doc}}
\sphinxAtStartPar
The state of the classical particles change according to the Newton equation, which is a set of ordinary differential equations. Equivalently,  the trajectory can be computed from the Hamilton equations of motion, by measurement
\begin{equation*}
\begin{split}
\dot{q} = \frac{\partial H}{\partial p}, \qquad \dot{p} = -\frac{\partial H}{\partial q}
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(H\) is a Hamiltonian.

\sphinxAtStartPar
The state vector of a quantum system evolves in time according to the Schrödinger equation
\begin{equation*}
\begin{split}
i \frac{\partial}{\partial t} |\psi\rangle = H |\psi\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(H\) is Hamiltonian operator.  Equivalently,  the solution can be written as
\begin{equation*}
\begin{split}
|\psi(t)\rangle = U(t) |\psi(0)\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(U(t)\) is a unitary operator and \(|\psi(0)\rangle\) an initial state.  We call this type of evolution \sphinxstyleemphasis{unitary} evolution. Quantum computation solves this equation.  We will solve it using \sphinxcode{\sphinxupquote{Qiskis}}.


\bigskip\hrule\bigskip


\sphinxAtStartPar
(version 0.0.1:     Lat modified on April 7, 2022)

\sphinxstepscope


\section{Quantum measurement}
\label{\detokenize{qmsummary/measurement:quantum-measurement}}\label{\detokenize{qmsummary/measurement:chap-measurement}}\label{\detokenize{qmsummary/measurement::doc}}
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/Measurement\_in\_quantum\_mechanics}{Wikipedia: Measurement in quantum mechanics}

\sphinxAtStartPar
An important role of theoretical physics is to predict physical quantities such as energy and experimental physics tries to measure them.  Without measurement as accurate as possible.  Without measurement, there is no physics.

\sphinxAtStartPar
In classical mechanics, we can obtain a precise value from any  physical quantity  upon measurement and we can predict it by solving the Newton equation.  If the same measurement is done on identical copies of the original system, the same value is always obtained. If the outcomes differ, then that must be due to measurement error (e.g., a bad measurement device).

\sphinxAtStartPar
In quantum mechanics, as we already discussed in previous chapters, the outcomes of measurement is \sphinxstyleemphasis{stochastic} even when the measurement apparatus is perfect. The principle of quantum mechanics cannot predict the outcome of single measurement. Only we can predict is the probabilities.   In this chapter, we present a formal theory of quantum measurement.


\subsection{Observables}
\label{\detokenize{qmsummary/measurement:observables}}
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/Observable}{Wikipedia: Observable}

\sphinxAtStartPar
We haven’t discussed how to describe physical quantities in quantum mechanics.  They are not number.  They are a special kind of operators in the Hilbert space of a quantum system. The operators corresponding to physical quantities are called \sphinxstyleemphasis{observable}.
In order for operator \(A\) to be observable, it must be \sphinxstyleemphasis{Hermitian} (self\sphinxhyphen{}adjoint).  That is \(A^\dagger = A\).  Since it satisfies \([A^\dagger, A]=0\), the observable is also a \sphinxstyleemphasis{normal} operator,  which guarantees that the observable has eigenvalues \(a_i\) and eigenvectors \(\ket{e_i}\).  Thus we have
\begin{equation*}
\begin{split}
A \ket{a_i} = a_i \ket{a_i}, \quad i=1,\cdots,d
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(d\) is the dimension of Hilbert space.  There are two important properties of the observable:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
all eigenvalues are real

\item {}
\sphinxAtStartPar
eigenvectors form a complete orthonormal basis

\end{enumerate}

\sphinxAtStartPar
which are essential to the quantum measurement.

\sphinxAtStartPar
In quantum computation,  computational basis vectors \(\ket{0}\) and \(\ket{1}\) are the eigenvectors of a Pauli operator \(Z\).  Hence, we measure \(Z\).


\subsection{Outcomes of measurement}
\label{\detokenize{qmsummary/measurement:outcomes-of-measurement}}
\sphinxAtStartPar
When we measure a physical quantity, we expect that the outcome is a number, not an operator.  The role of operator (observable) is to determine possible outcome.  The outcome of the measurement must be an eigenvalue of the observable.  We obtain one of \(a_i\) when \(A\) is measured.  But there are many eigenvalues.  Which one are we going to obtain?   Quantum mechanics can’t tell us what precisely we get.  No one can predict it. Only we know the probability to obtain a particular eigenvalue.   If the state of the system is \(\rho\), the probability of finding \(a_i\) is given by
\begin{equation}\label{equation:qmsummary/measurement:born-rule-density}
\begin{split}
p_i = \bra{a_i} \rho \ket{a_i}.
\end{split}
\end{equation}
\sphinxAtStartPar
which is vaklid for both pure and mixed states.

\sphinxAtStartPar
For pure state, we already use the probability.  Consider the system on a pure state \(\ket{\psi}\), we expand it in basis \(\{\ket{a_i}\}\) (We can do so since the eigenvectors form a complete orthonormal basis):
\begin{equation*}
\begin{split}
\ket{\psi} = c_1 \ket{a_1} + c_2 \ket{a_2} + \cdots + c_d \ket{a_d}
\end{split}
\end{equation*}
\sphinxAtStartPar
The Born rule indicates that we obtain \(a_i\)  with probability \(p_i= |c_i|^2 = |\langle a_i | \psi \rangle |^2\).  Recalling that the density operator of  the pure state is \(\rho = \ket{\psi}\bra{\psi}\), Eq. \eqref{equation:qmsummary/measurement:born-rule-density} gives the same probability.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise}  \hyperref[\detokenize{qmsummary/measurement:chap-measurement}]{\ref{\detokenize{qmsummary/measurement:chap-measurement}}}.1   Show that \(\bra{a_i} \rho \ket{a_i} =  |\langle a_i | \psi \rangle |^2\) for the pure state \(\ket{\psi}\).


\bigskip\hrule\bigskip



\subsection{Projective measurement}
\label{\detokenize{qmsummary/measurement:projective-measurement}}
\sphinxAtStartPar
In classical mechanics, we can measure a physical quantity without disturbing the system state.  That is not the case of quantum systems.  When  the measurement results in \(a_i\), the state also is transformed to \(\ket{a_i}\) regardless of the original state before the measurement.  This transformation is known as \sphinxstyleemphasis{wave function collapse}.  The mechanism of the collapse is still not known but we are able to explain experiment results based on this postulate.  No exception has been reported since the inception of quantum mechanics 100 years ago.

\sphinxAtStartPar
Recall that the quantum mechanics is is applied to an ensemble and measurement is needed to be repeated.  If we throw away other states and keep only \(\ket{a_i}\), then the resulting state is a pure state \(\ket{a_i}\).  This kind of measurement is called \sphinxstyleemphasis{selective measurement}.   On the other hand, if we keep all outcomes (\sphinxstyleemphasis{non\sphinxhyphen{}selective measurement}), we have a classical mixture of \(\ket{a_i}\) with probability \eqref{equation:qmsummary/measurement:born-rule-density}:
\begin{equation}\label{equation:qmsummary/measurement:rho-out}
\begin{split}
\rho_\text{out} = \sum_i p_i \ket{a_i}\bra{a_i}  = \sum_i \ket{a_i}\bra{a_i} \rho_\text{in} \ket{a_i}\bra{a_i}.
\end{split}
\end{equation}
\sphinxAtStartPar
where \(\rho_\text{in}\) and \(\rho_\text{out}\) are the density operators before and after the measurement, respectively.   Noting that \(\ket{a_i}\bra{a_i}\) is a projection operator, we can interpret Eq. \eqref{equation:qmsummary/measurement:rho-out} as a projection of the state to \(\ket{a_i}\) and this type of measurement is called \sphinxstyleemphasis{projective measurement}.


\subsection{Expectation values}
\label{\detokenize{qmsummary/measurement:expectation-values}}

\subsection{Uncertainty principle}
\label{\detokenize{qmsummary/measurement:uncertainty-principle}}
\sphinxAtStartPar
In classical mechanics, we can obtain a precise value from any  physical quantity  upon measurement and we can predict it by solving the Newton equation.  If the same measurement is done on indentical copies of the original system, the same value is always obtained. If the outcomes differ, then tha must be due to measurement error (e.g., a bad measurement device).

\sphinxAtStartPar
In quantum mechanics, as we already discussed in previous chapters, the outcomes of measurement is \sphinxstyleemphasis{stochastic} even when the measurement apparatus is perfect. The principle of quantum mechanics cannot predict the outcome of single measurement. Only we can predict is the probabilities.   In this chapter, we present a formal theory of quantum measurement.

\sphinxAtStartPar
When we have many copies of the identical quantum states, the outcomes of measurement are usually different.  What quantum mechanics can tell us is a \sphinxstyleemphasis{probability} of finding a particular value.  That means that the outcome of  measurement is randomly chosen according to the probability.  Only in special cases, we can get the same value from the all copies,  which we can predict from the state vector.

\sphinxAtStartPar
When the outcome is stochastic, we need to resort to the methods of statistics. Computing expectation value and standard deviation is essential since we can predict them based on the current theory of quantum mechanics.

\sphinxAtStartPar
Furthermore, the measurement changes the state and the new state depends on the value of the outcome.  When the measurement picked an eigenvalue of the observable, the state jumps to the corresponding eigenvector. This jump cannot be described by the current theory of quantum mechanics.  \sphinxstyleemphasis{Decoherence} may explain a part of this process but the detail remains unclear.

\sphinxAtStartPar
In addition to the stochastic nature of quantum measurement, there is another notable difference between classical and quantum measurements.  In classical mechanics,  we can determine the precise values of two or more physical quantities simultaneously by measurement. That may not be possible in quantum mechanics depending on what you measures.  For example, the position and momentum of a classical particle can be precisely determined. In quatum mechanics, on the other hand, if both quantities are measured from many identical copies, it is impossible to have the same outcome from the all copies.  If all copies have the same position, then every copy has very different value of momentum.  In typical cases, each copy results in a pair of different values from other copies, hence there are uncertainties in both quantities.

\sphinxAtStartPar
The interpretation of quantum measurement is very counter intuitive. We still don’t know  how quantum measurement takes place.  Many physicists are not fully convinced by the current theory of quantum mechanics and believe that the theory of quantum mechanics is still incomplete.   There are other interpretation of quantum mechanics such as the pilot wave theory. However, all experimental results agree with the probabilities computed from the state vector.  Therefore, we adopt the standard theory of quantum mechanics in this book.

\sphinxAtStartPar
Finding the state of a system is not necessarily the final goal of physics.  We want to know the  values of other quantities such as  energy  In classical mechanics, physical quantities are naturally defined as number and the measurement of a physical quantity produces a unique value.  On contrary to our intuition, physical quantities in quantum mechanics are not number.  They are \sphinxstyleemphasis{self\sphinxhyphen{}adjoint operator} in the Hilbert space.  The outcome of a measurement is one of the \sphinxstyleemphasis{eigenvalues} of the operator and we don’t know which one will be the result of the measurement.  This strange behaviors are the next topics.

\sphinxAtStartPar
\sphinxstylestrong{Related topics in Wikipedia}
\begin{itemize}
\item {}
\sphinxAtStartPar
 Measurement in quantum mechanics

\item {}
\sphinxAtStartPar
Observable

\item {}
\sphinxAtStartPar
Born rule

\item {}
\sphinxAtStartPar
Wave function collapse

\end{itemize}


\bigskip\hrule\bigskip


\sphinxAtStartPar
Version 0.1.0:   Last modified on May 3, 2022

\sphinxstepscope


\part{Introduction}

\sphinxstepscope


\chapter{What is a Quantum Computer?}
\label{\detokenize{computation/intro:what-is-a-quantum-computer}}\label{\detokenize{computation/intro:chap-whatisqcomp}}\label{\detokenize{computation/intro::doc}}
\sphinxAtStartPar
In modern life style, computers are used everywhere, inside cars, TV sets, kitchen appliances and cell phones, to name a few.  They are all operated in the same way with classical \sphinxstyleemphasis{bits}.  The principles of computation are developed by major mathematicians such as Alan Turing (\sphinxhref{https://en.wikipedia.org/wiki/Turing\_machine}{universal Turing machine}) and von Neumann (\sphinxhref{https://en.wikipedia.org/wiki/Von\_Neumann\_architecture}{von Neumann architecture}).  Furthermore, classical \sphinxhref{https://en.wikipedia.org/wiki/Information\_theory}{information theory} developed by another genius mathematician, Claude Shannon advanced the classical computation to a much higher level.

\sphinxAtStartPar
While the classical computation technology is matured, the \sphinxhref{https://en.wikipedia.org/wiki/Computability\_theory}{computability theory} shows that there are many hard problems that cannot be solved by the classical computer. See for example \sphinxhref{https://en.wikipedia.org/wiki/Travelling\_salesman\_problem}{travelling salesman problem}.  The demands of new computers that can solve such hard problems keep rising.  On the other hand, the current encryption based on \sphinxhref{https://en.wikipedia.org/wiki/RSA\_(cryptosystem)}{RSA keys} works precisely because classical computers have the limitation.  However, in 1994 Peter Shore found a \sphinxstyleemphasis{quantum algorithm} to breaking the RSA encryption.  If quantum computers should become available, data security based on the RSA keys would be obsolete. This is a national security problem (\sphinxhref{https://www.whitehouse.gov/briefing-room/statements-releases/2022/05/04/national-security-memorandum-on-promoting-united-states-leadership-in-quantum-computing-while-mitigating-risks-to-vulnerable-cryptographic-systems/}{See this national security memorandom on May 4, 2022})  and it is quickly becoming a real issue.  \sphinxhref{https://www.nature.com/articles/d41586-022-00339-5\#:~:text=The\%20quantum\%20computer\%20revolution\%20could,secure\%20algorithms\%20can\%20safeguard\%20privacy.\&text=In\%20cybersecurity\%20circles\%2C\%20they\%20call,relentless\%20hum\%20of\%20cryptographic\%20algorithms.}{See “The race to save the Internet from quantum hackers”}.

\sphinxAtStartPar
So, what is a quantum computer?  It is our current understanding that all physical phenomena are governed by quantum mechanics. The computer you are using is indeed built upon the laws of quantum mechanics. Electrons in the semiconductor chips must be treated as quantum particles.  Nevertheless, it is called classical computer.  The difference between classical and quantum computing is how \sphinxstyleemphasis{information} is stored and processed.  Information must be stored in certain \sphinxstyleemphasis{stable} physical states.  If they are unstable, information is lost quickly.  Information in classical devices is safely stored in  macroscopic states against disturbances from the environment but an important signature of quantum mechanical behavior, \sphinxstyleemphasis{coherence}, is completely abandoned.  On the other hand, quantum computers store in information in a microscopic state which is fragile and easily disturbed by the environmental noises but quantum mechanical coherence is used as computational resources.  The recent advances in quantum technology have made it possible to keep quantum information alive long enough to carry out computation.

\sphinxAtStartPar
In this chapter, I  briefly introduce basic idea of classical and quantum computers and discuss what can be advantage of quantum computers over classical ones.

\sphinxstepscope


\section{Classical computation}
\label{\detokenize{computation/ccomp:classical-computation}}\label{\detokenize{computation/ccomp:sec-ccomp}}\label{\detokenize{computation/ccomp::doc}}
\sphinxAtStartPar
We carry out classical computation every day on many different devices, laptop computers, mobile phones, automobiles, smart TVs, refrigerators, …  to name a few. These devices are made from semiconductors chips and optionally magnetic materials and their functionalities are governed by quantum mechanics.  Nevertheless, we call them \sphinxstyleemphasis{classical computer}. Why?   While the underlying physical processes are quantum mechanical, \sphinxstyleemphasis{information} stored and processed in these materials is classical.  For example,  macroscopic electric current and voltage, which are classical quantities, are used to store and process information.  In other words, a large number of electrons are used to store even the smallest amount of information.  In contrast, quantum computation relies on microscopic states , e. g.,  energy eigenstates in an atomic ion.  In th following, we discuss what is the classical information and how it is processed in the classical devices.


\subsection{What is classical information?}
\label{\detokenize{computation/ccomp:what-is-classical-information}}
\sphinxAtStartPar
We  ask a question because we do not know something and try to find it.  In other words, wey to get new \sphinxhref{https://en.wikipedia.org/wiki/Information}{information}.  But what is information and can we quantify the amount of information?  To answer this question, \sphinxhref{https://en.wikipedia.org/wiki/Information\_theory}{information theory} was developed in the first half of twenty century by \sphinxhref{https://en.wikipedia.org/wiki/Claude\_Shannon}{Claude Shannon} and others.

\sphinxAtStartPar
In essence,  the amount of information we obtain is the amount of uncertainty decreased.  If there is no uncertainty, there is nothing to ask.  The undertainties arise in several different ways.  The outcome of an event that is going to happen in future can be uncertain if we cannot predict it precisely.  The uncertainty is due to the stochastic nature of the event.  IIn another case, the event has already happened and some people know  the outcome but we dont’ know it.  For us, this is uncertainty but it is due to our ignorance.  In either case,  once we know the outcome, the uncertainty disappears and we obtain the information.

\sphinxAtStartPar
The uncertainty can be mathematically expressed as probability.  Consider coin tossing.  For tossing the coin, no one knows the outcome.  However, we know that the outcome must be one of head and tail.  We cannot predict the outcome because the motion of th coin is chaotic and thus the outcome is stochastic.  Assuming the coin is ideal, the probability of finding head and tail ares \(p_\text{head} = \frac{1}{2}\) and \(p_\text{tail}=\frac{1}{2}\), which is the uncertainty associated with the coin tossing.  The amount of the information (undertainty) is given by
\begin{equation*}
\begin{split}
H = - p_\text{head} \log p_\text{head} - p_\text{tai} \log p_\text{tail} = \log 2
\end{split}
\end{equation*}
\sphinxAtStartPar
which is known as \sphinxstyleemphasis{Shannon entropy} or \sphinxstyleemphasis{information entropy}.  If base 2 is used, \(\log_2 2 = 1\) and  we say one \sphinxstyleemphasis{bit} of information is gained.  Here \sphinxstyleemphasis{bit} is the unit of the amount of information.

\sphinxAtStartPar
After the coin is tossed and landed on someone’s hand,  the outcome is not known to us until the person shows it.  The uncertainty is due to ignorance but the amount of information we will find remain the same.

\sphinxAtStartPar
Here is the general definition of the Shannon entropy
For a set of all possible outcomes, \(\{\omega_1, \omega_2, \cdots, \omega_N\}\) where \(N\) is the total number of possible outcomes and the probability \(p_i\) of finding the outcome \(\omega_i\) for all \(i\) is defined,  the amount of  information  is measured by
\$\(
H = - \sum_{i=1}^N p_i \log p_i.
\)\$


\subsection{Classical bits}
\label{\detokenize{computation/ccomp:classical-bits}}
\sphinxAtStartPar
Selecting one out of two possibilities is the simplest question.  Coin tossing is one of them. In classical computer the smallest  information unit has two possibilities \(\texttt{0}\) and \(\texttt{1}\), which are assigned to two well\sphinxhyphen{}defined physical states in the devices, e.g.,  \(\texttt{0}\) to \(0\) volt and \(\texttt{1}\) to \(1\) volt if the voltage is used.

\sphinxAtStartPar
Mathematicall, we use a variable \(b \in \{\texttt{0},\texttt{1}\}\) for a single bit.  The computer consists of many bits, bit 0, bit 1, bit 2, …….  For convenience, we denote the bits as \(b_0, b_1, b_2, \cdots \) and altogether the information is stored in a string of n bits, \('\, b_{n-1}\, b_{n-2}\, \cdots\, b_1\, b_0\, '\), for example ‘0010101’ (in this book, the bit string is in single quotes.)  Notice the order of bits in the string.  It is the standard to write string from the right to the left.


\subsection{Copying a state of bit}
\label{\detokenize{computation/ccomp:copying-a-state-of-bit}}
\sphinxAtStartPar
In classical computers, the information is stored as bit strings in random access memory (RAM).  To process information, the bit strings are copied to the central proccessing unit (CPU).  After the information is processed, the outcome is copied to some location in RAM.   Copying the bits is a fundamental aspect of classical information processsing. As you see below, the input information is usually lost in during processing in CPU.  In contrast, quantum computation does not have such luxury since cloning of quantum state is not possible (\sphinxstyleemphasis{no cloning theorem}).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{ccomp}.png}
\caption{A schematic diagram of information flows in a typical classical computer.  The state of classical bit can be copied to another classical bit with no restriction.}\label{\detokenize{computation/ccomp:ccomp}}\end{figure}


\subsection{Gates}
\label{\detokenize{computation/ccomp:gates}}
\sphinxAtStartPar
The computer can change the state of any bit as directed by a program.  A simple operation is to flip a bit, that is \(0\rightarrow 1\)  and \(1 \rightarrow 0\).  We express it using a concept of \sphinxstyleemphasis{gate}.  A bit enters a gate and comes out with a different value.  In the classical computer, there are only two possibility,  no flip or flip.  “No flip” means nothing happens to the bit and thus we are not interesting it.  The gate that flips a bit is called \sphinxcode{\sphinxupquote{NOT}} gate. (See \hyperref[\detokenize{computation/ccomp:classical-gates}]{Fig.\@ \ref{\detokenize{computation/ccomp:classical-gates}}}.)  This is the only gate acts on a single bit outputs a single bit.  The relation between the input and the output bit is given in the truth \hyperref[\detokenize{computation/ccomp:classical-not}]{table \ref{\detokenize{computation/ccomp:classical-not}}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{NOT Gate}\label{\detokenize{computation/ccomp:classical-not}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar

&\sphinxstyletheadfamily
\sphinxAtStartPar
\(i\)
&\sphinxstyletheadfamily
\sphinxAtStartPar

&\sphinxstyletheadfamily
\sphinxAtStartPar
\(o\)
&\sphinxstyletheadfamily
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

&
\sphinxAtStartPar
1
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
1
&
\sphinxAtStartPar

&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Classical computation uses various kind of gates which takes two input bits (\(i_0\) and \(i_1\)) and outputs one bit.  For example, \sphinxcode{\sphinxupquote{AND}} gate outputs \(i_0 \times i_1\).  (See \hyperref[\detokenize{computation/ccomp:classical-gates}]{Fig.\@ \ref{\detokenize{computation/ccomp:classical-gates}}}.)
The corresponding truth table is given in \hyperref[\detokenize{computation/ccomp:classical-and}]{Table \ref{\detokenize{computation/ccomp:classical-and}}}.  Notice that this process is \sphinxstyleemphasis{irreversible}, meaning that we cannot recover the input information \(i_0\) and \(i_1\) from the output \(o\).  Hence, we says that a bit of information is lost.  Two\sphinxhyphen{}bit classical gates  are in general irreversible and 1 bit of information is lost.  However, this is not a major issue since classical bits can be cloned and saved in a separate bit string.

\sphinxAtStartPar
In principle, classical computation needs only \(\texttt{NOT}\) and \(\texttt{AND}\) gates.  It is using other gates makes classical computing much more efficient.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{AND Gate}\label{\detokenize{computation/ccomp:classical-and}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar

&\sphinxstyletheadfamily
\sphinxAtStartPar
\(i_0\)
&\sphinxstyletheadfamily
\sphinxAtStartPar

&\sphinxstyletheadfamily
\sphinxAtStartPar
\(i_1\)
&\sphinxstyletheadfamily
\sphinxAtStartPar

&\sphinxstyletheadfamily
\sphinxAtStartPar
\(o\)
&\sphinxstyletheadfamily
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

&
\sphinxAtStartPar
1
&
\sphinxAtStartPar

&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
1
&
\sphinxAtStartPar

&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
1
&
\sphinxAtStartPar

&
\sphinxAtStartPar
1
&
\sphinxAtStartPar

&
\sphinxAtStartPar
1
&
\sphinxAtStartPar

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{classical-gate}.png}
\caption{An example of classical gates. The \(\texttt{NOT}\) gate takes one bit and output one bit.}\label{\detokenize{computation/ccomp:classical-gates}}\end{figure}


\subsection{Landauer principle}
\label{\detokenize{computation/ccomp:landauer-principle}}
\sphinxAtStartPar
The irreversibility of classical gates has important physical consequence.  \sphinxhref{https://en.wikipedia.org/wiki/Landauer\%27s\_principle}{\sphinxstyleemphasis{Landauer’s principle}} states that the loss of one bit of information necessarily dissipates \(k_B T \log 2\) of heat. For example, every time an  \(\texttt{AND}\) gate is used, at least \(k_B T \log 2\) of heat must be generated. This heat is actually minute and much smaller than Joule heat that makes CPU really hot. Therefore, it odes not causes a significant problem.  However, it imposes a theoretical limit of classical computation.  In contrast, quantum computing is reversible and thus no dissipation is mandatory.

\sphinxAtStartPar
\sphinxstylestrong{Exercise}  Is \(\texttt{NOT}\) gate reversible?


\subsection{Encoding}
\label{\detokenize{computation/ccomp:encoding}}
\sphinxAtStartPar
The computer can understand only bit strings and manipulates them by applying gates.  However, problems we want to solve are usually not expressed in bit strings.  Somehow, we need to map the problems to bit strings the computer can understand. In other words, we need to \sphinxstyleemphasis{encode} the information in our expression to the bit strings. As a simple example, we consider a boolean operation between two logical variables \(x\) and \(y\).  Their value is either \(\texttt{True}\) or \(\texttt{False}\).   Since the valiables takes only one of two possibilities, the mapping between the boolean variables and bits are naturally
\begin{equation*}
\begin{split}
\texttt{False} \Rightarrow \texttt{0}, \quad \texttt{True} \Rightarrow \texttt{1}
\end{split}
\end{equation*}
\sphinxAtStartPar
Now, variable \(x\) is expressed by a bit \(b_0\) and \(y\)  by \(b_1\).

\sphinxAtStartPar
In many problems, encoding is not obvious at all.  Integer numbers can be mapped to bit strings using their binary expressions.  For example, \(5 \Rightarrow \texttt{101}\), which requires three bits.  Exact encoding of continuous numbers is not possible  since bits are digital.  Approximated representation such as \sphinxhref{https://en.wikipedia.org/wiki/Floating-point\_arithmetic}{\sphinxstyleemphasis{floating point arithmetic}} numbers are used.


\subsection{Instructions}
\label{\detokenize{computation/ccomp:instructions}}
\sphinxAtStartPar
Computation means that by manipu, quantum or classicallating the state of bits toward the solution.  The device can flip the specified bits .  It can be thought of bits entering a \sphinxstyleemphasis{gate} and coming out with different values.  We need to instruct the device how to change the state of the bits.  In other words we to find find what gates should be applied to the bits. Let us consider a simple operation \(x+y \mod 2\) where \(x, y \in \{0, 1\}\).  WE shall write this operation simply as \(x \oplus y\) . We map \(x\) and \(y\) to bits \(b_0\) and \(b_1\). Applying an \sphinxcode{\sphinxupquote{XOR}} gate on \(q_0\) and \(b_1\) produces desired outputs.   The following diagram classically computes \(x \oplus y\) and the output is stored in \(x\). The value of \(y\) remains the same.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{classical-half-adder}.png}
\caption{An example of classical circuit.  This circuit computer \(x \oplus y\) using \(\texttt{XOR}\) and \(\texttt{AND}\).  In addition to the answer, carry over bit}\label{\detokenize{computation/ccomp:classical-half-adder}}\end{figure}

\sphinxAtStartPar
In real world applications, we don’t apply the gates by ourselves.  Instead, we use a programming language such as \sphinxcode{\sphinxupquote{python}}. The language translates the mathematical  expression such as \(x + y\) into gate instructions. So, we really don’t need to know about the classical gate.  Quantum computation has not reached that level yet. Users must picks appropriate gates by themselves.


\subsection{Readout and decoding}
\label{\detokenize{computation/ccomp:readout-and-decoding}}
\sphinxAtStartPar
Once the computation is completed at the device level, we need to read out the values of the bits and decode the outcome to an integer.  The readout of the classical bits can be done without damaging their state.  The value of the classical bits remains the same before and after the readout.  (That is not the case in quantum computers.)

\sphinxstepscope


\section{Quantum computation}
\label{\detokenize{computation/qcomp:quantum-computation}}\label{\detokenize{computation/qcomp:sec-qcomp}}\label{\detokenize{computation/qcomp::doc}}
\sphinxAtStartPar
Here is a brief description of quantum computer and the details will be discussed in this book.  It is necessary for you to understand the following at this stage.  Just read them and move on.


\subsection{Qubits}
\label{\detokenize{computation/qcomp:qubits}}
\sphinxAtStartPar
Quantum computers are also made of many small building blocks but unlike classical computers we need to use quantum mechanics to describe their state. Current quantum computers use the smallest quantum system, that is a two\sphinxhyphen{}dimensional Hilbert space \(\mathbb{C}_2\) spanned by complex vectors \(\lvert 0 \rangle\) and \(\lvert 1 \rangle\), known as \sphinxstyleemphasis{qubit}. These two basis states looks similar to \sphinxcode{\sphinxupquote{0}} and \sphinxcode{\sphinxupquote{1}} for a classical bit . However, unlike the classical bit,  the state of a qubit  can be in a superposition state
\begin{equation}\label{equation:computation/qcomp:eqn:superposition}
\begin{split}
\ket{\psi} = c_{0} \lvert 0 \rangle + c_{1} \lvert 1 \rangle
\end{split}
\end{equation}
\sphinxAtStartPar
where \(c_0\) and \(c_1\) are complex number satisfying \(|c_0|^2+|c_1|^2=1\) (normalization). Similarly to the classical bit, we obtain either \(\ket{0}\) or \(\lvert 1 \rangle\)  when the superposition state is measured.   We shall call them \sphinxstyleemphasis{computational basis}. However,  the state of the qubit is neither \(\lvert 0 \rangle\) nor \(\lvert 1 \rangle\)  but  \(\lvert 0 \rangle\) AND \(\lvert 1 \rangle\) simultaneously. Hence, a qubit can compute two different cases at once (if a programmer is smart enough). Quantum computers exploit this superposition state.  Unlike the classical bit which has only two possible states, a qubit can take infinitely many different states since \(c_0\) and \(c_1\) can be any complex numbers satisfying the normalization condition.

\sphinxAtStartPar
Obviously, quantum computers are made of many qubits as a composite system. Let us consider two qubits, \(q_0\) and \(q_1\).  A composite system of two classical bits can have four different states, ‘00’, ‘01’, 10’, and ‘11’.  Similarly  the pair of qubits are spanned by four basis vectors \(\lvert 00 \rangle\), \(\lvert 01 \rangle\), \(\lvert 10 \rangle\), and \(\lvert 11 \rangle\).  Unlike the classical bits, the qubits can be in a superposition state
\begin{equation*}
\begin{split}
\lvert \psi \rangle = c_{00} \lvert 00 \rangle + c_{01} \lvert 01 \rangle + c_{10} \lvert 10 \rangle + c_{00} \lvert 11 \rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
The four different possibilities are simultaneously considered in the superposition state. The complexity of the superposition state grows very rapidly as the number of qubits increases.  If there are \(n\) qubits, the number of terms in the superposition state can be as many as \(2^n\).   Then, \(2^n\) different cases are simultaneously computed. We will take the advantage in various applications.

\sphinxAtStartPar
In classical computers,  a bit string \(b_{n-1}\, b_{n-2}\,\cdots\, b_1\, b_0\) expresses the state of the system.  In quantum computer, a tensor product \(\lvert q_{n-1} \rangle \otimes \lvert q_{n-2}\rangle \otimes \cdots \otimes \lvert q_1 \rangle \otimes \lvert q_0 \rangle\) represents the state of \(n\) qubits.  For two qubits, \(\lvert 01 \rangle = \lvert 0 \rangle \otimes \lvert 1 \rangle\).


\subsection{Restriction on quantum information processes}
\label{\detokenize{computation/qcomp:restriction-on-quantum-information-processes}}
\sphinxAtStartPar
Qubits have many advantages over classical bits, which is the main topics of this book.  However, they have also many disadvantages.  Here are some restrictions imposed on the quantum information.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/No-cloning\_theorem}{\sphinxstylestrong{No\sphinxhyphen{}cloning theorem}}The theorem states that it is not possible to duplicate an arbitrary qubit.   During quantum computation we cannot make a copy of a qubit in an unknown state.  Recall that classical bit can be cloned.

\item {}
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/No-teleportation\_theorem}{\sphinxstylestrong{No\sphinxhyphen{}teleportation theorem}}If the information stored in a qubit can be converted to a classical bit string and vice versa, we can \sphinxstyleemphasis{teleport} the quantum information to a distant place via a classical bit string. Such teleportation is not possible.  This theorem imposes more important restriction.  We cannot read out the full information in an arbitrary qubit since the outcome of the measurement is classical.

\item {}
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/No-deleting\_theorem}{\sphinxstylestrong{No\sphinxhyphen{}deleting theorem}}If two qubits happened to be in the same but arbitrary state, it is not possible to delete the information in one of the qubits.  This is a no\sphinxhyphen{}go theorem and time\sphinxhyphen{}reversal of no cloning theorem.

\item {}
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/No-broadcasting\_theorem}{\sphinxstylestrong{No\sphinxhyphen{}broadcasting theorem}}It is possible to transfer the full information in an arbitrary qubit to another qubit but the information in the original qubit must be destroyed.  This is known as \sphinxstyleemphasis{quantum teleportation}.  However, broadcasting the full information in an arbitrary qubit to multiple qubits is not possible. This is a corollary of no cloning theorem.

\item {}
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/No-hiding\_theorem}{\sphinxstylestrong{No\sphinxhyphen{}hiding theorem}}Briefly stating, the information stored in quantum system must be conserved. It is not possible to create or destroy quantum information.  In contrast, classical information can be created or destroyed.

\end{enumerate}


\subsection{Quantum Information}
\label{\detokenize{computation/qcomp:quantum-information}}
\sphinxAtStartPar
Recall that information is about uncertainty or probability.  a classical bit is dichotomous and there is only one uncertainty, 0 or 1.  In contrast, the state of a qubit is continuous and there are infinitely many different states.  The no\sphinxhyphen{}teleportation theorem tells us that even infinitely many classical bits cannot describe the state of a qubit.  Does this mean a qubit contains infinite amount of information? It turns out that we can ask only a dichotomous question.

\sphinxAtStartPar
Consider a qubit in a superposition state
\begin{equation*}
\begin{split}
\lvert \psi \rangle = \frac{1}{\sqrt{2}} \lvert 0 \rangle +  \frac{1}{\sqrt{2}} \lvert 1 \rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
If we ask if the qubit is in \(\lvert 0 \rangle\), the answer is either “yes” or “no” but there is no definite answer.  There is 50\% chance to get “yes” and 50\% chance to get “no”.  The situation is quite similar to the coin tossing.
However, there are differences. Even when we know precisely that the qubit is in the state \(\lvert \psi \rangle\), there is still the uncertainty, hence it is no due to our ignorance.  The uncertainty is not due to future event since \(\lvert \psi \rangle\) already exists.  Nevertheless, the amount of information seems \(\log 2\).

\sphinxAtStartPar
You can ask a different question.  Is the state \(\lvert + \rangle =  \frac{1}{\sqrt{2}} \lvert 0 \rangle +  \frac{1}{\sqrt{2}} \lvert 1 \rangle\) or \(\lvert - \rangle =  \frac{1}{\sqrt{2}} \lvert 0 \rangle -  \frac{1}{\sqrt{2}} \lvert 1 \rangle\)?  \(\lvert \pm \rangle\) forms an orthonormal basis, this question makes a sense.  Now, the answer is “yes” without ambiguity.  For this question,  \(\lvert \psi \rangle\) contains no information!   Although the question we can ask is always dichotomous, we can ask infinitely many different questions.  This is the main difference between qubit and classical bit.

\sphinxAtStartPar
We define quantum information entropy using density operator \(\rho = \lvert \psi \rangle \langle \psi \rvert\) as
\begin{equation*}
\begin{split}
S = - \text{Tr} \left(\rho \log \rho\right)
\end{split}
\end{equation*}
\sphinxAtStartPar
which is known as von\sphinxhyphen{}Neumann entropy. Plugin \(\rho = \lvert \psi \rangle \langle \psi \rvert\) , we find \(S=0\).  Hence, the state has no information (uncertainty).  When quantum measurement is done, the state collapses to a different state, which can have a non\sphinxhyphen{}vanishing information entropy.  In this sense, information is created, when measurement is done.  For the current example, the state after measurement of \(\lvert 0 \rangle\) and \(\lvert 1 \rangle\), the state after the measurement is
\begin{equation*}
\begin{split}
\rho = \frac{1}{2}  \lvert 0 \rangle \langle 0 \rvert + \frac{1}{2}  \lvert 1 \rangle \langle 1 \rvert
\end{split}
\end{equation*}
\sphinxAtStartPar
and its von Neumann entropy is \(S = \log 2\) as expected.


\subsection{Gates}
\label{\detokenize{computation/qcomp:gates}}
\sphinxAtStartPar
As a general purpose computer, a quantum computer must be able to change the state of qubits based on given instructions. Recall that a classical bit can only be flipped.  In contrast, quantum computers can change the state of a qubit in infinitely many different ways.  Here we use also the concept of gates.  A qubit enters a gate and comes out in a different state.  In other words, a state vector of the qubit is transformed to another state vector by the gate.  In quantum mechanics, that is achieved by a unitary transformation \(U\).   The transformation \(\ket{\psi'}=U \ket{\psi}\) in quantum mechanics is equivalent to applying a 1\sphinxhyphen{}qubit gate \(U\) to a qubit and expressed as

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{u1-gate}.png}
\caption{Action of one\sphinxhyphen{}qubit gate.}\label{\detokenize{computation/qcomp:u1-gate}}\end{figure}

\sphinxAtStartPar
As an example, consider a Pauli operator \(X \equiv \sigma_x\).  When it acts on the computational basis, \(X \lvert 0 \rangle = \lvert 1 \rangle\) and \(X \lvert 1 \rangle=\lvert 0 \rangle\).  Hence, it acts like \(\texttt{NOT}\) in the classical computation. See the \hyperref[\detokenize{computation/qcomp:quantum-gate-x}]{Table \ref{\detokenize{computation/qcomp:quantum-gate-x}}}. The qubit can be in a superposition state.  The  classical truth table is not enough. When it acts on a general state, we get
\begin{equation}\label{equation:computation/qcomp:Xgate}
\begin{split}
X \lvert \psi \rangle = c_0 X \lvert 0 \rangle + c_1 X \lvert 1 \rangle = c_0 \lvert 1 \rangle + c_1 \lvert 0 \rangle = c_1 \lvert 0 \rangle + c_0 \lvert 1 \rangle
\end{split}
\end{equation}
\sphinxAtStartPar
which actually swaps the coefficients.  The first two rows in  \hyperref[\detokenize{computation/qcomp:quantum-gate-x}]{Table \ref{\detokenize{computation/qcomp:quantum-gate-x}}} is much like the classical truth \hyperref[\detokenize{computation/ccomp:classical-not}]{table \ref{\detokenize{computation/ccomp:classical-not}}}.  The third row makes quantum computers more powerful than the classical computers.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{X Gate}\label{\detokenize{computation/qcomp:quantum-gate-x}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar

&\sphinxstyletheadfamily
\sphinxAtStartPar
\(i\)
&\sphinxstyletheadfamily
\sphinxAtStartPar
\(o\)
\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
\(\lvert 0 \rangle\)
&
\sphinxAtStartPar
\(\lvert 1 \rangle\)
\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
\(\lvert 1 \rangle\)
&
\sphinxAtStartPar
\(\lvert 0 \rangle\)
\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
\(c_0 \lvert 0 \rangle + c_1 \lvert 1 \rangle\)
&
\sphinxAtStartPar
\(c_1 \lvert 0 \rangle + c_0 \lvert 1 \rangle\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Like classical computers, quantum computers use gates that take two qubits as input.   Two\sphinxhyphen{}qubit gates are also a unitary operator and express as

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{u2-gate}.png}
\caption{Action of two\sphinxhyphen{}qubit gate.}\label{\detokenize{computation/qcomp:u2-gate}}\end{figure}

\sphinxAtStartPar
Logically, infinitely many 1\sphinxhyphen{}qubit and 2\sphinxhyphen{}qubits gates are possible but actual devices can understand only some of them. Depending on the underlying quantum systems, the available gates are different.  However, almost any gate can be expressed equivalently with a set of other gates in principle (gate \sphinxstyleemphasis{decomposition}).  So, if a desired gate is not available on the device you are using, you  must find a decomposition of the gate.  For IBM devices, \(\texttt{Qiskit}\) finds a decomposition suitable for them.


\subsection{Encoding}
\label{\detokenize{computation/qcomp:encoding}}
\sphinxAtStartPar
Encoding the information of the problem to be solved to qubits in a quantum computer is not a trivial task.  Let us try to use the same encoding scheme as the above classical case:
\begin{equation*}
\begin{split}
\texttt{False} \Rightarrow \lvert 0 \rangle, \quad \texttt{True} \Rightarrow \lvert 1 \rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
This works fine.  However, there are many other encoding schemes since a qubit can take a superposition state.  For example,
\begin{equation*}
\begin{split}
\texttt{False} \Rightarrow \lvert + \rangle \equiv \frac{1}{\sqrt{2}}\left(\lvert 0 \rangle+\lvert 1 \rangle\right), \quad
\texttt{True}  \Rightarrow \lvert - \rangle \equiv \frac{1}{\sqrt{2}}\left(\lvert 0 \rangle-\lvert 1 \rangle\right)
\end{split}
\end{equation*}
\sphinxAtStartPar
is another choice.

\sphinxAtStartPar
To make a good use of quantum computer, finding a good encoding scheme is crucial.


\subsection{Instructions}
\label{\detokenize{computation/qcomp:instructions}}
\sphinxAtStartPar
Once an encoding scheme is chosen, we need to give a set of instructions to a quantum computer.  That is we find a set of unitary operators that are applied on qubits one after the other. Unlike classical computation, no advanced programming language is available for quantum computing.  Therefore, programmers must right  instructions the device can understand directly (similar to coding with machine or assembly language for classical computers.)  A code for quantum computation looks like

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{qc}.png}
\caption{An example of quantum circuit.}\label{\detokenize{computation/qcomp:qc-example}}\end{figure}

\sphinxAtStartPar
which is known as quantum circuit.  Each object in the circuit is a unitary gate.

\sphinxAtStartPar
The following circuit computes \(x \oplus y\) using a quantum computer.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{quantum_x+y}.png}
\caption{Quantum computation of \(x \oplus y\).}\label{\detokenize{computation/qcomp:quantum-x-y}}\end{figure}

\sphinxAtStartPar
The gate in the circuit is known as \sphinxstyleemphasis{controlled X} or \sphinxstyleemphasis{controlled NOT}.  It applies \(X\) on \(q_0\) only when \(q_1 = \lvert 1 \rangle\). This is equivalent to the classical computation with \(\texttt{XOR}\) gate if input qubits are either \(\lvert 0 \rangle\) or \(\lvert 1 \rangle\).   We can see the difference between classical and quantum computation  when a superposition state is used as input. Consider a case where \(q_0=\lvert 0 \rangle\) and \(q_1=c_0 \ket{0} + c_1 \lvert 1 \rangle\).  The state of the two qubits is
\begin{equation*}
\begin{split}
\lvert \Psi_\text{in} \rangle = \lvert 0 \rangle \otimes (c_0 \lvert 0 \rangle + c_1 \lvert 1 \rangle) = c_0 \lvert 0 \rangle\otimes \lvert 0 \rangle + c_1 \lvert 0 \rangle \otimes \lvert 1 \rangle.
\end{split}
\end{equation*}
\sphinxAtStartPar
The output is
\begin{equation*}
\begin{split}
\lvert \Psi_\text{out} \rangle =  c_0 \lvert 0 \rangle \otimes \lvert 0 \rangle + c_1 \lvert 1 \rangle \otimes \lvert 1 \rangle,
\end{split}
\end{equation*}
\sphinxAtStartPar
which is known as  \sphinxstyleemphasis{entangled} state.   There is no way to express this state in a classical computer.  Quantum computation utilizes entangled states.


\subsection{Readouts}
\label{\detokenize{computation/qcomp:readouts}}
\sphinxAtStartPar
When a qubit is in \(\lvert 0 \rangle\) or \(\lvert 1 \rangle\), readout is in principle accurate (not on current NISQ computers due to device errors). However, the outcome is completely uncertain if the qubit is in a superposition state \eqref{equation:computation/qcomp:eqn:superposition}. We will obtain \(\texttt{0}\) or \(\texttt{1}\) at random.  If we prepare many qubits in the same superposition state, we obtain \(\texttt{0}\) from some and \(\texttt{1}\) from others. Hence, the readout of qubits is stochastic, from which we know that the qubits are in a superposition state but which one?  The principle of quantum mechanics tells us that the probability of getting \(\texttt{0}\) is given by \(|c_0|^2\) and \(\texttt{1}\) by \(|c_1|^2\).  By measuring many qubits in the same state, we can calculate the probabilities from which \(|c_0|^2\) and \(|c_1|^2\) can be determined.  The phase of \(c_0\) and \(c_1\) are still missing.  There is a complicate procedure, known as \sphinxstyleemphasis{quantum tomography}, which can determine the superposition state if and only if sufficiently large number of the same superposition states are measured.  Therefore, it is necessary to repeat the same quantum computation many times if the final result is a superposition state.  Even when the result of the computation is designed to be \(\lvert 0 \rangle\) or \(\lvert 1 \rangle\) by the algorithm, the outcome can be a superposition state due to device errors.  Even worse, the final state can be so\sphinxhyphen{}called \sphinxstyleemphasis{mixed state}, which contains a mixture of classical and quantum uncertainties simultaneously.  A good quantum circuit avoids both classical and quantum uncertainties as much as possible.

\sphinxstepscope


\part{Single qubit}

\sphinxstepscope


\chapter{Single qubit}
\label{\detokenize{qubit/intro:single-qubit}}\label{\detokenize{qubit/intro:chap-qubit1}}\label{\detokenize{qubit/intro::doc}}
\sphinxAtStartPar
In quantum computer, information is processed in a set of qubits.  Correlation among the qubits distinguishes the quantum computation from the classical computation.  However, understanding the properties of a single qubit is the first step toward the quantum computation.

\sphinxAtStartPar
Mathematically, a qubit lives in the smallest Hilbert space, that is a two\sphinxhyphen{}dimensional Hilbert space. Physically, a qubit is realized in many different form.  Any quantum system that has only two states or two states well separated from other states is a good candidate of a qubit.    For example, a photon  has two directions of linear polarization,  the horizontal and vertical polarization.  Hence, a single photon can be used as a qubit.  Various different types of qubits are developed, including \sphinxhref{https://en.wikipedia.org/wiki/Superconducting\_quantum\_computing}{Superconducting quantum computing} and \sphinxhref{https://en.wikipedia.org/wiki/Trapped\_ion\_quantum\_computer}{Trapped ion quantum computer}.  Regardless its physical implementation, the same mathematical theory can be used for any type of a qubit.

\sphinxAtStartPar
In this chapter, first mathematical expressions and properties of a single qubit are explained. It is very important for you to familiarize yourself with the notations and the rules of calculation since they are used through the book.  Secondly, the concept of quantum measurement is introduced.  As we discussed in the previous chapter, the quantum measurement is quite different from the classical measurement.  You must get rid of the classical intuition and believe in the principles of quantum mechanics.

\sphinxAtStartPar
After the theory of a qubit, I explain how to create a qubit in Qiskit and how to visualize the state of the qubit.  At the end, we simulate quantum coin tossing and quantum state tomography using a quantum computer.

\sphinxstepscope


\section{Pure states}
\label{\detokenize{qubit/purestates:pure-states}}\label{\detokenize{qubit/purestates:sec-purestates}}\label{\detokenize{qubit/purestates::doc}}
\sphinxAtStartPar
Quantum computers store information in a two\sphinxhyphen{}dimensional Hilbert space called a qubit.   In this section, I will introduce mathematical description of a single qubit.


\subsection{Pure states}
\label{\detokenize{qubit/purestates:id1}}
\sphinxAtStartPar
In ideal situations, the state of a qubit is specified by a single ket vector in a two\sphinxhyphen{}dimensional Hilbert space.  We call the ket \sphinxstyleemphasis{state vector} and the ideal state \sphinxstyleemphasis{pure state}.  Unless otherwise is specified, the state vectors are assumed to be normalized. That is \(\langle \psi | \psi \rangle = 1\) (See \hyperref[\detokenize{qmsummary/vectors:sec-statevectors}]{Section \ref{\detokenize{qmsummary/vectors:sec-statevectors}}}).
In less ideal situations, a qubit is in a \sphinxstyleemphasis{mix state} involving multiple pure states, which will be discussed in a later chapter.  In this chapter, we focus on pure states.

\sphinxAtStartPar
Any qubit state can be written as
\begin{equation}\label{equation:qubit/purestates:qubit-purestate}
\begin{split}
| \psi \rangle = c_0 | 0 \rangle + c_1 | 1 \rangle
\end{split}
\end{equation}
\sphinxAtStartPar
where \(| 0 \rangle \) and \(| 1 \rangle\) are orthonormal basis vectors satisfying \(\langle 0 | 0 \rangle = \langle 1 | 1 \rangle = 1\) and \(\langle 0 | 1 \rangle = \langle 1 | 0 \rangle = 0\).  The coefficients \(c_0\) and \(c_1\) are complex numbers. The normalization requirement is satisfied if \(|c_0|^2 + |c_1|^2 = 1\).

\sphinxAtStartPar
This orthonormal complete basis set \(\{|0\rangle, |1\rangle\}\) is known as \sphinxstyleemphasis{computational basis} which is the default basis in quantum computing.  However, this basis set do not represent any particular physical basis set.  In real quantum computers,  a qubit can be realized, for example, by an electron spin, \(|0\rangle \equiv | \uparrow \rangle\) and \(|1\rangle \equiv |\downarrow \rangle\) or the polarization of a photon, \(|0\rangle \equiv | H \rangle\) (horizontal polarization) and \(|1\rangle \equiv | V \rangle\) (vertical polarization).  By using the computational basis set, we don’t have to worry about what type of hardware is used.  The mathematical expression based on the computational basis can be applied to all of qubit\sphinxhyphen{}based quantum computers.


\subsection{Standard Basis sets}
\label{\detokenize{qubit/purestates:standard-basis-sets}}
\sphinxAtStartPar
In addition to the computational basis (also known as \sphinxstyleemphasis{z\sphinxhyphen{}basis}) \(\{|0\rangle,|1\rangle\}\), we often use other orthonormal basis set, namely \sphinxstyleemphasis{x\sphinxhyphen{}basis} \(\{|+\rangle, |-\rangle\}\) and \sphinxstyleemphasis{y\sphinxhyphen{}basis} \(\{|L\rangle,|R\rangle\}\).
They are related to the computational basis as follows:
\begin{equation}\label{equation:qubit/purestates:XBasis}
\begin{split}
|+\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle + |1\rangle\right), \quad
|-\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle - |1\rangle\right)
\end{split}
\end{equation}\begin{equation}\label{equation:qubit/purestates:YBasis}
\begin{split}
|L\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle + i |1\rangle\right), \quad
|R\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle - i |1\rangle\right)
\end{split}
\end{equation}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qubit/purestates:sec-purestates}]{\ref{\detokenize{qubit/purestates:sec-purestates}}}.1    Assuming that the computational basis is orthonormal, show that the x\sphinxhyphen{}basis and the y\sphinxhyphen{}basis are orthonormal.


\bigskip\hrule\bigskip



\subsection{The basis sets in Qiskit}
\label{\detokenize{qubit/purestates:the-basis-sets-in-qiskit}}
\sphinxAtStartPar
In Qiskit, the computatioal basis kets \(\{|0\rangle, |1\rangle\}\) and x\sphinxhyphen{}basis kets \(\{|+\rangle, |-\rangle\}\) are predefined.  See the following Qiskit note.

\begin{sphinxadmonition}{note}{Qiskit note: Computational Basis}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{qiskit.opflow}} library provides us with basic tools to describe quantum mechanics using expressions very similar to the original methematical expressions.  Here are the correspondence between mathematical expressions and \sphinxcode{\sphinxupquote{opflow}} expressions.
\begin{quote}

\sphinxAtStartPar
\(\ket{0} \quad \Rightarrow \quad\) \sphinxcode{\sphinxupquote{Zero}}\(\ket{1} \quad \Rightarrow \quad\) \sphinxcode{\sphinxupquote{One}}\(\ket{+} \quad \Rightarrow \quad\) \sphinxcode{\sphinxupquote{Plus}}\(\ket{-} \quad \Rightarrow \quad\) \sphinxcode{\sphinxupquote{Minus}}
\end{quote}

\sphinxAtStartPar
The vector with “\textasciitilde{}” indicates bra.  For example,
\begin{quote}

\sphinxAtStartPar
\(\bra{0} \quad  \Rightarrow \quad\) \sphinxcode{\sphinxupquote{\textasciitilde{}One}}
\end{quote}

\sphinxAtStartPar
The regular addition works.
\begin{quote}

\sphinxAtStartPar
\(\ket{0} + \ket{1} \quad \Rightarrow \quad\)  \sphinxcode{\sphinxupquote{Zero + One}}
\end{quote}

\sphinxAtStartPar
The operator for inner product is “@”. You need to evalute it with \sphinxcode{\sphinxupquote{.eval()}}.
\begin{quote}

\sphinxAtStartPar
\(\langle 0 | + \rangle \quad \Rightarrow \quad\)  \sphinxcode{\sphinxupquote{(\textasciitilde{}Zero @ Plus).eval()}}
\end{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eval}} is a method associated with \sphinxcode{\sphinxupquote{OperatorBase}} class in \sphinxcode{\sphinxupquote{qiskit.opflow}}.

\sphinxAtStartPar
For more detail, see \sphinxhref{https://qiskit.org/documentation/apidoc/opflow.html}{Qiskit API Document: qiskit.opflow}
\end{sphinxadmonition}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{qubit/purestates:sec-purestates}]{\ref{\detokenize{qubit/purestates:sec-purestates}}}.1   Let us check the orthonormality of the computational basis set in Qiskit.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import numpy (for sqrt)}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} Import the base vectors from qiskit.opflow library}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{opflow} \PYG{k+kn}{import} \PYG{n}{Zero}\PYG{p}{,} \PYG{n}{One}\PYG{p}{,} \PYG{n}{Plus}\PYG{p}{,} \PYG{n}{Minus}

\PYG{c+c1}{\PYGZsh{} Example of inner product calculation with qiskit}

\PYG{c+c1}{\PYGZsh{} First example calculate the norm of |0\PYGZgt{} and |1\PYGZgt{}}
\PYG{c+c1}{\PYGZsh{} Zero and One are ket}
\PYG{c+c1}{\PYGZsh{} \PYGZti{}Zero and \PYGZti{}One are corresponding bra}
\PYG{c+c1}{\PYGZsh{} @ product between bra and ket, that is inner product}
\PYG{c+c1}{\PYGZsh{} To complete the operation @, we must evaluate it by .eval()}

\PYG{n}{Norm\PYGZus{}of\PYGZus{}Zero} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{Zero} \PYG{o}{@} \PYG{n}{Zero}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Norm\PYGZus{}of\PYGZus{}One}  \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{One} \PYG{o}{@} \PYG{n}{One}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show the reults}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Norm of |0\PYGZgt{} =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Norm\PYGZus{}of\PYGZus{}Zero}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Norm of |1\PYGZgt{} =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Norm\PYGZus{}of\PYGZus{}One}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Next we check the orthogonality between |0\PYGZgt{} and |1\PYGZgt{}}
\PYG{n}{Inner\PYGZus{}Product} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{Zero} \PYG{o}{@} \PYG{n}{One}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show the result.}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}0|1\PYGZgt{} =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Inner\PYGZus{}Product}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{qubit/purestates:sec-purestates}]{\ref{\detokenize{qubit/purestates:sec-purestates}}}.2    Let us construct another orthonormal basis set \(|L\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle + i |1\rangle\right)\) and \(|R\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle - i |1\rangle\right)\).  Notice the complex unit \(i\) on \(|1\rangle\).

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Let us try more complicated case.}
\PYG{c+c1}{\PYGZsh{} we will solve the above exercise problem using Qiskit}

\PYG{c+c1}{\PYGZsh{} import numpy }
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} imaginary unit \PYGZdq{}i\PYGZdq{} is \PYGZdq{}1j\PYGZdq{} in python.}
\PYG{n}{L} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Zero} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*} \PYG{n}{One}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{R} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Zero} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*} \PYG{n}{One}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}L|L\PYGZgt{} =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{L}\PYG{n+nd}{@L}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}R|R\PYGZgt{} =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{R}\PYG{n+nd}{@R}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}L|R\PYGZgt{} =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{L} \PYG{o}{@} \PYG{n}{R}\PYG{p}{)}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Anser should be 0 since they are orthogonal.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Python note: Complex numbers}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{python}}, a complex number is expressed as \(2 + 3j\).  Note that symbol \(j\) is used instead of \(i\).  The imaginary unit \(i\) is \(1j\).  Notice \(1\) in from of \(j\).  \(j\) must be used with a regular number.  \(j\) alone causes an error.
\end{sphinxadmonition}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qubit/purestates:sec-purestates}]{\ref{\detokenize{qubit/purestates:sec-purestates}}}.2
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Confirm that base vectors \sphinxcode{\sphinxupquote{Plus}} and \sphinxcode{\sphinxupquote{Minus}} are orthonormal using Qiskit.

\item {}
\sphinxAtStartPar
Calculate the inner product between \sphinxcode{\sphinxupquote{One}} and \sphinxcode{\sphinxupquote{Minus}} by hand and confirm your answer using Qiskit.

\end{enumerate}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{qubit/purestates:sec-purestates}]{\ref{\detokenize{qubit/purestates:sec-purestates}}}.2    In the previous example, change the order of rotations to \sphinxcode{\sphinxupquote{rx}}, \sphinxcode{\sphinxupquote{rz}}, \sphinxcode{\sphinxupquote{ry}}.  Does it come back to the initial state?


\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified: 07/09/2022

\sphinxstepscope


\section{Bloch sphere}
\label{\detokenize{qubit/bloch:bloch-sphere}}\label{\detokenize{qubit/bloch:sec-bloch}}\label{\detokenize{qubit/bloch::doc}}
\sphinxAtStartPar
While Eq. \eqref{equation:qubit/purestates:qubit-purestate} can describe any qubit state, there is a better expression suitable for visualizing the qubit state.
Writing the complex coefficient in the polar expression,
\(c_0 = r_0 e^{i \phi_0}\) and \(c_1 = r_1 e^{i \phi_1}\) where \(r_i\) and \(\phi_i\) are modulus and argument. Then, we remove a global phase as
\begin{equation*}
\begin{split}
\ket{\psi} = r_0 e^{i \phi_0} \ket{0} + r_1 e^{i \phi_1} \ket{1} = e^{i \phi_0} \left( r_0  \ket{0} + r_1 e^{i (\phi_1-\phi_0)} \ket{1} \right) \simeq r_0  \ket{0} + r_1 e^{i \theta} \ket{1}
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\phi=\phi_1-\phi_0,\ \phi \in [0, 2\pi)\) and “\(\simeq\)” means “equivalent up to global phase”.  Now, the normalization condition becomes \(r_0^2 + r_1^2 = 1\).  Since \(r_0\) and \(r_1\) are positive, we can write them as \(r_0 = \cos\left(\frac{\theta}{2}\right)\) and \(r_1 = \sin\left(\frac{\theta}{2}\right)\) with \(0 < \theta < \pi\).  Now the general qubit state is written as
\begin{equation}\label{equation:qubit/bloch:bloch-vector}
\begin{split}
\ket{\psi} = \cos\left(\frac{\theta}{2}\right) \ket{0} + \sin\left(\frac{\theta}{2}\right) e^{i \phi} \ket{1},\quad 0 \le \theta \le \pi, \, 0 \le \phi < 2 \pi .
\end{split}
\end{equation}
\sphinxAtStartPar
This expression suggests that any pure state can be map to a point on the surface of a unit sphere using spherical coordinates \(\theta\) and \(\phi\).   The north pole of the sphere (\(\theta=0\)) corresponds to \(\ket{0}\) and the south pole (\(\theta=\pi\)) to \(\ket{1}\) (recall that the global phase \(e^{i \phi}\) can be omitted.  When \(\theta = \frac{\pi}{2}\) and \(\phi=0\), we obtain \(|+\rangle\) and when \(\theta = \frac{\pi}{2}\) and \(\phi=\pi\), we have \(|-\rangle\).

\sphinxAtStartPar
The sphere is known as \sphinxstyleemphasis{Bloch sphere} and the arrow from the center of the sphere to the point on the surface is called \sphinxstyleemphasis{Bloch vector}. Each Bloch vector corresponds to a qubit state.

\begin{sphinxadmonition}{note}{Qiskit note: Bloch sphere}

\sphinxAtStartPar
Qiskit provides four tools to visualize the Bloch sphere and vector.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{plot\_bloch\_vector}} in \sphinxcode{\sphinxupquote{qiskit.visuakization}} if \(\theta\) and \(\phi\) are known.

\end{enumerate}
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot\_bloch\_vector({[}r,theta,phi{]}, coord\_type='spherical', figsize=(w,h) )}}\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.visualization.plot\_bloch\_vector.html}{API reference:plot\_bloch\_vector}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{plot\_bloch\_multivector}} if a state vector is known.

\end{enumerate}
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{plot\_bloch\_multivector(state)}}\sphinxcode{\sphinxupquote{state}} is a quantum state. Various format is allowed, including Statevector class objects.
For other optional arguments.\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.visualization.plot\_bloch\_multivector.html}{API reference:plot\_bloch\_multivector}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{draw}} method associated with \sphinxcode{\sphinxupquote{statevector}} class

\end{enumerate}
\begin{quote}

\sphinxAtStartPar
psi\sphinxcode{\sphinxupquote{.draw('mpl')}}where psi is a \sphinxcode{\sphinxupquote{staetvector}} class object.  \sphinxcode{\sphinxupquote{mpl}} specifies the use of \sphinxcode{\sphinxupquote{matplotlib}} module.  This method is just a front end to plot\sphinxhyphen{}bloch\sphinxhyphen{}multivector.\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.quantum\_info.Statevector.draw.html\#qiskit.quantum\_info.Statevector.draw}{API reference:Statevector.draw}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
We can even draw evolution of the Bloch vector as a movie using \sphinxcode{\sphinxupquote{visualize\_transition}}.

\end{enumerate}
\begin{quote}

\sphinxAtStartPar
visualize\_transition(qc,fpg=50, spg=1)
where \sphinxcode{\sphinxupquote{qc}} is a quantum circuit (I will explain it later.)   See the following documentation for other parameters.\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.visualization.visualize\_transition.html}{API reference:visualize\_transition}
\end{quote}
\end{sphinxadmonition}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{qubit/bloch:sec-bloch}]{\ref{\detokenize{qubit/bloch:sec-bloch}}}.1   The following example plots the Bloch vectors of \(|0\rangle\), \(|1\rangle\), and \(|\pm\rangle\).  To plot all of them at once, we use a tensor product of all vectors.  In Qiskit, tensor product is done by “\textasciicircum{}”.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} import }
\PYG{c+c1}{\PYGZsh{} importhe visualization tool}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}

\PYG{c+c1}{\PYGZsh{} impor}
\PYG{c+c1}{\PYGZsh{} import basis vectors}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{opflow} \PYG{k+kn}{import} \PYG{n}{Zero}\PYG{p}{,} \PYG{n}{One}\PYG{p}{,} \PYG{n}{Plus}\PYG{p}{,} \PYG{n}{Minus}

\PYG{c+c1}{\PYGZsh{} show Bloch vector for |0\PYGZgt{}, |1\PYGZgt{}, |+\PYGZgt{}, and |\PYGZhy{}\PYGZgt{}}
\PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}\PYG{p}{(}\PYG{n}{Minus}\PYG{o}{\PYGZca{}}\PYG{n}{Plus}\PYG{o}{\PYGZca{}}\PYG{n}{One}\PYG{o}{\PYGZca{}}\PYG{n}{Zero}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{bloch_3_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{qubit/bloch:sec-bloch}]{\ref{\detokenize{qubit/bloch:sec-bloch}}}.4   Plot the Bloch vectors of the states \(|L\rangle\) and \(|R\rangle\) discuessed in \sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{qubit/purestates:sec-purestates}]{\ref{\detokenize{qubit/purestates:sec-purestates}}}.2.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{c+c1}{\PYGZsh{} generate basis |L\PYGZgt{} and |R\PYGZgt{}}
\PYG{n}{L} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Zero} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*} \PYG{n}{One}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{R} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Zero} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*} \PYG{n}{One}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} show their Bloch vectors}
\PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}\PYG{p}{(}\PYG{n}{R}\PYG{o}{\PYGZca{}}\PYG{n}{L}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{bloch_5_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{qubit/bloch:sec-bloch}]{\ref{\detokenize{qubit/bloch:sec-bloch}}}.3    A statevector is initially \(|0\rangle\).  It is rotated around \(y\), \(z\), and \(x\) by angle \(\frac{\pi}{2}\) for each rotation. It is done by rotation gates \sphinxcode{\sphinxupquote{ry}}, \sphinxcode{\sphinxupquote{rz}}, and \sphinxcode{\sphinxupquote{rx}}. (They are introduced in next chapter.) Construction of quantum circuits will be discussed later in great detail.   The Bloch vector should come back to the starting point. See the animation.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}capture}
\PYG{c+c1}{\PYGZsh{} The output block is disabled.}

\PYG{c+c1}{\PYGZsh{} load numpy and qiskit}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c+c1}{\PYGZsh{} create an empty quantum circuit}
\PYG{n}{qr} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} add rotation gates to the circuit}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{ry}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{rz}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{rx}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} load the visdualization tool}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{visualize\PYGZus{}transition}

\PYG{c+c1}{\PYGZsh{} generate a movie (it will be shown in next cell,}
\PYG{n}{movie}\PYG{o}{=}\PYG{n}{visualize\PYGZus{}transition}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{fpg}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{spg}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Show the movie}
\PYG{n}{movie}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Qubit Measurement}
\label{\detokenize{qubit/measurement:qubit-measurement}}\label{\detokenize{qubit/measurement:sec-qubit-measurement}}\label{\detokenize{qubit/measurement::doc}}
\sphinxAtStartPar
Measuring a physical quantity in quantum mechanics is a bit weird.  I am not going to present a full theory of measurement. If you are interested in it, read Ref. {[}\hyperlink{cite.references:id4}{1}{]}. See also \sphinxhref{https://en.wikipedia.org/wiki/Measurement\_in\_quantum\_mechanics}{wikipedia}.


\subsection{Projective measurement}
\label{\detokenize{qubit/measurement:projective-measurement}}
\sphinxAtStartPar
In classical computer, readout processes determine the outcome of computation stored in each bit.  That is to determine if the state of each bit is \(0\) or \(1\). The readout can be done at any time without disturbing the state of the bit.  If you repeat the same measurement, the same outcome is obtained.

\sphinxAtStartPar
Similarly, we want to know whether each qubit is in \(|0\rangle\) or \(|1\rangle\). However, if a qubit is in a superposition state, we have a big problem.  Equation \eqref{equation:qubit/purestates:qubit-purestate} indicates that the state of the qubit is neither \(|0\rangle\) nor \(|1\rangle\).  Despite of it, quantum mechanics allows us to ask if the qubit is in \(|0\rangle\) or \(|1\rangle\) and surprisingly the answer is one of \(|0\rangle\) and \(|1\rangle\) even it is in the superposition state. Suppose that the outcome of the measurement is \(|0\rangle\), it does not mean that the qubit was in \(|0\rangle\).  The measurement process has transformed \(|psi\rangle\) to \(|0\rangle\). This transition is referred as the \sphinxstyleemphasis{collapse of wavefunction}. Mathematically, we say that the state \(|\psi\rangle\) is projected to \(|0\rangle\) and thus it is called \sphinxstyleemphasis{projective measurement}. See Fig. \hyperref[\detokenize{qubit/measurement:measurement-purestate}]{Fig.\@ \ref{\detokenize{qubit/measurement:measurement-purestate}}}.   You may obtain \(|1\rangle\) from the same superposition state. Then, \(\psi\rangle\) is projected to \(|1\rangle\). The measurement of a single qubit seems suggesting that the outcome is not related to the state of the qubit. We never be able to determine the superposition from the outcome. Then, what is the purpose of the measurement?   Even worse, the measurement destroys the superposition state.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{measurement-purestate}.png}
\caption{Measurement of a superposition state.  Before measurement, every qubit in the ensemble is in the same superposition state \eqref{equation:qubit/purestates:qubit-purestate}.  It is known as a purestate ensemble  The measurement selects one of \(|0\rangle\) and \(|1\rangle\).  As the result, some qubits in the ensemble are in \(|0\rangle\) and others in \(\1\rangle\). After the measurement, we have a mixed state ensemble.}\label{\detokenize{qubit/measurement:measurement-purestate}}\end{figure}


\subsection{Born rule}
\label{\detokenize{qubit/measurement:born-rule}}
\sphinxAtStartPar
It seems that the outcome is picked at random. The theory of quantum mechanics is powerless if we measure a single qubit.  So, what is the physical meaning of the state vector \(|\psi\rangle\)?  A resolution was offered by Born. Consider an ensemble of qubits. All qubits in the ensemble are prepared exactly in the same state \(|\psi\rangle\) and exactly the same measurement process is applied to them. Some of them are transformed to \(|0\rangle\) and others to \(|1\rangle\).  It turns out that the probability to obtain \(0\rangle\) is \(|c_0|^2\) and that of \(|1\rangle\) is \(|c_1|^2\). This interpretation of the superposition state is known as \sphinxstyleemphasis{Born} rule.  Since we will obtain one of them from each measurement, \(|c_0|^2+|c_1|^2=1\), which is satisfied by the normalization condition.


\bigskip\hrule\bigskip



\subsection{Quantum coin flipping}
\label{\detokenize{qubit/measurement:quantum-coin-flipping}}
\sphinxAtStartPar
As an example of the Born rule, we simulate quantum coin flipping.

\sphinxAtStartPar
It is a common practice to pick one of two choices by tossing up a coin.  The classical motion of coin is chaotic and the probability to get head and tail is approximately equal. We can simulate the process on a classical computer using a random number generator.  Such simulation is known as Monte Carlo simulation after the name of the famous casino city.  One can simulate the same process on a quantum computer without random number generator by exploiting the stochastic nature of quantum measurement.  For comparison, both a classical and quantum simulation are presented below.


\subsubsection{Classical simulation}
\label{\detokenize{qubit/measurement:classical-simulation}}
\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{random.choice}} function in numpy, we generate random choice of 0=head and 1=tail.  Then, count the number of head and tail.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Classical Monte Carlo simulation of coin tossing}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} coin is tossed 10000 times for statistical analysis}
\PYG{n}{shots}\PYG{o}{=}\PYG{l+m+mi}{10000}

\PYG{c+c1}{\PYGZsh{} generate random choice 0 or 1}
\PYG{c+c1}{\PYGZsh{} head=0 and tail=1}
\PYG{n}{face} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{size}\PYG{o}{=}\PYG{n}{shots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count number of heads and tails}
\PYG{c+c1}{\PYGZsh{} if the random number is less than 0.5, it is head.}
\PYG{c+c1}{\PYGZsh{} otherwise, it is tail.}
\PYG{n}{head} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{face}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{tail} \PYG{o}{=} \PYG{n}{shots}\PYG{o}{\PYGZhy{}}\PYG{n}{head}

\PYG{c+c1}{\PYGZsh{} print out the probabilities}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{head=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{head}\PYG{o}{/}\PYG{n}{shots}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tail=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{tail}\PYG{o}{/}\PYG{n}{shots}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
head= 0.5004
tail= 0.4996
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Quantum simulation}
\label{\detokenize{qubit/measurement:quantum-simulation}}
\sphinxAtStartPar
To demonstrate the stochastic nature of quantum measurement, we consider a quantum coin.  The quantum coin has two states, head and tail. We assign the head to \(|0\rangle\) and the tail to \(|1\rangle\)  The superposition state \(|\psi\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle+|1\rangle\right)\) indicates that the state of the quantum coin is neither head nor tail.  Based on the Born rule, the chance to get head is 50\% and tail 50\%.  Since the outcome is completely random, measuring the state of the quantum coin is equivalent to tossing a classical coin.

\sphinxAtStartPar
In the following qiskit code, the superposition state using a Hadamard gate (we will discuss this in next chapter) and then the state of the qubit is measured.  The result is stored in a classical bit. The quantum computation is simulated with \sphinxcode{\sphinxupquote{qasm\_simulator}} on your computer instead of sending the code to a real quantum computer. (We will send this to real quantum computer in a later chapter.) We repeat the simulation 10000 times and find the probabilities to find head and tail. Since the number of samplings is finite, the result is not exactly 50\%\sphinxhyphen{}50\% but close to  it.

\sphinxAtStartPar
The quantum circuit shows two lines, one for quantum register and the other for classical register.  The classical register contains a bit.  Usually the outcome of measurement on a qubit is stored. The quantum register contains a qubit.  It is initially reset to \(|0\rangle\).  The diagram shows that a single\sphinxhyphen{}qubit gate \(H\) (Hadamard gate) is applied on the qubit.  The outcome is \(H |0\rangle = \frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle \right)\).  The next gate shows that the state of the qubit is measured and the result, either \(0\) or \(1\), is sent to the classical register.  In the current example, \(0\) or \(1\) is obtained with the equal probability. First, we construct a quantum circuit.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Tossing Up Quantum Coin}

\PYG{c+c1}{\PYGZsh{} import numpy}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} import entire qiskit}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c+c1}{\PYGZsh{} set classical register (bit)}
\PYG{n}{cr} \PYG{o}{=} \PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set quantum register (qubit)}
\PYG{n}{qr} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} reset the quantum circuit}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} construct quantum circuit}
\PYG{c+c1}{\PYGZsh{} step 1: create the superposition state with Hardamard gate}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} measurement on qubit }
\PYG{c+c1}{\PYGZsh{} output is stored in cllasical register}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} show the quantum circuit}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mpl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{measurement_10_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now we execute the circuit using a simulator of quantum computer.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}

\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Execute the quantum circuit 10000 times}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Count the outcome}
\PYG{c+c1}{\PYGZsh{} Numbers of |0\PYGZgt{} and |1\PYGZgt{}}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Visualize the outcome}
\PYG{c+c1}{\PYGZsh{} import histgram plotting function}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}histogram}
\PYG{n}{plot\PYGZus{}histogram}\PYG{p}{(}\PYG{n}{counts}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The result should be close to 0.5 for both |0\PYGZgt{} and |1\PYGZgt{}.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{measurement_12_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The outcome is not exactly 50\%\sphinxhyphen{}50\%.  This is because the simulation is executed with a finite shots and thus there is statistical error due to finite sampling.  Theoretically infinite sampling is required but practically it is not possible. However, this is not an issue of quantum computation.

\sphinxstepscope


\section{Mixed states}
\label{\detokenize{qubit/mixedstates:mixed-states}}\label{\detokenize{qubit/mixedstates:sec-mixedstates}}\label{\detokenize{qubit/mixedstates::doc}}
\sphinxAtStartPar
TBW

\sphinxstepscope


\chapter{One\sphinxhyphen{}qubit gates}
\label{\detokenize{q1gates/intro:one-qubit-gates}}\label{\detokenize{q1gates/intro:chap-one-qubit-gates}}\label{\detokenize{q1gates/intro::doc}}
\sphinxAtStartPar
In quantum computing, we manipulate the state of qubits by applying a series of gates on qubits. In this chapter, I introduce various one\sphinxhyphen{}qubit gates commonly used in quantum computing. When a one\sphinxhyphen{}qubit gate acts on a single qubit, the Bloch vector of the qubit rotates around a certain axis by a certain angle.  The most general rotation is \sphinxhref{https://en.wikipedia.org/wiki/Euler\_angles}{\sphinxstyleemphasis{Euler rotation}}, which is done by \(U\) gate.  In theory, we need only this gate. However, it is not convenient since we have to figure out three parameters (angles) for each operation.  Furthermore, in actual quantum computing devices, the general gate may not be available.   In practice, we use parameter\sphinxhyphen{}free gates with predefined rotation axes and angles, and a few others that require a single parameter.

\sphinxAtStartPar
Mathematically, the gates are unitary operators in \(\mathbb{C}^2\). Some are Hermitian and others are not.  \hyperref[\detokenize{q1gates/intro:tbl-q1gates}]{Table \ref{\detokenize{q1gates/intro:tbl-q1gates}}} lists commonly used single\sphinxhyphen{}qubit gates.  I explain some the most important ones in the following section.  See also Qiskit documentation:

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/apidoc/circuit\_library.html}{Qiskit Circuit Library}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Commonly used single\sphinxhyphen{}qubit gates}\label{\detokenize{q1gates/intro:tbl-q1gates}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar
Generaic Name
&\sphinxstyletheadfamily
\sphinxAtStartPar
Qiskit Ciruit Name
&\sphinxstyletheadfamily
\sphinxAtStartPar
\# of Parameters
&\sphinxstyletheadfamily
\sphinxAtStartPar
Symbols
\\
\hline
\sphinxAtStartPar
Unitary
&
\sphinxAtStartPar
u
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
\(U\)
\\
\hline
\sphinxAtStartPar
Rotation X
&
\sphinxAtStartPar
rx
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\(R_x\)
\\
\hline
\sphinxAtStartPar
Rotation Y
&
\sphinxAtStartPar
ry
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\(R_y\)
\\
\hline
\sphinxAtStartPar
Rotation Z
&
\sphinxAtStartPar
rz
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\(R_z\)
\\
\hline
\sphinxAtStartPar
Pauli X
&
\sphinxAtStartPar
x
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\(X\)
\\
\hline
\sphinxAtStartPar
Pauli Y
&
\sphinxAtStartPar
y
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\(Y\)
\\
\hline
\sphinxAtStartPar
Pauli Z
&
\sphinxAtStartPar
z
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\(Z\)
\\
\hline
\sphinxAtStartPar
Hadamard
&
\sphinxAtStartPar
h
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\(H\)
\\
\hline
\sphinxAtStartPar
Sqrt X
&
\sphinxAtStartPar
sx
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\(SX\)
\\
\hline
\sphinxAtStartPar
Inverse sqrt X
&
\sphinxAtStartPar
sxdg
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\(SX^\dagger\)
\\
\hline
\sphinxAtStartPar
Sqrt Z
&
\sphinxAtStartPar
s
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\(S\)
\\
\hline
\sphinxAtStartPar
Inverse sqrt Z
&
\sphinxAtStartPar
sdg
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\(S^\dagger\)
\\
\hline
\sphinxAtStartPar
4th root Z
&
\sphinxAtStartPar
t
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\(T\)
\\
\hline
\sphinxAtStartPar
Inverse 4th root Z
&
\sphinxAtStartPar
tdg
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
\(T^\dagger\)
\\
\hline
\sphinxAtStartPar
Phase
&
\sphinxAtStartPar
p
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\(P\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Their definition and typical usage of those gates are explained in the following sections.


\section{Mathematical expressions}
\label{\detokenize{q1gates/intro:mathematical-expressions}}
\sphinxAtStartPar
There are several ways to define the gates. In the following sections, the gates are defined in four different ways but they  are mathematically all equivalent.  In one definition, a gate is defined by how the computational basis kets are transformed by the gate.  This definition is practical.  For computational purpose, the matrix expression of the gate is more convenient.  The matrix expression assumes the computational basis. Since every gate is a special case of the general \(U\) gate, the gate can be expressed with \(U\), which is the third definition.


\section{Transformation of general superposition states}
\label{\detokenize{q1gates/intro:transformation-of-general-superposition-states}}
\sphinxAtStartPar
The definitions do not give you a clear idea on the operational functionality of a gate.  It is important to understand how a superposition state is transformed by the gate. Pay attention to how the coefficients are transformed.


\section{Combination of gates}
\label{\detokenize{q1gates/intro:combination-of-gates}}
\sphinxAtStartPar
When gate \(Y\) is applied after \(X\), we write it \(Y \cdot X\). We can think of a gate \((Y \cdot X)\)  acts on a state vector as
\begin{equation*}
\begin{split}
Y (X |\psi\rangle) = (Y \cdot X) |\psi\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
We put “\(\cdot\)” between the gates to avoid confusion.  For example \(SX\) is a single gate and \(S \cdot X\) is a product of \(S\) and \(X\).

\sphinxAtStartPar
The order is important.  \(Y \cdot X\) is not necessarily equal to \(X \cdot Y\).

\sphinxAtStartPar
In quantum circuit, the gates act from left to right.  For example,  \(Y\cdot X |0\rangle\) becomes

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   ┌───┐┌───┐
q: ┤ X ├┤ Y ├
   └───┘└───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified: 07/09/2022

\sphinxstepscope


\section{U Gate}
\label{\detokenize{q1gates/u:u-gate}}\label{\detokenize{q1gates/u:sec-ugate}}\label{\detokenize{q1gates/u::doc}}
\sphinxAtStartPar
When a gate acts on a qubit, it rotates the Bloch vector.  Any rotation can be specified with three angles, \(\theta\), \(\phi\), and \(\lambda\).  They are known as \sphinxhref{https://en.wikipedia.org/wiki/Euler\_angles}{\sphinxstyleemphasis{Euler angles}}. In standard quantum computation, a standard Euler rotation \(z-y-z\) is used.  That is rotating 1) around \(z\) axis by \(\lambda\), 2) around \(y\) axis by \(\theta\), and 3) around \(z\) axis by \(\phi\).  The rotations must be done in this order.  This gate transforms \(|0\rangle\) to a general qubit state.

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.UGate.html}{Qiskit API References: UGate}


\subsection{Definition}
\label{\detokenize{q1gates/u:definition}}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}
\begin{quote}
\begin{equation*}
\begin{split}
\begin{eqnarray}
U(\theta,\phi,\lambda) |0\rangle &=& \cos(\theta/2) |0\rangle + \sin(\theta/2) e^{i \phi} |1\rangle \\
U(\theta,\phi,\lambda) |1\rangle &=& - e^{i \phi} \left[\sin(\theta/2) |0\rangle  - \cos(\theta/2) e^{i \lambda}|1\rangle\right]
\end{eqnarray}
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
Notice that when it acts on \(|0\rangle\), we obtain a general state in the Bloch sphere expression  \eqref{equation:qubit/bloch:bloch-vector}  (no \(\lambda\) appears in it).

\sphinxAtStartPar
\sphinxstylestrong{Matrix expression}
\begin{quote}
\begin{equation*}
\begin{split}
U(\theta,\phi,\lambda) \doteq \begin{bmatrix} \cos(\theta/2) & - e^{i \phi} \sin(\theta/2) \\ e^{i \lambda} \sin(\theta/2) & e^{i (\lambda+\phi)} \cos(\theta/2)\end{bmatrix}
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Using Rotation gates}

\sphinxAtStartPar
The \(U\) gate used to be defined as \(U(\theta,\phi,\lambda)=R_z(\phi) R_y(\theta) R_z(\lambda)\). (See \sphinxhref{https://doi.org/10.48550/arXiv.1707.03429}{OpenQASM 2}.)  However, it adds a global phase on the Bloch sphere expression. To remove the inconvenience, now it is officially defined in \sphinxhref{https://openqasm.com/language/gates.html\#built-in-gates}{OpenQASM 3} as
\begin{quote}
\begin{equation*}
\begin{split}
U(\theta,\phi,\lambda) = e^{i (\lambda+\phi)/2} R_z(\phi) R_y(\theta) R_z(\lambda) .
\end{split}
\end{equation*}\end{quote}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{q1gates/u:sec-ugate}]{\ref{\detokenize{q1gates/u:sec-ugate}}}.1   Generate a state \(\cos(\pi/3)|0\rangle + \sin(\pi/3) e^{-i \pi/7} |1\rangle\) in a quantum circuit.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} import numpy}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} import QuatumCircuit and QuantumRegister classes.}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}\PYG{p}{,} \PYG{n}{QuantumRegister}

\PYG{c+c1}{\PYGZsh{} import STatevector class}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{c+c1}{\PYGZsh{} Preparation}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create a single qubit with name \PYGZsq{}q\PYGZsq{}.}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create a quantum circuit}

\PYG{c+c1}{\PYGZsh{}  apply the Ugate to the qubit}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{u}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the final state}
\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bloch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{u_5_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Acting on a superposition state}
\label{\detokenize{q1gates/u:acting-on-a-superposition-state}}\begin{quote}

\sphinxAtStartPar
\$\$
U(\textbackslash{}theta,\textbackslash{}phi,\textbackslash{}lambda)\textbackslash{}left(c\_0|0\textbackslash{}rangle+c\_1|1\textbackslash{}rangle\textbackslash{}right)
=\textbackslash{}left{[}c\_0 \textbackslash{}cos(\textbackslash{}theta/2) \sphinxhyphen{} c\_1 e\textasciicircum{}\{i\textbackslash{}phi\} \textbackslash{}sin(\textbackslash{}theta/2)\textbackslash{}right{]}|0\textbackslash{}rangle
\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
e\textasciicircum{}\{i \textbackslash{}phi\} \textbackslash{}left{[} c\_0 \textbackslash{}sin(\textbackslash{}theta/2) + c\_1 e\textasciicircum{}\{i \textbackslash{}lambda\}\textbackslash{}cos(\textbackslash{}theta/2) \textbackslash{}right{]}|1\textbackslash{}rangle
\$\$

\end{itemize}

\sphinxstepscope


\section{Rotation Gates, RX, RY, RZ}
\label{\detokenize{q1gates/r:rotation-gates-rx-ry-rz}}\label{\detokenize{q1gates/r:sec-rgate}}\label{\detokenize{q1gates/r::doc}}
\sphinxAtStartPar
The rotation gates \(R_x(\theta)\), \(R_y(\theta)\), and \(R_z(\theta)\) rotate the vector by \(\theta\) around \(x\), \(y\), and \(z\) axis, respectively.  All rotation gates require one parameter \(\theta\).

\sphinxAtStartPar
Qiskit circuit names are \sphinxcode{\sphinxupquote{rx}}, \sphinxcode{\sphinxupquote{ry}}, and \sphinxcode{\sphinxupquote{rx}}, respectively.

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.RXGate.html}{API References: RXGate}\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.RYGate.html}{API References: RYGate}\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.RZGate.html}{API References: RZGate}


\subsection{Definition}
\label{\detokenize{q1gates/r:definition}}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}
\begin{quote}
\begin{equation*}
\begin{split}
\begin{align}
R_x(\theta)|0\rangle &= \cos(\theta/2)|0\rangle - i \sin(\theta/2) |1\rangle\\
R_x(\theta)|1\rangle &= -i \sin(\theta/2) |0\rangle + \cos(\theta/2) |1\rangle
\end{align}
\end{split}
\end{equation*}\end{quote}
\begin{quote}
\begin{equation*}
\begin{split}
\begin{align}
R_y(\theta)|0\rangle &= \cos(\theta/2)|0\rangle - \sin(\theta/2) |1\rangle\\
R_y(\theta)|1\rangle &= \sin(\theta/2) |0\rangle + \cos(\theta/2) |1\rangle
\end{align}
\end{split}
\end{equation*}\end{quote}
\begin{quote}
\begin{equation*}
\begin{split}
\begin{align}
R_z(\theta)|0\rangle &= e^{-i \theta/2} |0\rangle\\
R_z(\theta)|1\rangle &= e^{i \theta/2} |1\rangle
\end{align}
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Pauli expressions}
\begin{quote}
\begin{equation*}
\begin{split}
\begin{align}
R_x(\theta) &= e^{-i X \theta/2} = \cos(\theta/2) I - i \sin(\theta/2) X\\
R_y(\theta) &= e^{-i Y \theta/2} = \cos(\theta/2) I - i \sin(\theta/2) Y\\
R_z(\theta) &= e^{-i Z \theta/2} = \cos(\theta/2) I - i \sin(\theta/2) Z
\end{align}
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Matrix expressions}
\begin{quote}
\begin{equation*}
\begin{split}
\begin{align}
R_x(\theta) &\doteq \begin{bmatrix} \cos(\theta/2) & -i \sin(\theta/2) \\ -i \sin(\theta/2)& \cos(\theta/2)\end{bmatrix} \\
R_y(\theta) &\doteq \begin{bmatrix} \cos(\theta/2) & - \sin(\theta/2) \\ \sin(\theta/2)& \cos(\theta/2)\end{bmatrix}\\
R_z(\theta) &\doteq \begin{bmatrix} e^{-i \theta/2} & 0 \\0 & e^{i \theta/2}\end{bmatrix}
\end{align}
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
These gates rotates the Bloch vector arounf \(x\), \(y\), and \(z\) axis by \(\theta\), respectively. They appear in quantum circuit as
The qiskit circuit symbols are \sphinxcode{\sphinxupquote{rx}}, \sphinxcode{\sphinxupquote{ry}}, and \sphinxcode{\sphinxupquote{rz}}, respectively and they appear in quantum circuit as

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   ┌───────┐┌───────┐┌───────┐
q: ┤ Rx(θ) ├┤ Ry(θ) ├┤ Rz(θ) ├
   └───────┘└───────┘└───────┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Example} \hyperref[\detokenize{q1gates/r:sec-rgate}]{\ref{\detokenize{q1gates/r:sec-rgate}}}.1   Starting with \(|0\rangle\), rotate about the \(y\) axis by \(\pi/3\), about \(z\) axis by \(\pi/2\), and about \(x\) axis by \(-2\pi/3\). This example shows that the final state is \(|1\rangle\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}capture}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{circuit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{ry}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{rz}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{rx}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} load the visdualization tool}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{visualize\PYGZus{}transition}

\PYG{c+c1}{\PYGZsh{} generate a movie (it will be shown in next cell,}
\PYG{n}{movie}\PYG{o}{=}\PYG{n}{visualize\PYGZus{}transition}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{fpg}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{spg}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{movie}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Additional useful Properties}
\label{\detokenize{q1gates/r:additional-useful-properties}}
\sphinxAtStartPar
In the following \(R\) represent any of \(RX\), \(RY\), and \(RZ\).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\(R^\dagger(\theta) = R^{-1}(\theta) = R(-\theta)\)

\item {}
\sphinxAtStartPar
\(R^{\alpha} (\theta) = R(\alpha\theta)\)

\item {}
\sphinxAtStartPar
\(R(\theta_2) \cdot R(\theta_1) = R(\theta_1 + \theta_2)\)  (note: all rotations must be around the same axis.)

\end{enumerate}


\subsection{Relation with other gates}
\label{\detokenize{q1gates/r:relation-with-other-gates}}
\sphinxAtStartPar
By definition a one\sphinxhyphen{}qubit gate transforms a Bloch vector to another, which is a rotation of the Bloch vector.  Hence, Any one\sphinxhyphen{}qubit gate can be expressed as rotation.  In turn, any rotation can be expressed by a combination of rotations.  Hence, any one\sphinxhyphen{}qubit gate can be expressed with a comination of RXGate, RYGate, and RZGate.  Mathematically, these three gates are enough to describe quantum computation.  However, the combination of rotation gates are not necessarily the most efficient implementation of gates.  Parameter\sphinxhyphen{}free gates are still preferred.

\sphinxAtStartPar
The previous gates are related to the rotation as
\begin{itemize}
\item {}
\sphinxAtStartPar
\(X = i RX(\pi) \simeq RX(\pi)\)

\item {}
\sphinxAtStartPar
\(Y = i RY(\pi) \simeq RY(\pi)\)

\item {}
\sphinxAtStartPar
\(Z = i RZ(\pi) \simeq RZ(\pi)\)

\item {}
\sphinxAtStartPar
\(H = X \cdot Y^{1/2} \simeq RX(\pi) RY(\pi/2)\)

\item {}
\sphinxAtStartPar
\(S = Z^{1/2} \simeq RZ(\pi/2)\)

\item {}
\sphinxAtStartPar
\(T = Z^{1/4} \simeq RZ(\pi/4)\)

\item {}
\sphinxAtStartPar
\(SX = X^{1/2} \simeq RX(\pi/2)\)

\end{itemize}


\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified

\sphinxstepscope


\section{XGate}
\label{\detokenize{q1gates/x:xgate}}\label{\detokenize{q1gates/x:sec-xgate}}\label{\detokenize{q1gates/x::doc}}
\sphinxAtStartPar
This is a Pauli operator and one of the most important one\sphinxhyphen{}qubit gates.  Hence, this section covers its properties at depth.

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.XGate.html\#qiskit.circuit.library.XGate}{Qiskit API References: XGate}


\subsection{Definition}
\label{\detokenize{q1gates/x:definition}}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}
\begin{quote}
\begin{equation}\label{equation:q1gates/x:XGate}
\begin{split}
\begin{align}
X |0\rangle &= |1\rangle\\
X |1\rangle &= |0\rangle
\end{align}
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\(X\) gate flips the computational basis, which resembles to the \(NOT\) gate for classical computation.   However, when it acts on superposition states, the state does not flip (the Bloch vector does not inverted).

\sphinxAtStartPar
\sphinxstylestrong{Matrix expression}
\begin{quote}
\begin{equation}\label{equation:q1gates/x:XGate-matrix}
\begin{split}
X \doteq \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{U gate expression}
\begin{quote}
\begin{equation}\label{equation:q1gates/x:XGate-U}
\begin{split}
X = U(\pi,0,\pi)
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{R gate expression}
\begin{quote}
\begin{equation*}
\begin{split}
X = i R_x(\pi)
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
The qiskit circuit symbol is \sphinxcode{\sphinxupquote{x}} and it appears in quantum circuit as

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   ┌───┐
q: ┤ X ├
   └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{q1gates/x:sec-xgate}]{\ref{\detokenize{q1gates/x:sec-xgate}}}.1

\sphinxAtStartPar
We construct a short quantum circuit using two Xgates and check how the state vector is transformed.  The initial state is always \(|0\rangle\).  The first Xgate flips it to \(|1\rangle\) and the second Xgate flips it back to \(|0\rangle\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} import QuatumCircuit and QuantumRegister classes.}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}\PYG{p}{,} \PYG{n}{QuantumRegister}

\PYG{c+c1}{\PYGZsh{} import STatevector class}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{c+c1}{\PYGZsh{} Preparation}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create a single qubit with name \PYGZsq{}q\PYGZsq{}.}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create a quantum circuit}

\PYG{c+c1}{\PYGZsh{} Intial state}
\PYG{n}{psi0} \PYG{o}{=} \PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}  apply the first Xgate to 0\PYGZhy{}th qubit}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Intermediate state}
\PYG{n}{psi1} \PYG{o}{=} \PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}  apply the second Xgate to 0\PYGZhy{}th qubit}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Final state}
\PYG{n}{psi2} \PYG{o}{=} \PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Format ket vector with LaTeX.}
\PYG{n}{ket0} \PYG{o}{=} \PYG{n}{psi0}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ket1} \PYG{o}{=} \PYG{n}{psi1}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ket2} \PYG{o}{=} \PYG{n}{psi2}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show the result using display function}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,} \PYG{n}{Math}
\PYG{n}{display}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Quantum circuit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mpl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{State vector before the gate}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{n}{ket0}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{State vector after the first Xgate}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ket1}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{State vector after the second Xgate}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ket2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Quantum circuit\PYGZsq{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{x_5_1}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}State vector before the gate\PYGZsq{}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split} |0\rangle\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}State vector after the first Xgate\PYGZsq{}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split} |1\rangle\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}State vector after the second Xgate\PYGZsq{}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split} |0\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Acting on a superposition state}
\label{\detokenize{q1gates/x:acting-on-a-superposition-state}}
\sphinxAtStartPar
When XGate is applied to a super position state the coefficient is swapped.  That is
\begin{quote}
\begin{equation}\label{equation:q1gates/x:X-on-superpos}
\begin{split}
X \left (c_0 |0\rangle + c_1 |1\rangle\right) = c_1 |0\rangle + c_0 |1\rangle
\end{split}
\end{equation}\end{quote}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{q1gates/x:sec-xgate}]{\ref{\detokenize{q1gates/x:sec-xgate}}}.1   Prove Eq. \eqref{equation:q1gates/x:X-on-superpos}.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{q1gates/x:sec-xgate}]{\ref{\detokenize{q1gates/x:sec-xgate}}}.1  How do the following superposition states transformed by the Xgate?
\begin{equation*}
\begin{split}
|L\rangle = \frac{1}{\sqrt{2}} \left (|0\rangle + i |1\rangle\right), \quad |R\rangle = \frac{1}{\sqrt{2}} \left (|0\rangle - i |1\rangle\right)
\end{split}
\end{equation*}
\sphinxAtStartPar
Using the general result \eqref{equation:q1gates/x:X-on-superpos}, we find
\begin{equation*}
\begin{split}
X |L\rangle = \frac{1}{\sqrt{2}} \left (i |0\rangle + |1\rangle\right) = i |R\rangle, \quad
X |R\rangle = \frac{1}{\sqrt{2}} \left (-i |0\rangle + |1\rangle\right) = -i |L\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Recalling that the global phase factor can be ignored, we conclude that
\begin{equation*}
\begin{split}
X |L\rangle \simeq |R\rangle, \quad
X |R\rangle \simeq |L\rangle.
\end{split}
\end{equation*}
\sphinxAtStartPar
The following Qiskit code demonstrates that mathematically \(X|L\rangle = i |R\rangle\) but \(X|L\rangle\) \textbackslash{}simeq |R\textbackslash{}rangle\$ when plotted in the Bloch sphere.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} import QuatumCircuit and QuantumRegister classes.}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}\PYG{p}{,} \PYG{n}{QuantumRegister}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{opflow} \PYG{k+kn}{import} \PYG{n}{Zero}\PYG{p}{,} \PYG{n}{One}

\PYG{c+c1}{\PYGZsh{} import STatevector class}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{c+c1}{\PYGZsh{} import numpy}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}


\PYG{n}{L}\PYG{o}{=}\PYG{p}{(}\PYG{n}{Zero}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{One}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{R}\PYG{o}{=}\PYG{p}{(}\PYG{n}{Zero}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{One}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Preparation}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create a single qubit with name \PYGZsq{}q\PYGZsq{}.}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create a quantum circuit}

\PYG{c+c1}{\PYGZsh{} set the qubit to |L\PYGZgt{} }
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{initialize}\PYG{p}{(}\PYG{n}{L}\PYG{o}{.}\PYG{n}{to\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} apply Xgate}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Final state}
\PYG{n}{final}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show that the final state is not exactly the same as |R\PYGZgt{}}
\PYG{n}{final}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\frac{\sqrt{2} i}{2} |0\rangle+\frac{\sqrt{2}}{2} |1\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Compare the final state with |R\PYGZgt{} in Bloch sphere.}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}

\PYG{c+c1}{\PYGZsh{} Generate Bloch vectors}
\PYG{n}{R\PYGZus{}bloch} \PYG{o}{=} \PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}
\PYG{n}{final\PYGZus{}bloch} \PYG{o}{=} \PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}\PYG{p}{(}\PYG{n}{final}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}

\PYG{c+c1}{\PYGZsh{} Compare X|L\PYGZgt{} and |R\PYGZgt{}.  They are equivalent in the Bloch sphere.}
\PYG{n}{display}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Original |R\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{R\PYGZus{}bloch}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X|L\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{final\PYGZus{}bloch}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Original |R\PYGZgt{}\PYGZsq{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{x_10_1}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}X|L\PYGZgt{}\PYGZsq{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{x_10_3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{q1gates/x:sec-xgate}]{\ref{\detokenize{q1gates/x:sec-xgate}}}.2   Show that \(X|+\rangle = |+\rangle\) and \(X|-\rangle = -|-\rangle\).  This means that \(X\) does not change \(|\pm\rangle\) except for the phase factor.


\bigskip\hrule\bigskip



\subsection{Important Properties}
\label{\detokenize{q1gates/x:important-properties}}\begin{quote}

\sphinxAtStartPar
\(X^2 = I\)
\end{quote}

\sphinxAtStartPar
This means that
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\(X^2\) does not do any thing on the qubit.

\item {}
\sphinxAtStartPar
\(X\) is  self\sphinxhyphen{}inverse, that is \(X^{-1} = X\).

\item {}
\sphinxAtStartPar
\(X\) is self\sphinxhyphen{}adjoint (\(X^\dagger = X\)) since \(X\) is unitary (\(X^\dagger = X^{-1}\)) by definition.

\end{enumerate}

\sphinxAtStartPar
Property 1 was deomnstrated in Qiskit Example \hyperref[\detokenize{q1gates/x:sec-xgate}]{\ref{\detokenize{q1gates/x:sec-xgate}}}.1.


\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified: 07/09/2022

\sphinxstepscope


\section{YGate}
\label{\detokenize{q1gates/y:ygate}}\label{\detokenize{q1gates/y:sec-ygate}}\label{\detokenize{q1gates/y::doc}}
\sphinxAtStartPar
This gate is not popular since it can be replaced with other common operators.  Hence, this section only briefly covers its properties.

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.YGate.html\#qiskit.circuit.library.YGate}{API References: YGate}


\subsection{Definition}
\label{\detokenize{q1gates/y:definition}}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}
\begin{quote}
\begin{equation*}
\begin{split}
Y |0\rangle = i|1\rangle, \qquad Y |1\rangle = -i |0\rangle
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Matrix expression}
\begin{quote}
\begin{equation}\label{equation:q1gates/y:YGate-matrix}
\begin{split}
Y \doteq \begin{bmatrix} 0 & -i \\ i & 0 \end{bmatrix}
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{U gate expression}
\begin{quote}
\begin{equation}\label{equation:q1gates/y:YGate-U}
\begin{split}
Y = U\left(\pi,\frac{\pi}{2},\frac{\pi}{2}\right)
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{R gate expression}
\begin{quote}
\begin{equation*}
\begin{split}
Y = i R_y(\pi)
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
The qiskit circuit symbol is \sphinxcode{\sphinxupquote{y}} and it appears in quantum circuit as

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   ┌───┐
q: ┤ Y ├
   └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\subsection{Acting on a superposition state}
\label{\detokenize{q1gates/y:acting-on-a-superposition-state}}
\sphinxAtStartPar
When Ygate is applied to a super position state the coefficient is swapped.  That is
\begin{quote}
\begin{equation}\label{equation:q1gates/y:Y-on-superpos}
\begin{split}
Y \left (c_0 |0\rangle + c_1 |1\rangle\right)  = -i (c_1 |0\rangle - c_0 |1\rangle)
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
If the global phase factor is omitted, we have
\begin{quote}
\begin{equation}\label{equation:q1gates/y:Y-on-superpos2}
\begin{split}
Y \left (c_0 |0\rangle + c_1 |1\rangle\right) \simeq c_1 |0\rangle - c_0 |1\rangle
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
Like Xgate, the coefficients are swapped.  In addition the relative phase of \(\pi\) is applied.


\subsection{Important Properties}
\label{\detokenize{q1gates/y:important-properties}}\begin{quote}

\sphinxAtStartPar
\(Y^2 = I\)
\end{quote}

\sphinxAtStartPar
This means that
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\(Y^2\) does not do any thing on the qubit.

\item {}
\sphinxAtStartPar
\(Y\) is  self\sphinxhyphen{}inverse, that is \(Y^{-1} = Y\).

\item {}
\sphinxAtStartPar
\(Y\) is self\sphinxhyphen{}adjoint (\(Y^\dagger = Y\)) since \(Y\) is unitary (\(Y^\dagger = Y^{-1}\)) by definition.

\end{enumerate}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{q1gates/y:sec-ygate}]{\ref{\detokenize{q1gates/y:sec-ygate}}}.1   Show that \(Y|+\rangle = -i |-\rangle\) and \(Y|-\rangle = i |+\rangle\).
Apart from the phase factor, \(Y\) flips \(|\pm\rangle\).


\bigskip\hrule\bigskip


\sphinxAtStartPar
Late modified xxx

\sphinxstepscope


\section{ZGate}
\label{\detokenize{q1gates/z:zgate}}\label{\detokenize{q1gates/z:sec-zgate}}\label{\detokenize{q1gates/z::doc}}
\sphinxAtStartPar
This gate is popular since it reverses the relative phase.

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.ZGate.html\#qiskit.circuit.library.ZGate}{API References: ZGate}


\subsection{Definition}
\label{\detokenize{q1gates/z:definition}}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}
\begin{quote}
\begin{equation*}
\begin{split}
Z |0\rangle = |0\rangle, \qquad Z |1\rangle = -|1\rangle
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
\(Z\) gate preserves \(|0\rangle\) but flips the phase of \(|1\rangle\).  This is a phase gate with prefixed phase change, “\sphinxhyphen{}1”.

\sphinxAtStartPar
\sphinxstylestrong{U gate expression}
\begin{quote}
\begin{equation}\label{equation:q1gates/z:ZGate-U}
\begin{split}
Z = U\left(0,\frac{\pi}{2},\frac{\pi}{2}\right)
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{R gate expression}
\begin{quote}
\begin{equation*}
\begin{split}
z = i R_z(\pi)
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
The Qiskit circuit symbol is \sphinxcode{\sphinxupquote{z}} and it appears in quantum circuit as

\sphinxAtStartPar
The standard symbol is \(Z\) and it appears in quantum circuit as

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   ┌───┐
q: ┤ Z ├
   └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\subsection{Acting on a superposition state}
\label{\detokenize{q1gates/z:acting-on-a-superposition-state}}
\sphinxAtStartPar
When ZGate is applied to a super position state the relative phase changes by \(\pi\).  That is
\begin{quote}
\begin{equation}\label{equation:q1gates/z:Z-on-superpos}
\begin{split}
Z \left (c_0 |0\rangle + c_1 |1\rangle\right)  = c_0 |0\rangle - c_1 |1\rangle)
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
In Bloch sphere representation,
\begin{quote}
\begin{equation*}
\begin{split}
Z \left( \cos(\theta/2)|0\rangle + \sin(\theta/2) e^{i\phi}|1\rangle\right) = \cos(\theta/2) |0\rangle + \sin(\theta/2) e^{i (\phi+\pi)} |1\rangle
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
This suggests that the Bloch vector rotates around \(z\) axis by \(\pi\).


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{q1gates/z:sec-zgate}]{\ref{\detokenize{q1gates/z:sec-zgate}}}.1   Show that \(Z|+\rangle = |-\rangle\) and \(Z|-\rangle = |+\rangle\). ZGate flips \(|\pm\rangle\) exactly (YGate flips only up to the global phase).  This property is useful in quantum computation.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{q1gates/z:sec-zgate}]{\ref{\detokenize{q1gates/z:sec-zgate}}}.1   Let us demonstrate the effect of ZGate using Qiskit.  Using the BLoch sphere representation, ZGate transform \((\theta,\phi)\) to \((\theta,\phi+\pi)\).  Try \(\theta=\pi/4\) and \(\phi=-\pi/4\).  Check that he Bloch vector rotates around \(z\) axis by \(\pi\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} import QuatumCircuit and QuantumRegister classes.}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}\PYG{p}{,} \PYG{n}{QuantumRegister}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{opflow} \PYG{k+kn}{import} \PYG{n}{Zero}\PYG{p}{,} \PYG{n}{One}

\PYG{c+c1}{\PYGZsh{} import STatevector class}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{c+c1}{\PYGZsh{} import numpy}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{theta}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}
\PYG{n}{phi}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}

\PYG{n}{ket0}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{theta}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Zero} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{theta}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{phi}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}\PYG{o}{*}\PYG{n}{One}

\PYG{c+c1}{\PYGZsh{} Preparation}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create a single qubit with name \PYGZsq{}q\PYGZsq{}.}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create a quantum circuit}

\PYG{c+c1}{\PYGZsh{} set the qubit to |L\PYGZgt{} }
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{initialize}\PYG{p}{(}\PYG{n}{ket0}\PYG{o}{.}\PYG{n}{to\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} apply Xgate}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{z}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Final state}
\PYG{n}{ket1}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compare the final state with |R\PYGZgt{} in Bloch sphere.}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}

\PYG{c+c1}{\PYGZsh{} Generate Bloch vectors}
\PYG{n}{bloch0} \PYG{o}{=} \PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}\PYG{p}{(}\PYG{n}{ket0}\PYG{p}{)}
\PYG{n}{bloch1} \PYG{o}{=} \PYG{n}{plot\PYGZus{}bloch\PYGZus{}multivector}\PYG{p}{(}\PYG{n}{ket1}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}

\PYG{c+c1}{\PYGZsh{} Compare |psi\PYGZgt{} and Z|psi\PYGZgt{}.  They are equivalent in the Bloch sphere.}
\PYG{n}{display}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Original |psi\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{bloch0}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z|psi\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{bloch1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Original |psi\PYGZgt{}\PYGZsq{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{z_7_1}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Z|psi\PYGZgt{}\PYGZsq{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{z_7_3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
When ZGate acts on a superposition state in \(\{|+\rangle,|-\rangle\}\), what will be the outcome?


\subsection{Important Properties}
\label{\detokenize{q1gates/z:important-properties}}\begin{quote}

\sphinxAtStartPar
\(Z^2 = I\)
\end{quote}

\sphinxAtStartPar
This means that
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\(Z^2\) does not do any thing on the qubit.

\item {}
\sphinxAtStartPar
\(Z\) is  self\sphinxhyphen{}inverse, that is \(Z^{-1} = Z\).

\item {}
\sphinxAtStartPar
\(Z\) is self\sphinxhyphen{}adjoint (\(Z^\dagger = Z\)) since \(Z\) is unitary (\(Z^\dagger = Z^{-1}\)) by definition.

\end{enumerate}

\sphinxstepscope


\section{Hadamard gate}
\label{\detokenize{q1gates/h:hadamard-gate}}\label{\detokenize{q1gates/h:sec-hgate}}\label{\detokenize{q1gates/h::doc}}
\sphinxAtStartPar
This is another very important one\sphinxhyphen{}qubit gate.  It changes basis set between \(\{|0\rangle,|1\rangle\}\) and \(\{|+\rangle,|-\rangle\}\).  We shall call this gate simply HGate.

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.HGate.html\#qiskit.circuit.library.HGate}{API References: HGate}


\subsection{Definition}
\label{\detokenize{q1gates/h:definition}}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}
\begin{quote}
\begin{equation}\label{equation:q1gates/h:HGate}
\begin{split}
H |0\rangle = |+\rangle, \qquad H |1\rangle = |-\rangle
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
This is the standard way to generate the \(x\)\sphinxhyphen{}basis (\eqref{equation:qubit/purestates:XBasis} from the computational basis.

\sphinxAtStartPar
\sphinxstylestrong{Matrix expression}
\begin{quote}
\begin{equation}\label{equation:q1gates/h:HGate-matrix}
\begin{split}
H \doteq \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{U gate expression}
\begin{quote}
\begin{equation}\label{equation:q1gates/h:HGate-U}
\begin{split}
H = U\left(\frac{\pi}{2},0,\pi\right)
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{R Gate expression}
\begin{quote}
\begin{equation*}
\begin{split}
H = i \, R_x(\pi) \cdot R_y\left(\frac{\pi}{2}\right)
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
The qiskit circuit symbol is \(h\) and it appears in quantum circuit as

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   ┌───┐
q: ┤ H ├
   └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{q1gates/h:sec-hgate}]{\ref{\detokenize{q1gates/h:sec-hgate}}}.1  Show that \(H^{-1}=H\). This means that the \(x\)\sphinxhyphen{}basis is transformed to the computational basis by \(H\) gates.
\begin{quote}
\begin{equation}\label{equation:q1gates/h:HGate-inv}
\begin{split}
H |+\rangle = |0\rangle, \quad H|-\rangle = |1\rangle
\end{split}
\end{equation}\end{quote}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{q1gates/h:sec-hgate}]{\ref{\detokenize{q1gates/h:sec-hgate}}}.1  A common use of the Hadamard gate is to switch the basis set.  In the quantum simulation of coin tossing (Qiskit Example \hyperref[\detokenize{qubit/measurement:sec-qubit-measurement}]{\ref{\detokenize{qubit/measurement:sec-qubit-measurement}}}.1) we have already used a Hadamard gate to generate \(+\rangle\).
Here we flip \(|0\rangle\) to \(|1\rangle\) via the \(x\)\sphinxhyphen{}basis.  First, we switch the basis from \(|0\rangle\) to \(|+\rangle\) by HGate.  Flip \(|+\rangle\) to \(|-\rangle\) by ZGate.  Then, switch back to the original basis by HGate.  The final state is \(|1\rangle\).
\begin{equation*}
\begin{split}
|0\rangle \xrightarrow{H} |+\rangle \xrightarrow{Z} |-\rangle \xrightarrow{H} |1\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
This means \(X = H \cdot Z \cdot H\).
In this example, the following process is visualized with Qiskit.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-output}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}capture}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{visualize\PYGZus{}transition}

\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{z}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{movie}\PYG{o}{=}\PYG{n}{visualize\PYGZus{}transition}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{fpg}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{spg}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{movie}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Acting on a superposition state}
\label{\detokenize{q1gates/h:acting-on-a-superposition-state}}\label{\detokenize{q1gates/h:sec-hgate-qft}}
\sphinxAtStartPar
The \(H\) gate transforms a super position state in an interesting way:
\begin{quote}
\begin{equation}\label{equation:q1gates/h:H-on-superpos}
\begin{split}
H \left (c_0 |0\rangle + c_1 |1\rangle\right)  = c_0 |+\rangle + c_1 |-\rangle)
=\frac{1}{\sqrt{2}}\left(c_0+c_1\right) |0\rangle + \frac{1}{\sqrt{2}}\left(c_0-c_1\right) |1\rangle
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
Apart from the normalization constant \(\frac{1}{\sqrt{2}}\), it computes addition and subtraction of the coefficients simultaneously, which is actually a Fourier transform (See \hyperref[\detokenize{algorithms/qft:sec-qft}]{Section \ref{\detokenize{algorithms/qft:sec-qft}}}.).  In therms of physics, the Hadamard gate “computes” constructive and destructive interference simultaneously.  We will be using this property in may applications.


\subsection{Qiskit example:}
\label{\detokenize{q1gates/h:qiskit-example}}\label{\detokenize{q1gates/h:ex-hgate-interference}}
\sphinxAtStartPar
We demonstrate Eq. \eqref{equation:q1gates/h:H-on-superpos} using Qiskit.  Suppose that the qubit is in a superposition state \(\cos(\pi/6) |0\rangle + \sin(\pi/6)|1\rangle\).  We want to find \(\cos(\pi/6)+\sin(\pi/6)\) and \(\cos(\pi/6)-\sin(\pi/6)\) using the Hadamard gate.  First, we construct a quantum circuit and test it with Statevector function.  Recall that this is not a quantum computation since we cheat by using \sphinxcode{\sphinxupquote{initialization}} and \sphinxcode{\sphinxupquote{Statevector}} function. I next example, we try to find the solution by quantum computation.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} import QuatumCircuit and QuantumRegister classes.}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{opflow} \PYG{k+kn}{import} \PYG{n}{Zero}\PYG{p}{,} \PYG{n}{One}

\PYG{c+c1}{\PYGZsh{} import STatevector class}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{c+c1}{\PYGZsh{} import numpy}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{theta}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}

\PYG{n}{c0}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{theta}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{c1}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{theta}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{ket0}\PYG{o}{=}\PYG{n}{c0}\PYG{o}{*}\PYG{n}{Zero} \PYG{o}{+}\PYG{n}{c1}\PYG{o}{*}\PYG{n}{One}

\PYG{c+c1}{\PYGZsh{} Preparation}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create a single qubit with name \PYGZsq{}q\PYGZsq{}.}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create a quantum circuit}

\PYG{c+c1}{\PYGZsh{} set the qubit to |L\PYGZgt{} }
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{initialize}\PYG{p}{(}\PYG{n}{ket0}\PYG{o}{.}\PYG{n}{to\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} apply Xgate}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Final state}
\PYG{n}{ket1}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{data}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} COmpare }
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c0+c1: Hadamard = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ket1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   Direct calculation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{c0}\PYG{o}{+}\PYG{n}{c1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c0\PYGZhy{}c1: Hadamard = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ket1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{   Direct calculation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{c0}\PYG{o}{\PYGZhy{}}\PYG{n}{c1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
c0+c1: Hadamard =  (1.3660254037844384+0j)    Direct calculation 1.3660254037844386
c0\PYGZhy{}c1: Hadamard =  (0.3660254037844388+0j)    Direct calculation 0.36602540378443876
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The above calculation mathematically confirms that the Hadamard gate computes the addition and subtraction.  Now, we want to solve it using quantum computation. Although there is no advantage over classical computation, we can see how quantum computation calculate two things, addition and subtraction, simultaneously (quantum parallelism). Using the  Born rule, the probability that the outcome of measurement is \(|0\rangle\) is given by \(p_0 = (c_0+c_1)^2/2\) and similarly for \(|1\rangle\) \(p_1 = (c_0-c_1)^2/2\).  By repeating quantum computation, many times, we can estimate \(p_0\) and \(p_1\).  From the probabilities we obtain \(|c_0 + c_1| = \sqrt{2 p_0}\) and \(|c_0-c_1| = \sqrt{2 p_1}\).  This approach give us only the modulus of the target quantities.  We can run the quantum calculation only finite times, the result is not exact.  Nevertheless, the results good enough with 10000 tries.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}  \PYG{c+c1}{\PYGZsh{} import qiskit}

\PYG{c+c1}{\PYGZsh{} Preparation}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create a single qubit named \PYGZsq{}q\PYGZsq{}.}
\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} create a single classical bit named \PYGZsq{}c\PYGZsq{}}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create a quantum circuit}

\PYG{c+c1}{\PYGZsh{} create the desired superpositionstate using RyGate}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{ry}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} apply Hadamard gate}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} measure the qubit state}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The quantum circuit has been constructed.  }
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌─────────┐┌───┐┌─┐
  q: ┤ Ry(π/3) ├┤ H ├┤M├
     └─────────┘└───┘└╥┘
c: 1/═════════════════╩═
                      0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Now we execute the circuit}

\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{10000}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Visualize the outcome}
\PYG{c+c1}{\PYGZsh{} import histgram plotting function}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}histogram}
\PYG{n}{plot\PYGZus{}histogram}\PYG{p}{(}\PYG{n}{counts}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{h_13_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} post analysis}
\PYG{c+c1}{\PYGZsh{} the outcome of counting is stored in  dict data type}
\PYG{c+c1}{\PYGZsh{} compute the probabilities}
\PYG{n}{p0}\PYG{o}{=}\PYG{n}{counts}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{nshots}
\PYG{n}{p1}\PYG{o}{=}\PYG{n}{counts}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{nshots}

\PYG{c+c1}{\PYGZsh{} estimate the addition and subtraction from the probabilities}
\PYG{c+c1}{\PYGZsh{} (this part is classical computation)}
\PYG{n}{add}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{p0}\PYG{p}{)}
\PYG{n}{sub}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{p1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Compare the results}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c0+c1: quantum = }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{   classical }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{add}\PYG{p}{,}\PYG{n}{c0}\PYG{o}{+}\PYG{n}{c1}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c0\PYGZhy{}c1: quantum = }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{   classical }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{sub}\PYG{p}{,}\PYG{n}{c0}\PYG{o}{\PYGZhy{}}\PYG{n}{c1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
c0+c1: quantum =  1.362   classical  1.366
c0\PYGZhy{}c1: quantum =  0.382   classical  0.366
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Important Properties}
\label{\detokenize{q1gates/h:important-properties}}\begin{quote}

\sphinxAtStartPar
\(H^2 = I\)
\end{quote}

\sphinxAtStartPar
This means that
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\(H^2\) does not do any thing on the qubit.

\item {}
\sphinxAtStartPar
\(H\) is  self\sphinxhyphen{}inverse, that is \(H^{-1} = H\).

\item {}
\sphinxAtStartPar
\(H\) is self\sphinxhyphen{}adjoint (\(H^\dagger = H\)) since \(H\) is unitary (\(H^\dagger = H^{-1}\)) by definition.

\end{enumerate}


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{q1gates/h:sec-hgate}]{\ref{\detokenize{q1gates/h:sec-hgate}}}.2   Knowing that \(X = H \cdot Z \cdot H\), show that the following relations are true.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\(Z = H \cdot X \cdot H\)

\item {}
\sphinxAtStartPar
\(Z \cdot H = H \cdot X\)

\item {}
\sphinxAtStartPar
\(H \cdot Z = X \cdot H\)

\end{enumerate}

\sphinxAtStartPar
These relations are used to simplify quantum circuits.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{q1gates/h:sec-hgate}]{\ref{\detokenize{q1gates/h:sec-hgate}}}.3   Prove that \(H \cdot Y \cdot H = -Y\).   Essentially, \(Y\) acts in the same way in both the computational basis and \(|\pm\rangle\) basis.


\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified: 07/09/2022

\sphinxstepscope


\section{SX and SXdg Gates}
\label{\detokenize{q1gates/sx:sx-and-sxdg-gates}}\label{\detokenize{q1gates/sx:sec-sxgate}}\label{\detokenize{q1gates/sx::doc}}
\sphinxAtStartPar
SX gate is a native gate of IBMQ hardware. Do not get confused with \(S\) times \(X\).

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.SXGate.html\#qiskit.circuit.library.SXGate}{API References: SXGate}\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.SXdgGate.html\#qiskit.circuit.library.SXdgGate}{API References: SXdgGate}


\subsection{Definition}
\label{\detokenize{q1gates/sx:definition}}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}
\begin{quote}
\begin{equation*}
\begin{split}
\begin{align}
&SX |0\rangle = e^{i\pi/4}|R\rangle,  &&SX |1\rangle = e^{i\pi/4}|L\rangle\\
&SX^\dagger |0\rangle = e^{-i\pi/4}|L\rangle, &&SX^\dagger |1\rangle = e^{-i\pi/4}|R\rangle
\end{align}
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Matrix expression}
\begin{quote}
\begin{equation}\label{equation:q1gates/sx:SXGate-matrix}
\begin{split}
SX \doteq \frac{1}{2} \begin{bmatrix} 1+i & 1-i \\ 1-i & 1+i \end{bmatrix}, \quad
SX^\dagger \doteq \frac{1}{2} \begin{bmatrix} 1-i & 1+i \\ 1+i & 1-i \end{bmatrix}
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{U gate expression}
\begin{quote}
\begin{equation*}
\begin{split}
SX = e^{i \pi/4}\, U\left(\frac{\pi}{2}, -\frac{\pi}{2}, \frac{\pi}{2} \right)
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{R gate expression}
\begin{quote}
\begin{equation*}
\begin{split}
SX = e^{i \pi/4} R_x(\pi/2), \quad SX^\dagger = e^{-i \pi/4} R_x(-\pi/2)
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
Notice that \(SX^2 = (SX^\dagger)^2 = X\).  Hence, \(SX\) and \(SX^\dagger\) are square roots of \(X\) and they are often expressed as  \(SX=X^{1/2}\) and \(SX^\dagger = X^{-1/2}\).

\sphinxAtStartPar
The Qiskit circuit symbols are \sphinxcode{\sphinxupquote{sx}} and \sphinxcode{\sphinxupquote{sxdg}}, respectively. They appear in quantum circuits as

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   ┌────┐┌──────┐
q: ┤ √X ├┤ √Xdg ├
   └────┘└──────┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\subsection{Transformation of other basis kets}
\label{\detokenize{q1gates/sx:transformation-of-other-basis-kets}}\begin{itemize}
\item {}
\sphinxAtStartPar
\(x\)\sphinxhyphen{}basis

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}
\begin{align}
&SX |+\rangle = |+\rangle,  &&SX |-\rangle = i |-\rangle \\
&SX^\dagger |+\rangle = |+\rangle, &&SX^\dagger |-\rangle = -i |-\rangle
\end{align}
\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {}
\sphinxAtStartPar
\(y\)\sphinxhyphen{}basis

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}
\begin{align}
&SX |L\rangle = e^{i\pi/4}|0\rangle,  &&SX |R\rangle = e^{i\pi/4}|1\rangle\\
&SX^\dagger |L\rangle = e^{-i\pi/4}|1\rangle, &&SX^\dagger |R\rangle = e^{-i\pi/4}|0\rangle
\end{align}
\end{split}
\end{equation*}\end{quote}


\subsection{Acting on a superposition state}
\label{\detokenize{q1gates/sx:acting-on-a-superposition-state}}
\sphinxAtStartPar
When SXGate and SXdgGate are applied to a super position state the coefficient to \(|0\rangle\) remains the same but that of \(|1\rangle\) gets additional phase factor.  That is
\begin{quote}
\begin{equation}\label{equation:q1gates/sx:SX-on-superpos}
\begin{split}
SX \left (c_0 |0\rangle + c_1 |1\rangle\right) = \frac{1}{\sqrt{2}}\left(e^{i \pi/4} c_0 + e^{-i \pi/4} c_1\right) |0\rangle + \frac{1}{\sqrt{2}}\left(e^{-i \pi/4} c_0 + e^{i \pi/4} c_1\right) |1\rangle
\end{split}
\end{equation}\end{quote}
\begin{quote}
\begin{equation}\label{equation:q1gates/sx:SXdg-on-superpos}
\begin{split}
SX^\dagger \left (c_0 |0\rangle + c_1 |1\rangle\right) = \frac{1}{\sqrt{2}}\left(e^{-i \pi/4} c_0 + e^{i \pi/4} c_1\right) |0\rangle + \frac{1}{\sqrt{2}}\left(e^{i \pi/4} c_0 + e^{-i \pi/4} c_1\right) |1\rangle
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
In \(\{|+\rangle,|-\rangle\}\) basis,
\begin{quote}
\begin{equation}\label{equation:q1gates/sx:SX-on-supoerpos+}
\begin{split}
SX \left(c_0 |+\rangle + c_1|-\rangle\right) = c_0 |+\rangle + i c_1 |-\rangle
\end{split}
\end{equation}\end{quote}
\begin{quote}
\begin{equation}\label{equation:q1gates/sx:SXdg-on-supoerpos+}
\begin{split}
SX^\dagger \left(c_0 |+\rangle + c_1|-\rangle\right) = c_0 |+\rangle - i c_1 |-\rangle
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
Comparing these relations with Eqs. \eqref{equation:q1gates/s:S-on-superpos} and \eqref{equation:q1gates/s:Sdg-on-superpos}, we find that SXGate and SGate work in the same way but in different basis sets.


\subsection{Additional useful Properties}
\label{\detokenize{q1gates/sx:additional-useful-properties}}
\sphinxAtStartPar
\(SX \cdot SX = SX^\dagger \cdot SX^\dagger = X\) implies that
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\(SX = X \cdot SX^\dagger = SX^\dagger\cdot X, \quad SX^\dagger = X \cdot SX = SX \cdot X\).

\item {}
\sphinxAtStartPar
\(X = SX \cdot X \cdot SX^\dagger = SX^\dagger \cdot X \cdot SX\)

\item {}
\sphinxAtStartPar
\(SX = X \cdot SX \cdot X, \quad SX^\dagger = X \cdot SX^\dagger \cdot X\).

\end{enumerate}

\sphinxstepscope


\section{S Gate and S\protect\(^\dagger\protect\) Gate}
\label{\detokenize{q1gates/s:s-gate-and-s-dagger-gate}}\label{\detokenize{q1gates/s:sec-sgate}}\label{\detokenize{q1gates/s::doc}}
\sphinxAtStartPar
We shall call \(S\) and \(S^\dagger\) gates SGate and SdgGate, respectively.

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.SGate.html\#qiskit.circuit.library.SGate}{API References: SGate}\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.SdgGate.html\#qiskit.circuit.library.SdgGate}{API References: SdgGate}


\subsection{Definition}
\label{\detokenize{q1gates/s:definition}}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}
\begin{quote}
\begin{equation}\label{equation:q1gates/s:SGate}
\begin{split}\begin{eqnarray}
S |0\rangle &=& |0\rangle, \qquad S |1\rangle = i|1\rangle \\
S^\dagger |0\rangle &=& |0\rangle, \qquad S^\dagger |1\rangle = -i|1\rangle
\end{eqnarray}
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Matrix expression}
\begin{quote}
\begin{equation}\label{equation:q1gates/s:Sgate-matrix}
\begin{split}
S \doteq \begin{bmatrix} 1 & 0 \\ 0 & i \end{bmatrix}, \quad S^\dagger \doteq \begin{bmatrix} 1 & 0 \\ 0 & -i \end{bmatrix}
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{U gate expression}
\begin{quote}
\begin{equation*}
\begin{split}
S = U\left(0,0,\frac{\pi}{2}\right), \quad S^\dagger = U\left(0,0,-\frac{\pi}{2}\right)
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
(Sgate\sphinxhyphen{}U)

\sphinxAtStartPar
\sphinxstylestrong{R gate expression}
\begin{quote}
\begin{equation*}
\begin{split}
S = e^{i\pi/4} R_z (\pi/2), \quad S^\dagger = e^{-i\pi/4} R_z (-\pi/2)
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
The qiskit circuit symbols are \sphinxcode{\sphinxupquote{s}}  and \sphinxcode{\sphinxupquote{sdg}}, respectively. They appear in quantum circuits as

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{s}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{sdg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   ┌───┐┌─────┐
q: ┤ S ├┤ Sdg ├
   └───┘└─────┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Acting on a superposition state}
\label{\detokenize{q1gates/s:acting-on-a-superposition-state}}
\sphinxAtStartPar
When SGate and SdgGate are applied to a super position state the coefficient to \(|0\rangle\) remains the same but that of \(|1\rangle\) gets additional phase factor.  That is
\begin{quote}
\begin{equation}\label{equation:q1gates/s:S-on-superpos}
\begin{split}
S \left (c_0 |0\rangle + c_1 |1\rangle\right) = c_0 |0\rangle + i c_1 |1\rangle
\end{split}
\end{equation}\end{quote}
\begin{quote}
\begin{equation}\label{equation:q1gates/s:Sdg-on-superpos}
\begin{split}
S^\dagger \left (c_0 |0\rangle + c_1 |1\rangle\right) = c_0 |0\rangle - i c_1 |1\rangle
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
In Bloch sphere representation,
\begin{quote}
\begin{equation*}
\begin{split}
S \left( \cos(\theta/2)|0\rangle + \sin(\theta/2) e^{i\phi}|1\rangle\right) = \cos(\theta/2) |0\rangle + \sin(\theta/2) e^{i (\phi+\pi/2)} |1\rangle
\end{split}
\end{equation*}\end{quote}
\begin{quote}
\begin{equation*}
\begin{split}
S^\dagger \left( \cos(\theta/2)|0\rangle + \sin(\theta/2) e^{i\phi}|1\rangle\right) = \cos(\theta/2) |0\rangle + \sin(\theta/2) e^{i (\phi-\pi/2)} |1\rangle
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
This suggests that the Bloch vector rotates around \(z\) axis by \(\pm\pi/2\).
Notice that the relative phase changes by \(e^{\pm i\pi/2} = \pm i\).  Recall that \(Z\) changes the relative phase by \(e^{i \pi} = -1\). Further notice that \((e^{\pm i \pi/2})^2 = e^{i \pi}\).  Hence, \(S^2 = (S^\dagger)^2 = Z\).  Because of this relation,  \(S\) is sometimes expressed as \(\sqrt{Z}\) or \(Z^{1/2}\) and \(S^\dagger = Z^{-1/2}\).

\sphinxAtStartPar
Setting \(c_0=c_1=\frac{1}{\sqrt{2}}\), we find basis transformation
\begin{quote}
\begin{equation}\label{equation:q1gates/s:Sgate-fwd}
\begin{split}
S|+\rangle = |L\rangle, \quad S|-\rangle = |R\rangle
\end{split}
\end{equation}\end{quote}
\begin{quote}
\begin{equation}\label{equation:q1gates/s:SdgGate-fwd}
\begin{split}
S^\dagger|+\rangle = |R\rangle, \quad S^\dagger|-\rangle = |L\rangle
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
Since \(S\) is unitary \(S S^\dagger = I\) and thus \(S^{-1}=S^\dagger\) and \((S^\dagger)^{-1} = S\).  Now the inverse of \eqref{equation:q1gates/s:Sgate-fwd} and \sphinxcode{\sphinxupquote{SdgGate\sphinxhyphen{} fwd}} are
\begin{quote}
\begin{equation}\label{equation:q1gates/s:Sgate-inv}
\begin{split}
S^\dagger |L\rangle = |+\rangle, \quad S^\dagger|R\rangle = |-\rangle
\end{split}
\end{equation}\end{quote}
\begin{quote}
\begin{equation}\label{equation:q1gates/s:SdgGate-inv}
\begin{split}
S|L\rangle = |-\rangle, \quad S|R\rangle = |+\rangle
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
Combining HGate and SGate, we can transform the computational basis \(\{|0\rangle, |1\rangle\}\) to \(\{|L\rangle, |R\rangle\}\) by \(S \cdot H\) and its inverse is \(H \cdot S^\dagger\).  Now, we know we can move from one basis to another by \(H\), \(S\), and \(S \cdot H\).


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Qiskit Example} \hyperref[\detokenize{q1gates/s:sec-sgate}]{\ref{\detokenize{q1gates/s:sec-sgate}}}.1  We demonstrate the above basis set transformation using Qiskit.  First, we construct a quantum circuit corresponding to the following transformation
\begin{equation*}
\begin{split}
|0\rangle \xrightarrow{H} |+\rangle \xrightarrow{S} |L\rangle \xrightarrow{S^\dagger} |+\rangle \xrightarrow{H} |0\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Notice that the whole operation can be written as \(H \cdot S^\dagger \cdot S \cdot H |0\rangle\) it can be simplified as
\begin{equation*}
\begin{split}
H \cdot S^\dagger \cdot S \cdot H |0\rangle = H \cdot (S^\dagger \cdot S) \cdot H = H \cdot I \cdot H = H^2 = I
\end{split}
\end{equation*}
\sphinxAtStartPar
Hence, the whole operation does nothing at all.  In order to avoid unnecessary computation like this, we need to understand the properties of gates.  You will surprise that a long circuit can be significantly shortened by contracting gates.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}capture}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{visualize\PYGZus{}transition}

\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{s}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{sdg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{movie}\PYG{o}{=}\PYG{n}{visualize\PYGZus{}transition}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{fpg}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{spg}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mpl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{s_9_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{movie}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Additional useful Properties}
\label{\detokenize{q1gates/s:additional-useful-properties}}
\sphinxAtStartPar
\(S \cdot, S = S^\dagger \cdot S^\dagger = Z\) implies that
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
\(S = Z \cdot S^\dagger = S^\dagger \cdot Z, \quad S^\dagger = Z \cdot S = S  \cdot Z\).

\item {}
\sphinxAtStartPar
\(Z = S \cdot Z \cdot  S^\dagger = S^\dagger \cdot Z \cdot S\)

\item {}
\sphinxAtStartPar
\(S = Z \cdot S \cdot Z, \quad S^\dagger = Z \cdot S^\dagger \cdot Z\).

\end{enumerate}


\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified 07/11/2022

\sphinxstepscope


\section{P Gate}
\label{\detokenize{q1gates/p:p-gate}}\label{\detokenize{q1gates/p::doc}}
\sphinxAtStartPar
P gate is also known as \sphinxstyleemphasis{phase gate}.  This gate contains a parameter.

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.circuit.library.PhaseGate.html\#qiskit.circuit.library.PhaseGate}{API References: PhaseGate}


\subsection{Definition}
\label{\detokenize{q1gates/p:definition}}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}
\begin{quote}
\begin{equation*}
\begin{split}
\begin{align}
&P(\theta) |0\rangle = |0\rangle, && P(\theta) |1\rangle = e^{i \theta}|1\rangle\\
&P^\dagger(\theta) |0\rangle = |0\rangle, && P^\dagger(\theta) |1\rangle = e^{-i \theta}|1\rangle
\end{align}
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{Matrix expression}
\begin{quote}
\begin{equation*}
\begin{split}
P(\theta) = \begin{bmatrix}1&0\\0&e^{i \theta}\end{bmatrix}, \qquad P^\dagger(\theta) = \begin{bmatrix}1&0\\0&e^{-i \theta}\end{bmatrix}
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{U gate expression}
\begin{quote}
\begin{equation*}
\begin{split}
P = U\left(0,0,\theta \right) = U\left(0,\theta,0 \right), \quad P^\dagger = U\left(0,0,-\theta\right)= U\left(0,-\theta,0\right)
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{R gate expression}
\begin{quote}
\begin{equation*}
\begin{split}
P = e^{i \theta/2} R_z(\theta), \quad P^\dagger = e^{-i \theta/2} R_z(-\theta)
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
The qiskit circuit symbol is \sphinxcode{\sphinxupquote{p}}. It appears in quantum circuits as

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   ┌──────┐
q: ┤ P(θ) ├
   └──────┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
\(Z\), \(S\), \(T\) and \(P\) all rotates the Bloch vector around the \(z\) axis. gates are special cases of \(P\) gate: \(Z=P(\pi)\), \(S=P(\pi/2)\) and \(T=P(\pi/4)\). While these relations are mathematically exact and \(P\) gate can replace them, the parameter\sphinxhyphen{}free gates should be used when the rotation angle


\subsection{Acting on a superposition state}
\label{\detokenize{q1gates/p:acting-on-a-superposition-state}}
\sphinxAtStartPar
When PGate is applied to a superposition state, the coefficient to \(|0\rangle\) remains the same but that of \(|1\rangle\) gets additional phase factor.  That is
\begin{quote}
\begin{equation}\label{equation:q1gates/p:P-on-superpos}
\begin{split}
P(t) \left (c_0 |0\rangle + c_1 |1\rangle\right) = c_0 |0\rangle + e^{it} c_1 |1\rangle
\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
In Bloch sphere representation,
\begin{quote}
\begin{equation*}
\begin{split}
P(t) \left( \cos(\theta/2)|0\rangle + \sin(\theta/2) e^{i\phi}|1\rangle\right) = \cos(\theta/2) |0\rangle + \sin(\theta/2) e^{i (\phi+t)} |1\rangle
\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
This suggests that the Bloch vector rotates around \(z\) axis by \(t\).

\sphinxstepscope


\section{Change of basis sets}
\label{\detokenize{q1gates/change-basis:change-of-basis-sets}}\label{\detokenize{q1gates/change-basis:sec-change-basis}}\label{\detokenize{q1gates/change-basis::doc}}
\sphinxAtStartPar
Although the computational basis (\(z\)\sphinxhyphen{}basis) \(\{|0\rangle,|1\rangle\}\) is the primary basis set, in some cases \(x\)\sphinxhyphen{}basis \(\{|+\rangle,|-\rangle\}\) and \(y\)\sphinxhyphen{}basis \(\{|L\rangle,|R\rangle\}\) are more convenient.

\sphinxAtStartPar
We can change from a basis set to another by \(H\), \(S\), and \(S\cdot H\).
\begin{equation*}
\begin{split}
\begin{align}
H |0\rangle &= |+\rangle, & \quad H|1\rangle &= |-\rangle \\
S |+\rangle &= |L\rangle, &\quad S|-\rangle &= |R\rangle \\
(S\cdot H)|0\rangle &= |L\rangle, \quad & (S\cdot H)|1\rangle &= |R\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
and their inverse transformation are
\begin{equation*}
\begin{split}
\begin{align}
H |+\rangle &= |0\rangle, & \quad H|-\rangle &= |1\rangle \\
S^\dagger |L\rangle &= |+\rangle, &\quad S^\dagger|R\rangle &= |-\rangle \\
(H\cdot S^\dagger)|L\rangle &= |0\rangle, \quad & (H\cdot S^\dagger)|R\rangle &= |1\rangle
\end{align}
\end{split}
\end{equation*}

\subsection{Transformation of gates}
\label{\detokenize{q1gates/change-basis:transformation-of-gates}}
\sphinxAtStartPar
Consider the following three transofrmations by gates, \(G_z\), \(G_x%\), and \(G_y\).
\begin{equation*}
\begin{split}
\begin{eqnarray}
G_z \left (a_0 |0\rangle + a_1 |1\rangle\right) &=& b_0 |0\rangle + b_1 |1\rangle \\
G_x \left (a_0 |+\rangle + a_1 |-\rangle\right) &=& b_0 |+\rangle + b_1 |-\rangle\\
G_y \left (a_0 |L\rangle + a_1 |R\rangle\right) &=& b_0 |L\rangle + b_1 |R\rangle
\end{eqnarray}
\end{split}
\end{equation*}
\sphinxAtStartPar
The difference is only the basis set and the coefficients are the same in all three cases.  Then, there are simple relation among the gates.
\begin{equation*}
\begin{split}
G_z = H \cdot G_x \cdot H, \quad G_y = S \cdot G_x \cdot S^\dagger = (S \cdot H) \cdot G_z  \cdot(H \cdot S^\dagger)
\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Example 1}  Swapping coefficients

\sphinxAtStartPar
Suppose that a state vector is given in \(\{|+\rangle,|-\rangle\}\) basis as \(c_0 |+\rangle + c_1 |-\rangle\). We want to swap the coefficients.
\begin{equation*}
\begin{split}
c_0 |+\rangle + c_1 |-\rangle \quad \xrightarrow{?} \quad c_1 |+\rangle + c_0 |-\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
What gate do we need?  In \hyperref[\detokenize{q1gates/x:sec-xgate}]{Section \ref{\detokenize{q1gates/x:sec-xgate}}}, we learned that XGate swaps the coeeficients in the computational basis. Recalling that HGate switches basis set between the computational basis and the \(x\)\sphinxhyphen{}basis.  Then, \(H \cdot X \cdot H\) should do the job.  Let us try it.
\begin{equation*}
\begin{split}
c_0 |+\rangle + c_1 |-\rangle \quad \xrightarrow{H} \quad c_0 |0\rangle + c_1 |1\rangle
\quad \xrightarrow{X} \quad  c_1 |0\rangle + c_0 |1\rangle \quad \xrightarrow{H} \quad
c_1 |+\rangle + c_0 |-\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
REcall that  we derived \(Z=H \cdot X \cdot H\) in \hyperref[\detokenize{q1gates/h:sec-hgate}]{Section \ref{\detokenize{q1gates/h:sec-hgate}}}.  \(Z\) is the gate we wanted.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{q1gates/change-basis:sec-change-basis}]{\ref{\detokenize{q1gates/change-basis:sec-change-basis}}}.1   We want to swap the coefficients in the \(y\)\sphinxhyphen{}basis.  That is \(
c_0 |L\rangle + c_1 |R\rangle \quad \xrightarrow{?} \quad c_1 |L\rangle + c_0 |R\rangle \). Find an gate for this transformation.

\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{q1gates/change-basis:sec-change-basis}]{\ref{\detokenize{q1gates/change-basis:sec-change-basis}}}.2   In \hyperref[\detokenize{q1gates/sx:sec-sxgate}]{Section \ref{\detokenize{q1gates/sx:sec-sxgate}}}, we noticed that \(S\) gate and \(SX\) gate work in the same way but in different basis sets.  Show that \(SX = H \cdot S \cdot H\) and \(SX^\dagger = H \cdot S^\dagger \cdot H\).


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Example 2} addition and subtraction of the coefficients

\sphinxAtStartPar
We want to find a gate that transforms a state vector as
\begin{equation*}
\begin{split}
c_0 |+\rangle + c_1|-\rangle \quad \xrightarrow{?} \quad \frac{1}{\sqrt{2}}\left(c_0+c_1\right)|+\rangle + \frac{1}{\sqrt{2}}\left(c_0-c_1\right)|-\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Recalling that \(H\) gate does the same type of transformation for the computational basis.  The \(H\) gate itself is also used to change the basis set. Hence, \(H \cdot H \cdot H\) will do the job. However, we recall that \(H^2=I\).  Hence, \(H \cdot H \cdot H=H\).  Interestingly, A single \(H\) works in the same way on the two different basis sets.

\sphinxAtStartPar
Similarly, we want to find a gate that transforms a state vector in the \(y\)\sphinxhyphen{}basis as
\begin{equation*}
\begin{split}
c_0 |L\rangle + c_1|R\rangle \quad \xrightarrow{?} \quad \frac{1}{\sqrt{2}}\left(c_0+c_1\right)|L\rangle + \frac{1}{\sqrt{2}}\left(c_0-c_1\right)|R\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
The \(S\) and \(S^\dagger\) gates swap the basis set between the \(x\)\sphinxhyphen{}basis and the \(y\)\sphinxhyphen{}basis. We already know that the \(H\) gate works between the computational gate and the \(x\) gate.  Hence, \(S \cdot H \cdot S^\dagger\) should achieve the task.


\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{q1gates/change-basis:sec-change-basis}]{\ref{\detokenize{q1gates/change-basis:sec-change-basis}}}.3   Show that \(S \cdot H \cdot S^\dagger\) works as desired.


\bigskip\hrule\bigskip



\subsection{Qiskit Example:  Measuring quantum phase.}
\label{\detokenize{q1gates/change-basis:qiskit-example-measuring-quantum-phase}}\label{\detokenize{q1gates/change-basis:ex-quantum-phase}}
\sphinxAtStartPar
This is the extension of \hyperref[\detokenize{q1gates/h:ex-hgate-interference}]{Section \ref{\detokenize{q1gates/h:ex-hgate-interference}}}.

\sphinxAtStartPar
Consider a superposition state,
\begin{equation*}
\begin{split}
|\phi\rangle = \frac{1}{\sqrt{2}}\left(|0\rangle + e^{i \phi} |1\rangle\right)
\end{split}
\end{equation*}
\sphinxAtStartPar
The corresponding Bloch vector is \(\vec{r} = \cos\phi\, \hat{x} + \sin\phi\,\hat{y}\).

\sphinxAtStartPar
We want to find out the value of the phase angle \(\phi\).  If we measure this state, we only get the modulus of the coefficients and thus no information on the phase is obtained.  In physics, the phase difference between two waves is measured by the interference pattern.  Here, we use the same method.

\sphinxAtStartPar
First, we write the state vector with the \(x\)\sphinxhyphen{}basis.
\begin{equation*}
\begin{split}
|\phi\rangle = \frac{1}{2}\left[ (1+e^{i \phi}) |+\rangle + (1-e^{i \phi}) |-\rangle \right]
\end{split}
\end{equation*}
\sphinxAtStartPar
Notice that the modulus square of coefficients are
\begin{equation*}
\begin{split}
p_0 = \left | \frac{1}{2} (1+e^{i \phi}) \right |^2 =  \frac{1}{2}\left(1+\cos \phi\right), \qquad p_1 = \left | \frac{1}{2} (1-e^{i \phi}) \right |^2 = \frac{1}{2}\left(1-\cos \phi\right)
\end{split}
\end{equation*}
\sphinxAtStartPar
If these quantities are measured, we find the value of \(\cos\phi = p_0 - p_1\).  However, the measurement must be done in the computational basis. Hence, we change the basis set by \(H\).
\begin{equation*}
\begin{split}
H |\phi\rangle = \frac{1}{2}\left[ (1+e^{i \phi}) |0\rangle + (1-e^{i \phi}) |1\rangle \right]
\end{split}
\end{equation*}
\sphinxAtStartPar
Measuring \(|0\rangle\) and \(|1\rangle\), we find the probabilities \(p_0\) and \(p_1\) from which we find \(\cos \phi\).  Notice that this is the \(x\) component of the Bloch vector.

\sphinxAtStartPar
In order to determine \(e^{i \phi}\), we also have to find \(\sin\phi\), that is the \(y\) component of the Bloch vector.  We rewrite the state vector again but in the \(y\)\sphinxhyphen{}basis.
\begin{equation*}
\begin{split}
\psi\rangle = \frac{1}{2} \left[ (1-i e^{i \phi}) |L \rangle + (1 + i e^{i \phi}) |R\rangle \right]
\end{split}
\end{equation*}
\sphinxAtStartPar
The modulus square of coefficients are now
\begin{equation*}
\begin{split}
q_0 = \left | \frac{1}{2} (1-i e^{i \phi}) \right |^2 =  \frac{1}{2}\left(1+\sin \phi\right), \qquad q_1 = \left | \frac{1}{2} (1+i e^{i \phi}) \right |^2 = \frac{1}{2}\left(1-\sin \phi\right)
\end{split}
\end{equation*}
\sphinxAtStartPar
To measure these quantities, the \(y\)\sphinxhyphen{}basis must be transformed to the computational basis. It is done by \(H \cdot S^\dagger\).
\begin{equation*}
\begin{split}
(H \cdot S^\dagger) |\psi\rangle = \frac{1}{2}\left(1- i e^{i \phi}\right) |0\rangle + \frac{1}{2}\left(1+ i e^{-i \phi}\right) |1\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
The measurement determines he probabilities \(q_0\) and \(q_1\) and we find \(\sin\phi = q_0 - q_1\).Now we have full information on \(e^{i \phi} = \cos\phi + i \sin\phi\).

\sphinxAtStartPar
Let us try this method using Qiskit.

\sphinxAtStartPar
First we create the superposition state using \(H\) and \(P\) gates.  We set \(\phi=\pi/3\).  The goal of the quantum computation is to obtain this angle by quantum measurement.  In the following quantum circuit, we use two qubits, one for \(\cos\phi\) and the other for \(\sin\phi\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c+c1}{\PYGZsh{} two classical registers}
\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} two quantum registers (qubits)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set the quantum circuit}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Generation of the superposition state}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{p}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} separate the preparation part from the phase determination}
\PYG{c+c1}{\PYGZsh{} by placing a barrier}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} real part}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} imaginary part}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{sdg}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} measure the both qubits}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} show the circuit}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐┌────────┐ ░  ┌───┐      ┌─┐
q\PYGZus{}0: ┤ H ├┤ P(π/3) ├─░──┤ H ├──────┤M├───
     ├───┤├────────┤ ░ ┌┴───┴┐┌───┐└╥┘┌─┐
q\PYGZus{}1: ┤ H ├┤ P(π/3) ├─░─┤ Sdg ├┤ H ├─╫─┤M├
     └───┘└────────┘ ░ └─────┘└───┘ ║ └╥┘
c: 2/═══════════════════════════════╩══╩═
                                    0  1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{8192}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get the marginal counts}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{result} \PYG{k+kn}{import} \PYG{n}{marginal\PYGZus{}counts}
\PYG{n}{counts\PYGZus{}x} \PYG{o}{=} \PYG{n}{marginal\PYGZus{}counts}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,}\PYG{n}{indices}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{counts\PYGZus{}y} \PYG{o}{=} \PYG{n}{marginal\PYGZus{}counts}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,}\PYG{n}{indices}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} calculate the marginal probability for the sine part}
\PYG{n}{q0}\PYG{o}{=}\PYG{n}{counts\PYGZus{}y}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{nshots}
\PYG{n}{q1}\PYG{o}{=}\PYG{n}{counts\PYGZus{}y}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{nshots}
\PYG{n}{dy}\PYG{o}{=}\PYG{n}{q0}\PYG{o}{\PYGZhy{}}\PYG{n}{q1}

\PYG{c+c1}{\PYGZsh{} calculate the marginal probability for the cosine part}
\PYG{n}{p0}\PYG{o}{=}\PYG{n}{counts\PYGZus{}x}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{nshots}
\PYG{n}{p1}\PYG{o}{=}\PYG{n}{counts\PYGZus{}x}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{nshots}
\PYG{n}{dx}\PYG{o}{=}\PYG{n}{p0}\PYG{o}{\PYGZhy{}}\PYG{n}{p1}

\PYG{c+c1}{\PYGZsh{} evaluate the phase angle}
\PYG{n}{phi}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arctan2}\PYG{p}{(}\PYG{n}{dy}\PYG{p}{,}\PYG{n}{dx}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} print out the results}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{measured phi = }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{exact answer = }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{error =  }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{phi} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
measured phi =  1.043
exact answer =  1.047
error =  \PYGZhy{}0.004
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The result of quantum computing is quite close to the original phase angle.


\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified: 07/09/2022

\sphinxstepscope


\section{State tomography}
\label{\detokenize{q1gates/tomography:state-tomography}}\label{\detokenize{q1gates/tomography:sec-state-tomography}}\label{\detokenize{q1gates/tomography::doc}}
\sphinxAtStartPar
State \sphinxstyleemphasis{tomography} is an experimental method to determine the state of a quantum system. In this section, we try to determine the pure state of a qubit by quantum computation.   Measurement of a single qubit cannot determine it due to the stochastic nature of quantum measurement.  We must prepare many  qubits in the same state.

\sphinxAtStartPar
In \hyperref[\detokenize{q1gates/change-basis:ex-quantum-phase}]{Section \ref{\detokenize{q1gates/change-basis:ex-quantum-phase}}}, we developed a quantum circuit that determines the quantum phase of a qubit.  In that example, we had only one parameter, \(\phi\), to be determined. To obtain the full information (up to the global phase) of the state vector, we have to determine two parameters.  Recall that the state of a qubit can be expressed as
\begin{equation*}
\begin{split}
|\psi\rangle = \cos\left(\frac{\theta}{2}\right) |0\rangle + \sin\left(\frac{\theta}{2}\right) e^{i \phi}|1\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Measuring this state directly, we obtain only \(\left|\cos\left(\frac{\theta}{2}\right)\right|\) and \(\left|\sin\left(\frac{\theta}{2}\right)\right|\). Neither \(\theta\) nor \(\phi\) can be determined from them. We need a quantum algorithm similar to the method used in \hyperref[\detokenize{q1gates/change-basis:ex-quantum-phase}]{Section \ref{\detokenize{q1gates/change-basis:ex-quantum-phase}}}.  See the following Strategy box on State Tomography.

\begin{sphinxadmonition}{note}{Strategy \sphinxhyphen{} State Tomography}

\sphinxAtStartPar
To determine the Bloch vector corresponding to a pure state \(\psi\rangle\),  change the \(x\)\sphinxhyphen{}, \(y\)\sphinxhyphen{}, \(z\)\sphinxhyphen{}basis to the computational basis and measure the state in the computational basis.
\begin{itemize}
\item {}
\sphinxAtStartPar
\(x\) componentChange the basis from the \(x\)\sphinxhyphen{}basis to the computational basis  by the \(H\) gate.Measure \(H |\psi\rangle\).  Then, \(r_x = \sin\theta \cos \phi = p_0 -p_1\).

\item {}
\sphinxAtStartPar
\(y\) componentChange the basis from the \(y\)\sphinxhyphen{}basis to the computational basis  by the \(H\cdot S^\dagger\) gate.Measure \((H\cdot S^\dagger) |\psi\rangle\).  Then, \(r_y = \sin\theta \sin\phi = p_0 -p_1\).

\item {}
\sphinxAtStartPar
\(z\) componentSince the \(z\)\sphinxhyphen{}basis and the computational basis are the same, no need to change the basis.Measure \(|\psi\rangle\).  Then, \(r_z = \cos\theta = p_0 -p_1\).

\end{itemize}

\sphinxAtStartPar
One the Bloch vector is measured, we can calculate the angles by \(\theta = \text{arccos}(r_z)\) and \(\phi = \text{arctan2}.(r_y,r_x)\).
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c+c1}{\PYGZsh{} two classical registers}
\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} two quantum registers (qubits)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set the quantum circuit}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set parameters}
\PYG{n}{theta}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{7}
\PYG{n}{phi}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}

\PYG{c+c1}{\PYGZsh{} Generation of the state}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{u}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} separate the preparation part from the phase determination}
\PYG{c+c1}{\PYGZsh{} by placing a barrier}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} x\PYGZhy{}component}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} y\PYGZhy{}component}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{sdg}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} z\PYGZhy{}component}
\PYG{c+c1}{\PYGZsh{} no gate for this}

\PYG{c+c1}{\PYGZsh{} measure the both qubits}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} show the circuit}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌──────────────┐ ░  ┌───┐      ┌─┐
q\PYGZus{}0: ┤ U(π/7,π/3,0) ├─░──┤ H ├──────┤M├───
     ├──────────────┤ ░ ┌┴───┴┐┌───┐└╥┘┌─┐
q\PYGZus{}1: ┤ U(π/7,π/3,0) ├─░─┤ Sdg ├┤ H ├─╫─┤M├
     ├──────────────┤ ░ └─┬─┬─┘└───┘ ║ └╥┘
q\PYGZus{}2: ┤ U(π/7,π/3,0) ├─░───┤M├────────╫──╫─
     └──────────────┘ ░   └╥┘        ║  ║
c: 3/══════════════════════╩═════════╩══╩═
                           2         0  1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{8192}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{result} \PYG{k+kn}{import} \PYG{n}{marginal\PYGZus{}counts}

\PYG{c+c1}{\PYGZsh{} marginal counts of each component}
\PYG{n}{counts\PYGZus{}x} \PYG{o}{=} \PYG{n}{marginal\PYGZus{}counts}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,}\PYG{n}{indices}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{counts\PYGZus{}y} \PYG{o}{=} \PYG{n}{marginal\PYGZus{}counts}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,}\PYG{n}{indices}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{counts\PYGZus{}z} \PYG{o}{=} \PYG{n}{marginal\PYGZus{}counts}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,}\PYG{n}{indices}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get the Bloch vector components}
\PYG{n}{rx}\PYG{o}{=}\PYG{p}{(}\PYG{n}{counts\PYGZus{}x}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{counts\PYGZus{}x}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nshots}
\PYG{n}{ry}\PYG{o}{=}\PYG{p}{(}\PYG{n}{counts\PYGZus{}y}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{counts\PYGZus{}y}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nshots}
\PYG{n}{rz}\PYG{o}{=}\PYG{p}{(}\PYG{n}{counts\PYGZus{}z}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{counts\PYGZus{}z}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nshots}

\PYG{c+c1}{\PYGZsh{} evaluate the phase angle}
\PYG{n}{theta\PYGZus{}qc}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arccos}\PYG{p}{(}\PYG{n}{rz}\PYG{p}{)}
\PYG{n}{phi\PYGZus{}qc}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arctan2}\PYG{p}{(}\PYG{n}{ry}\PYG{p}{,}\PYG{n}{rx}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} print out the results}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{measured   phi = }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{ (exact  = }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{ )}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{phi\PYGZus{}qc}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{measured theta = }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{ (exact  = }\PYG{l+s+si}{\PYGZob{}:6.3f\PYGZcb{}}\PYG{l+s+s2}{ )}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{theta\PYGZus{}qc}\PYG{p}{,}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
measured   phi =  1.079 (exact  =  1.047 )
measured theta =  0.453 (exact  =  0.449 )
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{Composite Systems}

\sphinxstepscope


\chapter{Composite Systems}
\label{\detokenize{composites/intro:composite-systems}}\label{\detokenize{composites/intro:ch-composites}}\label{\detokenize{composites/intro::doc}}
\sphinxAtStartPar
A single qubit is a smallest information carrying unit similar to classical bit.  Despite that a qubit can take infinitely many different states on the surface of a Bloch sphere, it carries the same amount of information as a classical bit since measurement of a qubit produces only two different values like a classical bit.  A practically useful quantum computer needs many qubits. Desktop computers process 64 bits of information inside a CPU and store information in giga bits of memory. At least similar number of qubits are needed for practical quantum computation.  However, the states of multiple qubits are much more complicated that the same number of classical bits. There are a special kind of superposition states known as \sphinxstyleemphasis{quantum entanglement}, which cannot realized in classical bits.  It turns out the entanglement is the most powerful resource for quantum computation.

\sphinxAtStartPar
In this chapter, we study mathematical properties of a composite system consisting of multiple qubits and two\sphinxhyphen{}qubit gates which act on two qubits in such a way that the transformation of one qubit  depends on the other qubit and vice versa.

\sphinxstepscope


\section{Two qubits}
\label{\detokenize{composites/2qubit:two-qubits}}\label{\detokenize{composites/2qubit:sec-2qubits}}\label{\detokenize{composites/2qubit::doc}}

\subsection{Hilbert space and computational basis}
\label{\detokenize{composites/2qubit:hilbert-space-and-computational-basis}}
\sphinxAtStartPar
First, let us recall that a single qubit is in a two\sphinxhyphen{}dimensional Hilbert space \(\mathbb{C}^2\) and the computational basis vectors \(0\rangle\) and \(|1\rangle\) span the space. Now we consider two qubits \(q_0\) and \(q_1\). The composite system lives in a four\sphinxhyphen{}dimensional Hilbert space.  The dimension \(4\) is not \(2+2\) but \(2 \times 2\).  We write it \(\mathbb{C}^2 \otimes \mathbb{C}^2\) where \(\otimes\) indicates \sphinxstyleemphasis{tensor product}.  This mathematical structure is very important. Using the computational basis of each \(\mathbb{C}^2\), we can construct four \sphinxstyleemphasis{computational basis} vectors for the composite system as products \(|q_1\rangle \otimes |q_0\rangle\):
\begin{equation}\label{equation:composites/2qubit:computational-basis-q2}
\begin{split}
|00\rangle \equiv |0\rangle \otimes |0\rangle, \quad |01\rangle \equiv |0\rangle \otimes |1\rangle, \quad |10\rangle \equiv |1\rangle \otimes |0\rangle, \quad |11\rangle \equiv |0\rangle \otimes |0\rangle.
\end{split}
\end{equation}
\sphinxAtStartPar
The physical meaning of each basis vector is clear. For example, \(|01\rangle\) means \(q_0\) is in \(\rangle\) and \(q_1\) in \(|0\rangle\).

\sphinxAtStartPar
Other basis sets are also used.  The \(xx\) basis uses \(|\pm\rangle\) for both qubits
\begin{equation*}
\begin{split}
|++\rangle \equiv |+\rangle \otimes |+\rangle, \quad |+-\rangle \equiv |+\rangle \otimes |-\rangle, \quad |-+\rangle \equiv |-\rangle \otimes |+\rangle, \quad |--\rangle \equiv |-\rangle \otimes |-\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
The mixed basis in which \(q_0\) and \(q_1\) use different basis kets is also allowed.
\begin{equation*}
\begin{split}
|0+\rangle \equiv |0\rangle \otimes |+\rangle, \quad |0-\rangle \equiv |0\rangle \otimes |-\rangle, \quad |1+\rangle \equiv |1\rangle \otimes |+\rangle, \quad |1-\rangle \equiv |1\rangle \otimes |-\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{composites/2qubit:sec-2qubits}]{\ref{\detokenize{composites/2qubit:sec-2qubits}}}.1    Show that the above basis sets are all orthonormal.


\subsection{Superposition states}
\label{\detokenize{composites/2qubit:superposition-states}}
\sphinxAtStartPar
The state of two\sphinxhyphen{}qubit system is expressed as
\begin{equation*}
\begin{split}
c_{00} |00\rangle + c_{01} |01\rangle + c_{10} |10\rangle + c_{11} |11\rangle.
\end{split}
\end{equation*}
\sphinxAtStartPar
What does this state physically means?  To see that, we assume that Alice has qubit \(q_0\) and Bob has \(q_1\).  They are separated by a large distance.  Even when they are far apart, the above state is still valid. Alice can measure her qubit but not Bob’s qubit.  Similarly, Bob can measure his qubit but not Alice’s.  This type of measurement is known as \sphinxstyleemphasis{local measurement}.  Now Alice measures her qubit \(q_0\) before Bob measures \(q_1\).  Suppose that the outcome is \(|0\rangle\).  The state now collapses to
\begin{equation*}
\begin{split}
\frac{1}{N} (c_{00} |00\rangle + c_{10} |10\rangle) = \left(c_0 |0\rangle + c_1|1\rangle\right) \otimes |0\rangle .
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(N = \sqrt{|c_{00}|^2 + |c_{01}|^2}\), \(c_0=c_{00}/N\), and \(c_1=c_{10}/N\).  After the measurement, Alice’s qubit is now in  definite state \(0\rangle\) but Bob’s qubit remains in a superposition state.  Next, Bob measures his qubit and found it in \(|1\rangle\).  Then, the state further collapses to \(|1\rangle \otimes |0\rangle\).

\sphinxAtStartPar
Recall that the outcome of quantum measurement is completely random and there is no way to predict it.  You can calculate the probability to find each state based on the Born rule.  The probability that Alice obtain \(|0\rangle\) is \(p_A(0) = |c_{00}|^2 + |c_{10}|^2\) because Alices qubit is \(|0\rangle\) in \(|00\rangle = |0\rangle \otimes |0\rangle\) and \(|10\rangle = |1\rangle \otimes |0\rangle\). In other words, when Alice obtained \(|0\rangle\), Bob’s qubit can be still \(|0\rangle\) or \(|1\rangle\), hence we need to take into account both.

\sphinxAtStartPar
The probability that Bob gets \(|1\rangle\) after Alice get \(|0\rangle\) is \(p_B(1|0)=|c_1|^2\), which is the \sphinxhref{https://en.wikipedia.org/wiki/Conditional\_probability}{\sphinxstyleemphasis{conditional probability}} after Alice gets \(|0\rangle\). The net probability to find \(|10\rangle\) is
\begin{equation*}
\begin{split}
p_A(0) p_B(1|0) = \left(|c_{00}|^2 + |c_{01}|^2)\right) |c_1|^2 = |c_{10}|^2
\end{split}
\end{equation*}
\sphinxAtStartPar
which is the probability to obtain \(|10\rangle\).  , The Born rule worked well for the composite case.

\sphinxAtStartPar
\sphinxstylestrong{Exercise}  \hyperref[\detokenize{composites/2qubit:sec-2qubits}]{\ref{\detokenize{composites/2qubit:sec-2qubits}}}.1 Suppose that Alice measured her qubit before Bob did and got \(|1\rangle\).  Bob measured his qubit after Alice and obtained \(|1\rangle\).  What is the state after their measurement and what is the probability to get it?

\sphinxAtStartPar
Now an important question arises. If Bob measures before Alice, does the probability remain the same?

\sphinxAtStartPar
Suppose that Bob measured before Alice and got \(|1\rangle\).  The probability that happens is \(p_B(1)=|c_{10}|^2 + |c_{11}|^2\), which is different from the previous case despite that Bob gets the same outcome.   This is weird but let us move on.  After Bob’s measurement the state collapse to
\begin{equation}\label{equation:composites/2qubit:superposition-q2}
\begin{split}
\frac{1}{N} (c_{10} |10\rangle + c_{11} |11\rangle) = |1\rangle \otimes \left(c_0 |0\rangle + c_1|1\rangle\right)
\end{split}
\end{equation}
\sphinxAtStartPar
where \(N = \sqrt{|c_{10}|^2 + |c_{11}|^2}\), \(c_0=c_{10}/N\), and \(c_1=c_{11}/N\).
Next, Alice measured her qubit and obtained \(0\rangle\) with the probability \(p_A(0|1)=|c_0|^2\).  The final state is \(|10\rangle\).  The net probability is
\begin{equation*}
\begin{split}
p_B(1) p_A(0|1) = \left(|c_{10}|^2 + |c_{11}|^2)\right) |c_1|^2 = |c_{10}|^2
\end{split}
\end{equation*}
\sphinxAtStartPar
in agreement with the previous case.  This agreement is guaranteed by the \sphinxhref{https://en.wikipedia.org/wiki/Bayes\%27\_theorem}{\sphinxstyleemphasis{Bayes’ theorem}} \(p_A(x)p_B(y|x) = p_B(y) p_A(x|y)\).

\sphinxAtStartPar
While the net probability does not depend on the order of the measurement, the probabilities of individual observers experience depend on it. Despite that Alice and Bob are separated by a far distance, the act of Alice on her qubit changed the state of Bob’s qubit instantaneously.  This conclusion is quite counter intuitive and needs to be examined more carefully.


\subsection{Product states}
\label{\detokenize{composites/2qubit:product-states}}
\sphinxAtStartPar
Let us consider a special case where the two qubit state is
\begin{equation}\label{equation:composites/2qubit:product10}
\begin{split}
|10\rangle = |1\rangle \otimes |0\rangle
\end{split}
\end{equation}
\sphinxAtStartPar
that is \(c_{00}=c_{01}=c_{11}=0\) and \(c_{10}=1\) in Eq \eqref{equation:composites/2qubit:superposition-q2}.  Alice always finds her qubit in \(|0\rangle\) (probability=1) and Bob always find his in \(|1\rangle\) without exception (probability=1).   In this case, the order of measurement does not affect the individual measurements. There seems no controversy.

\sphinxAtStartPar
Next we consider
\begin{equation}\label{equation:composites/2qubit:product+-}
\begin{split}
|+-\rangle = \frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right ) \otimes \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right ) = \frac{1}{2} \left(|00\rangle - |01\rangle + |10\rangle - |11\rangle \right).
\end{split}
\end{equation}
\sphinxAtStartPar
This state is closer to the general case \eqref{equation:composites/2qubit:superposition-q2}.  However, the probability that Alice gets \(|0\rangle\) is \(\frac{1}{2}\) and the probability Bob gets \(|1\rangle\) is also \(\frac{1}{2}\) regardless of who measures first.

\sphinxAtStartPar
The state of the composite systems in these two examples can be written as \sphinxstyleemphasis{product state} \(|q_1\rangle \otimes |q_0\rangle\).  In Eq. \eqref{equation:composites/2qubit:product10}, \(|q_0\rangle = |0\rangle\) and \(|q_1\rangle = |1\rangle\).  In Eq. \eqref{equation:composites/2qubit:product+-}, \(|q_0\rangle = |-\rangle\) and \(|q_1\rangle = |+\rangle\).  When a composite system is in a product state, the measurements of \(q_0\) and \(q_1\) are completely independent and thus the order does not matter.


\subsection{Entangled states}
\label{\detokenize{composites/2qubit:entangled-states}}
\sphinxAtStartPar
When the state of a composite system cannot be written in a form of product \(|q_1\rangle \otimes |q_0\rangle\), we say that the system is \sphinxstyleemphasis{entangled}.  \sphinxhref{https://en.wikipedia.org/wiki/Quantum\_entanglement}{\sphinxstyleemphasis{Quantum entanglement}} is unique to quantum systems.
When the qubits are entangled, they are not independent. Measurement on one qubit change the state of the other qubit.

\sphinxAtStartPar
A pair of qubits interact at a certain place and an entangle state
\begin{equation}\label{equation:composites/2qubit:01+10}
\begin{split}
\frac{1}{\sqrt{2}} \left(|01\rangle + |10\rangle\right)
\end{split}
\end{equation}
\sphinxAtStartPar
is formed.  Alice takes \(q_0\) and travels to a distant place with it. Bob takes the other qubit and travels in the opposite direction.  Alice and Bob are separated by a large distance.

\sphinxAtStartPar
The entangled state \eqref{equation:composites/2qubit:01+10} indicates that Alice’s qubit is either \(|0\rangle\) or \(|1\rangle\) and so is Bob’s.  When Alice’s measurement results in \(|0\rangle\), then Bob’s qubit necessarily in \(|1\rangle\) since \(|00\rangle\) is absent.  On the other hand, if Alice finds \(|1\rangle\) then Bob’s qubit must be in \(|0\rangle\).   Alice immediately knows what Bob’s will find.  Hence, their measurement is perfectly correlated.

\sphinxAtStartPar
This correlation is not necessarily controversial since classical correlation exits.  Consider a pair of grabs.  Each side of the grab is placed in a separate box.  Alice took a box and Bob the other.  They don’t know which side of the grab is in their of box.  They open the box at their home.  When Alice finds the left grab, the Bob must find the right grab.  This is an example of perfect classical correlation.  When Bob opened the box before Alice, the outcome remain the same.

\sphinxAtStartPar
The quantum correlation by entanglement seems the same as the classical case but it is actually quite different. Before measurement neither spin has a definite state.  Both qubits are mixture of \(|0\rangle\) and \(|1\rangle\).  Alice’s measurement destroys the mixture of Bob’s qubit \sphinxstyleemphasis{instantaneously} over \sphinxstyleemphasis{distance}.  How can Alice’s action on her qubit changes the state of Bob’s qubit instantaneously over an arbitrarily long distance?   This is known as \sphinxhref{https://en.wikipedia.org/wiki/EPR\_paradox}{\sphinxstyleemphasis{EPR paradox}}.  Einstein called it “Spooky action at a distance” and claimed that the theory of quantum mechanics is incomplete.  However, every experimental observation is found to be consistent with the standard theory of quantum mechanics. Nicolas Gisin’s book {[}\hyperlink{cite.references:id20}{2}{]} explains the issue nicely without complicated mathematics. Anyone interested in the quantum correlation, the book is highly recommended.

\sphinxAtStartPar
Once David Mermin explained the common attitude toward the theory of quantum mechanics as “Shut up and calculate”. {[}\hyperlink{cite.references:id19}{3}{]}.   For the moment, we set aside the incomprehensible aspect of quantum entanglement and just accept its extraordinary properties.  It turns out that entanglement carries very useful properties that classical physics cannot offer. We exploit them in quantum computation.  In fact, the success of quantum computation relies on quantum entanglement.


\subsection{Bell basis}
\label{\detokenize{composites/2qubit:bell-basis}}
\sphinxAtStartPar
The Hilbert space of two qubits is four\sphinxhyphen{}dimensional and spanned by four basis vectors.  The computational basis \eqref{equation:composites/2qubit:computational-basis-q2} is based on the product states.  In many cases, basis set based on entangled states is desired.  The most popular entangled basis is \sphinxstyleemphasis{Bell basis} defined by four Bell states:
\begin{equation*}
\begin{split}
\begin{align}
|\Phi^{\pm}\rangle &= \frac{1}{\sqrt{2}} \left(|00\rangle \pm |11\rangle\right) \\
|\Psi^{\pm}\rangle &= \frac{1}{\sqrt{2}} \left(|01\rangle \pm |10\rangle\right)
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
Among them, \(|\Psi^{-}\rangle\), known as \sphinxstyleemphasis{singlet state}, plays a particularly important role in quantum information theory.

\begin{sphinxadmonition}{note}{Qiskit note: Visualizing two\sphinxhyphen{}qubit states}

\sphinxAtStartPar
Visualizing the state of composite systems is challenging.  For small composite systems, \sphinxcode{\sphinxupquote{plot\_state\_qsphere}} draw a sphere and places the computational basis vectors on it as small circles. See the above example.  The size of each circle represents the magnitude of coefficient to the basis such as \(|c_{00}|\). In the above example, \(|01\rangle\) and \(|10\rangle\) are not shown because \(c_{01}=c_{10}=0\). The color of the circle show the phase \(e^{i \theta}\), blue for \(\theta=0\) and yellow for \(\theta=\pi\).
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Exercise}  \hyperref[\detokenize{composites/2qubit:sec-2qubits}]{\ref{\detokenize{composites/2qubit:sec-2qubits}}}.2  Generate \(|\Psi^{\pm}\rangle\) and visualize the results using Qiskit. (HINT: You can filp one of qubits by \sphinxcode{\sphinxupquote{X}} gate.


\subsection{Two\sphinxhyphen{}qubit measurements in computational basis}
\label{\detokenize{composites/2qubit:two-qubit-measurements-in-computational-basis}}
\sphinxAtStartPar
We want to determine \(|c_{ij}|\) in  \eqref{equation:composites/2qubit:superposition-q2} by measurement.  It can be done easily in Qiskit.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} randomly oriented qubits}
\PYG{n}{a}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{b}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{u}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{a}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{b}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{u}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌─────────────────────────┐ ░ ┌─┐
q\PYGZus{}0: ┤ U(1.2759,1.7262,1.9598) ├─░─┤M├───
     ├─────────────────────────┤ ░ └╥┘┌─┐
q\PYGZus{}1: ┤ U(2.418,2.8657,0.40626) ├─░──╫─┤M├
     └─────────────────────────┘ ░  ║ └╥┘
c: 2/═══════════════════════════════╩══╩═
                                    0  1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{8192}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}histogram}
\PYG{n}{plot\PYGZus{}histogram}\PYG{p}{(}\PYG{n}{counts}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2qubit_14_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Entanglement Measure}
\label{\detokenize{composites/2qubit:entanglement-measure}}
\sphinxAtStartPar
How do you know that a given state is entangled or not?  It is not a trivial question and  no simple method is known at present.  However, the the state  is pure (expressed as a state vector),  the presence of bipartite entanglement can be determined by a rather simple method.

\sphinxAtStartPar
Consider a bipartite system of \(\mathcal{H}_A \otimes \mathcal{H}_B\). The system is in a pure state \(|\psi\rangle\).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Write the state in a form of density matrix:  \(\qquad \rho = |\psi\rangle\langle \psi |\).

\item {}
\sphinxAtStartPar
Take partial trace of \(\rho\) over the subspace \(\mathcal{H}_B\).   \(\qquad \rho_A = = \text{Tr}_B \rho\).

\item {}
\sphinxAtStartPar
Evaluate the von Neumann entropy of the reduced density.  \(\qquad S_A = - \text{Tr}_A \left( \rho_A \ln \rho_A\right)\).

\item {}
\sphinxAtStartPar
If \(S_A=0\), then there is no entanglement.  Otherwise, there is entanglement.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{EXample}

\sphinxAtStartPar
Let us try to find if a \(\psi\rangle = \frac{1}{2}\left(|00\rangle + |01\rangle + |10\rangle + |11\rangle \right)\) is entangled or not. WE use matrix representation.

\sphinxAtStartPar
Step 1:
\$\(
\rho = \begin{bmatrix} \frac{1}{4} & \frac{1}{4} & \frac{1}{4} & \frac{1}{4} \\ \frac{1}{4} & \frac{1}{4} & \frac{1}{4} & \frac{1}{4} \\ \frac{1}{4} & \frac{1}{4} & \frac{1}{4} & \frac{1}{4} \\ \frac{1}{4} & \frac{1}{4} & \frac{1}{4} & \frac{1}{4} \end{bmatrix}
\)\$

\sphinxAtStartPar
Step 2:
\$\(
\rho_A = \begin{bmatrix} \frac{1}{2} & \frac{1}{2} \\ \frac{1}{2} & \frac{1}{2} \end{bmatrix}
\)\$

\sphinxAtStartPar
Step 3:To evalue the von Neumann entropy, we need to find the eigenvalues of \(\rho_A\).  They are \(\lambda_1 = 0\) and \(\lambda_2=1\).
\begin{equation*}
\begin{split}
S_A = - \lambda_0 \ln \lambda_0 + \lambda_1 \ln \lambda_1 = - 0 \ln 0 = -1 \ln 1 = 0
\end{split}
\end{equation*}
\sphinxAtStartPar
Remember that \(0 \ln 0 = 0 \times \infty = 0\).

\sphinxAtStartPar
Step 4:  Since \(S_A=0\), there is no entanglement.  In fact, the state can be written as a product \(|\psi\rangle = |+\rangle \otimes |+\rangle\).

\sphinxAtStartPar
Consider another state \(|\phi \rangle = \frac{1}{2}\left(|00\rangle + |01\rangle + |10\rangle + i |11\rangle \right)\) which is quite similar to the previous case but notice “i” on the last term.

\sphinxAtStartPar
Step 1:
\$\(
\rho = \begin{bmatrix} \frac{1}{4} & \frac{1}{4} & \frac{1}{4} & \frac{i}{4} \\ \frac{1}{4} & \frac{1}{4} & \frac{1}{4} & \frac{i}{4} \\ \frac{1}{4} & \frac{1}{4} & \frac{1}{4} & \frac{i}{4} \\ \frac{-i}{4} & \frac{-i}{4} & \frac{-i}{4} & \frac{1}{4} \end{bmatrix}
\)\$

\sphinxAtStartPar
Step 2:
\$\(
\rho_A = \begin{bmatrix} \frac{1}{2} & \frac{1+i}{4} \\ \frac{1-i}{4} & \frac{1}{2} \end{bmatrix}
\)\$

\sphinxAtStartPar
Step 3:\$\(
\lambda_1 = \frac{1}{4}\left(2-\sqrt{2}\right), \quad \lambda_2=\frac{1}{4}\left(2-\sqrt{2}\right)
\)\$
\begin{equation*}
\begin{split}
S_A = - \lambda_0 \ln \lambda_0 + \lambda_1 \ln \lambda_1 \approx 0.416
\end{split}
\end{equation*}
\sphinxAtStartPar
Step 4.
\(S_A > 0\), thus the state is entangled.

\sphinxstepscope


\section{More qubits}
\label{\detokenize{composites/morequbits:more-qubits}}\label{\detokenize{composites/morequbits:sec-more-qubits}}\label{\detokenize{composites/morequbits::doc}}
\sphinxAtStartPar
Two qubits are too few for useful quantum computation and we need many more. In this section, we consider \(n\) qubits where \(n>2\).  Each qubit is in \(\mathbb{C}^2\) and thus  ther system of \(n\) qubits is in \(2^n\) dimensional Hilbert space \(\mathbb{C}^2 \otimes \cdots \otimes \mathbb{C}^2\), which spanned by \(2^n\) basis vectors.


\subsection{Notation}
\label{\detokenize{composites/morequbits:notation}}\label{\detokenize{composites/morequbits:ssec-notations}}
\sphinxAtStartPar
In this book, we write the computational basis of \(n\) qubits as
\begin{equation*}
\begin{split}
|q_{n-1}\, q_{n-2}\, \cdots\, q_1\, q_0\rangle \equiv |q_{n-1}\rangle \otimes |q_{n-2}\rangle \otimes \cdots \otimes |q_1\rangle \otimes |q_0\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Notice that the qubits are ordered from the right to the left.  For example, \(|01011\rangle\) is a computational basis ket for five qubits representing \(|0\rangle \otimes |1\rangle \otimes |0 \rangle \otimes |1\rangle \otimes |1\rangle\).

\sphinxAtStartPar
For large \(n\), the expression becomes very long. We use a shorthand expression or an index based on integers in classical binary strings:
\begin{equation*}
\begin{split}
|j\rangle_n = |j_{n-1}\, j_{n-2}\, \cdots\, j_1\, j_0\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(j_k \in \{0,1\}\) and
\begin{equation*}
\begin{split}
j = 2^{n-1} j_{n-1} + 2^{n-2} j_{n-2} + \cdots + 2 j_1 + j_0 = \sum_{k=0}^{n-1} 2^k j_k.
\end{split}
\end{equation*}
\sphinxAtStartPar
For \(n=3\), we have eight basis vectors
\begin{equation*}
\begin{split}
\begin{align}
&|0\rangle_3 = |000\rangle, && |1\rangle_3 = |001\rangle, &&& |2\rangle_3 = |010\rangle, &&&&|3\rangle_3 = |011\rangle\\
&|4\rangle_3 = |100\rangle, && |5\rangle_3 = |101\rangle, &&& |6\rangle_3 = |110\rangle, &&&&|7\rangle_3 = |111\rangle
\end{align}
\end{split}
\end{equation*}

\bigskip\hrule\bigskip


\sphinxAtStartPar
\sphinxstylestrong{Exercise}  For the system of 5 qubits, find what computational basis set \(|13\rangle_5\) means.


\subsection{Entanglement}
\label{\detokenize{composites/morequbits:entanglement}}
\sphinxAtStartPar
Recall the system is entangled if the state vector of a composite system cannot be written as a product of individual state vectors.  For two qubits, this definition is clear.  For three qubits, what does “product” state mean?  Do all three qubits have to be separated like \(|q_2\rangle \otimes |q_1\rangle \otimes |q_0\rangle\)? If \(q_1\) and \(q_2\) are entangled but not with \(q_0\) the state vector can be written as
\begin{equation*}
\begin{split}
|\text{entangled}\rangle_2 \otimes |q_0\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Is this a product state?  In one sense this is a product state and thus the whole system is not entangled.  However, a part of the whole system is entangled.   When the state vector of a whole system cannot be written as any form of product state, we say that the whole system is entangled.  For example, the state known as the \sphinxhref{https://en.wikipedia.org/wiki/Greenberger\%E2\%80\%93Horne\%E2\%80\%93Zeilinger\_state}{\sphinxstyleemphasis{GHZ} state}:
\begin{equation*}
\begin{split}
|\text{GHZ}\rangle = \frac{1}{\sqrt{2}}\left(|000\rangle + |111\rangle\right)
\end{split}
\end{equation*}
\sphinxAtStartPar
cannot be written as any form of product state.  We say that the state is maximally entangled. To understand the effect of entanglement, qubits \(q_0\), \(q_1\) and \(q_2\) are delivered to Alice, Bob, and Charlie, respectively.  Before any measurement, all of them have a equal chance to get \(|0\rangle\) or \(|1\rangle\).  Alice measures her qubit before others and get \(|1\rangle\).  Immediately, the state collapse to \(|111\rangle\) and she knows that Bob’s and Charlie’s qubits are both in \(|1\rangle\).  Now, they have no chance to get \(|0\rangle\) (but they don’t know it.)  This happens even when they are far apart.  In one sense, this entanglement is strong because measurement of a single qubit removes the uncertainty in two others.  On the other hand, the entanglement is not robust since the measurement of a single qubit destroys the entanglement entirely. The GHZ state is used in various quantum algorithms including \sphinxhref{https://en.wikipedia.org/wiki/Quantum\_Byzantine\_agreement}{Quantum Byzantine agreement}.

\sphinxAtStartPar
There is another maximally entangled state known as the \sphinxhref{https://en.wikipedia.org/wiki/W\_state}{\sphinxstyleemphasis{W} state}
\begin{equation*}
\begin{split}
|\text{W}\rangle = \frac{1}{\sqrt{3}} \left(|001\rangle + |010\rangle + |100\rangle\right).
\end{split}
\end{equation*}
\sphinxAtStartPar
Again, Alice measures her qubit first but gets \(|0\rangle\) this time.  The state collapses to \(\frac{1}{\sqrt{2}}\left(01\rangle + |10\rangle\right) \otimes |0\rangle\).
This entanglement is a little bit more robust than the GHZ state since even after Alice measured, entanglement between Bob and Charie remains.

\sphinxAtStartPar
Finding all maximally entangled states for bigger composite systems is not a trivial task. We will not discuss it here.

\sphinxAtStartPar
\sphinxstylestrong{Quiskit example: creation of GHZ state}

\sphinxAtStartPar
The GHZ state can be created essentially in the same way as the Bell state \(|\Phi^{+}\rangle\).  The following circuit creates it using \sphinxcode{\sphinxupquote{H}} and \sphinxcode{\sphinxupquote{CX}} gates.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐
q\PYGZus{}0: ┤ H ├──■────■──
     └───┘┌─┴─┐  │
q\PYGZus{}1: ─────┤ X ├──┼──
          └───┘┌─┴─┐
q\PYGZus{}2: ──────────┤ X ├
               └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\frac{\sqrt{2}}{2} |000\rangle+\frac{\sqrt{2}}{2} |111\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}state\PYGZus{}qsphere}
\PYG{c+c1}{\PYGZsh{} it\PYGZsq{}s an entangled state.  Use qsphere.}
\PYG{n}{plot\PYGZus{}state\PYGZus{}qsphere}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{,}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{morequbits_8_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Generating W state is a little bit more complicated. The following circuit
creates the W state.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}  \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{n}{theta} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arccos}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{ry}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{ch}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌────────────┐               ┌───┐
q\PYGZus{}0: ┤ Ry(1.9106) ├──■─────────■──┤ X ├
     └────────────┘┌─┴─┐     ┌─┴─┐└───┘
q\PYGZus{}1: ──────────────┤ H ├──■──┤ X ├─────
                   └───┘┌─┴─┐└───┘
q\PYGZus{}2: ───────────────────┤ X ├──────────
                        └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\frac{\sqrt{3}}{3} |001\rangle+\frac{\sqrt{3}}{3} |010\rangle+\frac{\sqrt{3}}{3} |100\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plot\PYGZus{}state\PYGZus{}qsphere}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{,}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{morequbits_12_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Encoding numbers}
\label{\detokenize{composites/numbers:encoding-numbers}}\label{\detokenize{composites/numbers:sec-numbers}}\label{\detokenize{composites/numbers::doc}}
\sphinxAtStartPar
If a quantum computation involves numbers, first we need to encode them.The situation is not much different from classical computing.  First, we have only finite number of qubits, we cannot encode all numbers.  Secondly, strictly speaking continuous numbers cannot be expressed in digital computers.  In this section, we study how to encode integer numbers and real numbers.


\subsection{Integers}
\label{\detokenize{composites/numbers:integers}}
\sphinxAtStartPar
Suppose that we encode integers in \(n\) qubits. We just use the same encoding scheme as classical encoding.   That is to express intgers in binary and map them to bit string. Recall the inter indexing of the computational basis introduced in \hyperref[\detokenize{composites/morequbits:ssec-notations}]{Section \ref{\detokenize{composites/morequbits:ssec-notations}}} which also uses the binary string. Hence, integers from \(0\) to \(2^n-1\) can be expressed by the computational basis
\begin{equation*}
\begin{split}
j \quad \Rightarrow \quad |j\rangle_n
\end{split}
\end{equation*}
\sphinxAtStartPar
For example, \(151 \Rightarrow |151\rangle_8 = |10010111\rangle\).  You can also encode the same number with more qubits. Using \(16\) qubits, \(151 \Rightarrow |151\rangle_{16} = |0000000010010111\rangle\).  The lower half of the binary string matches to the 8\sphinxhyphen{}qubit expression.

\sphinxAtStartPar
The following Qiskit example encode 151 in eight qubits.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create integer 151}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split} |10010111\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Real numbers with floating point arithmetic}
\label{\detokenize{composites/numbers:real-numbers-with-floating-point-arithmetic}}
\sphinxAtStartPar
Real numbers are continuous and thus there are uncountable many numbers even upper and lower bounds are limited.  The situation is same in classical computation.  THerefore, we express real numbers approximately using the \sphinxhref{https://en.wikipedia.org/wiki/Floating-point\_arithmetic}{\sphinxstyleemphasis{floating\sphinxhyphen{}point arithmetic}} method.  Suppose that we write a real number in a scientific notation \sphinxstyleemphasis{mantissa} \(\times\) \sphinxstyleemphasis{scale}, for example in base 10 \(0.3452 \times 10^7\).  We can always make the mantissa less than 1 by adjusting the scaling.  We can also make the mantissa integer as \(3452 \times 10^3\).
Therefore, the scientific notation can be written as integer times scaling.
Now, we use the similar expression in binary.  Consider a binary fractional number \(0.10011 \times 2^{10}\).  The mantissa can be written as
\begin{equation*}
\begin{split}
0.10011 = \frac{1}{2} + \frac{1}{2^4} + \frac{1}{2^5} = \frac{1}{2^5} \left (2^4 \times 1 + 2 \times 1  + 1 \right) =  \frac{1}{2^5} \times 10011
\end{split}
\end{equation*}
\sphinxAtStartPar
Hence, \(0.10011 \times 2^{10} = 10011 \times 2^5\).

\sphinxAtStartPar
In general binary fractional number expressed with \(n\) qubits  is written as
\begin{equation*}
\begin{split}
0.j_{n-1}\,j_{n-2}\,...\,j_1\,j_0 =  \frac{1}{2^n} \left ( 2^{n-1} j_{n-1} + 2^{n-2} j_{n-2} + \cdots + 2 j_1 + j_0 \right)  = \frac{1}{2^n} \sum_{k=0}^{n-1} 2^k j_k
\end{split}
\end{equation*}
\sphinxAtStartPar
which indicate that the mantissa can be written as an integer divided by \(2^n\).
Real numbers smaller than 1 can be approximately encoded with \(n\) qubit as integer devided by \(2^n\).  In practice, \(0<x<1\) is encoded as \(|2^n x\rangle = |j\rangle_n\).  At the end of computation, we can find \(x\) by computing \(j/2^n\) on a classical computer.

\sphinxAtStartPar
Using 3 qubits, we can encode eight real numbers,
\(\frac{0}{8} = 0\), \(\frac{1}{8} = 0.125\), \(\frac{2}{8} = 0.25\), \(\frac{3}{8} = 0.375\),
\(\frac{4}{8} = 0.5\), \(\frac{5}{8}=0.625\), \(\frac{6}{8}=0.75\), \(\frac{7}{8}= 0.875\). The gap between two adjacent values is \(0.125\), too big as approximated real number.  However, for some applications, this is good enough. See for examples, \hyperref[\detokenize{algorithms/qft:sec-qft}]{Section \ref{\detokenize{algorithms/qft:sec-qft}}} and \hyperref[\detokenize{algorithms/qpe:sec-qpe}]{Section \ref{\detokenize{algorithms/qpe:sec-qpe}}}. If \(64\) qubits are available, we can encode \(2^{64} = 18446744073709551616\) different real numbers between 0 and 1.  That means the gap is approximately \(5.42101086 \times 10^{-20}\), which is small enough for most of applications.  Unfortunately, the currently available quantum computer do not have enough qubits to use floating point arithmetic.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create |101\PYGZgt{}}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} find corresponding real number}
\PYG{c+c1}{\PYGZsh{} extract output}
\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{to\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{psi}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.} \PYG{o}{+} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{2.}\PYG{o}{+} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{3.}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|}\PYG{l+s+si}{\PYGZob{}0:s\PYGZcb{}}\PYG{l+s+s2}{\PYGZgt{} corresponds to x=}\PYG{l+s+si}{\PYGZob{}1:5.3f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
|101\PYGZgt{} corresponds to x=0.625
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Real numbers encoded in coefficients}
\label{\detokenize{composites/numbers:real-numbers-encoded-in-coefficients}}
\sphinxAtStartPar
Unlike classical bits, quantum states naturally contains continuous numbers in superposition states.  Consider general qubit state
\begin{equation*}
\begin{split}
|\psi\rangle = \cos\left(\frac{\pi x}{2}\right) |0\rangle + \sin\left(\frac{\pi x}{2}\right) e^{2\pi y} |1\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(0<x<1\) and \(0<y<1\).  We can store two real numbers \(x\) and \(y\) in a single qubit. Their value can be determined by the method discussed in \hyperref[\detokenize{q1gates/tomography:sec-state-tomography}]{Section \ref{\detokenize{q1gates/tomography:sec-state-tomography}}}.  It is relatively easy to encode and decode the data.  However, it is not trivial to use \(x\) and \(y\) in actual calculation.  However, this method works in certain application nicely, especially the real numbers represent angles.

\sphinxAtStartPar
let us calculate \(\cos(A)\cos(B)\cos(C),\, \cos(A)\cos(B)\sin(C),\, \cdots\, \sin(A)\sin(B)\sin(C)\) all at once where \(0<A, B, C<\pi/2\). Using three qubits, we construct a state
\begin{equation*}
\begin{split}
\begin{align}
|\psi\rangle &=\left(\cos(A)|0\rangle + \sin(A)|1\rangle\right) \otimes \left(\cos(B)|0\rangle + \sin(B)|1\rangle\right) \otimes \left(\cos(C)|0\rangle + \sin(C)|1\rangle\right) \\
&= \cos(A)\cos(B)\cos(C)|000\rangle + \cos(A)\cos(B)\sin(C)|001\rangle + \cdots + \sin(A)\sin(B)\sin(C)|111\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
By measuring all qubits, we obtain probabilities \(p_{000}, \cdots, p_{111}\).  Then,
\(\cos(A)\cos(B)\cos(C) = \sqrt{p_{000}}, \cdots \).  Now we calculated all combination of three trig functions simultaneously.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{n}{A}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}
\PYG{n}{B}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}
\PYG{n}{C}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{6}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{ry}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{A}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{ry}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{B}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{ry}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{C}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{8192}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{counts}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{sqrtp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{counts}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{/}\PYG{n}{nshots}\PYG{p}{)}
    \PYG{n}{term}\PYG{o}{=}\PYG{p}{(}\PYG{n}{k}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ cos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ sin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}0:s\PYGZcb{}}\PYG{l+s+s2}{  = }\PYG{l+s+si}{\PYGZob{}1:3.3f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{term}\PYG{p}{,}\PYG{n}{sqrtp}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 cos cos sin  = 0.535
 sin cos sin  = 0.319
 cos sin cos  = 0.302
 sin cos cos  = 0.167
 sin sin cos  = 0.171
 cos cos cos  = 0.306
 sin sin sin  = 0.305
 cos sin sin  = 0.527
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Two\sphinxhyphen{}qubits Gates}
\label{\detokenize{q2gates/intro:two-qubits-gates}}\label{\detokenize{q2gates/intro::doc}}
\sphinxAtStartPar
When two gates \(A\) and \(B\) are applied to qubits \(q_0\) and \(q_1\), respectively, we can write the combined gates as \(C = A \otimes B\). We do not call it 2\sphinxhyphen{}qubit gate. In fact, \(A\) and \(B\) are not necessarily applied to the qubits at the same time.   A 2\sphinxhyphen{}quibit gate  cannot be expressed as a tensor product of two 1\sphinxhyphen{}qubit gates and it must act simultaneously on two qubits.

\sphinxAtStartPar
Commonly used 2\sphinxhyphen{}qubit gates are \sphinxstyleemphasis{controoled} gates, which are actually conditional 1\sphinxhyphen{}qubit gates. A 1\sphinxhyphen{}qubit gate such as \sphinxcode{\sphinxupquote{X}} is applied to \(q_1\) only when \(q_0\) is in \(|1\rangle\).  Otherwise, no action is taken.There are other kind of 2\sphinxhyphen{}qubit gates such as \sphinxcode{\sphinxupquote{Swap}} gate.

\sphinxAtStartPar
Most of common 2\sphinxhyphen{}qubit gates are spectial cases of more general canonical gates.  Many  models used in condensed matter physics are directly expressed by canonical gates, understandin the relation between canonical gates and common 2\sphinxhyphen{}qubit gates are particluarly important.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar
Generaic Name
&\sphinxstyletheadfamily
\sphinxAtStartPar
Qiskit Class Name
&\sphinxstyletheadfamily
\sphinxAtStartPar
Qiskit Ciruit Name
&\sphinxstyletheadfamily
\sphinxAtStartPar
Symbols
\\
\hline
\sphinxAtStartPar
Controlled X
&
\sphinxAtStartPar
CXGate
&
\sphinxAtStartPar
cx  or cnot
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CX}} or \sphinxcode{\sphinxupquote{CNOT}}
\\
\hline
\sphinxAtStartPar
Controlled Y
&
\sphinxAtStartPar
CYGate
&
\sphinxAtStartPar
cy
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CY}}
\\
\hline
\sphinxAtStartPar
Controlled Z
&
\sphinxAtStartPar
CZGate
&
\sphinxAtStartPar
cz
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CZ}}
\\
\hline
\sphinxAtStartPar
Controlled Hadamard
&
\sphinxAtStartPar
CHGate
&
\sphinxAtStartPar
ch
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CH}}
\\
\hline
\sphinxAtStartPar
Controlled SX
&
\sphinxAtStartPar
CSXGate
&
\sphinxAtStartPar
csx
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CSX}}
\\
\hline
\sphinxAtStartPar
Controlled Phase
&
\sphinxAtStartPar
CPhaseGate
&
\sphinxAtStartPar
cp
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CP}}
\\
\hline
\sphinxAtStartPar
Controlled Rotaion X
&
\sphinxAtStartPar
CRXGate
&
\sphinxAtStartPar
crx
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CR}}\(_x\)
\\
\hline
\sphinxAtStartPar
Controlled Rotaion Y
&
\sphinxAtStartPar
CRYGate
&
\sphinxAtStartPar
cry
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CR}}\(_y\)
\\
\hline
\sphinxAtStartPar
Controlled Rotaion Z
&
\sphinxAtStartPar
CRZGate
&
\sphinxAtStartPar
crz
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CR}}\(_z\)
\\
\hline
\sphinxAtStartPar
Controlled Unitary 1
&
\sphinxAtStartPar
CU1Gate
&
\sphinxAtStartPar
cu1
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CU}}\(_1\)
\\
\hline
\sphinxAtStartPar
Controlled Unitary 3
&
\sphinxAtStartPar
CU3Gate
&
\sphinxAtStartPar
cu3
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CU}}\(_3\)
\\
\hline
\sphinxAtStartPar
Controlled Unitary
&
\sphinxAtStartPar
CUGate
&
\sphinxAtStartPar
cu
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CU}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Others}
\begin{itemize}
\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Swap}}

\item {}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{H}}\(_2\)

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Canonical Gates}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Can}}\((t_x,t_y,t_z)=\exp\left[-i\frac{\pi}{2}\left( t_x X\otimes X + t_y Y\otimes Y + t_z \otimes ZZ\right) \right]\)

\sphinxstepscope


\section{CX gate}
\label{\detokenize{q2gates/cx:cx-gate}}\label{\detokenize{q2gates/cx:sec-cxgate}}\label{\detokenize{q2gates/cx::doc}}
\sphinxAtStartPar
CX (Controlled\sphinxhyphen{}X), known also as \sphinxcode{\sphinxupquote{CNOT}}, is one of the most essential gates for quantum computation.


\subsection{Definition}
\label{\detokenize{q2gates/cx:definition}}
\sphinxAtStartPar
\sphinxstylestrong{Operational Definition}

\sphinxAtStartPar
When gate CX\(_{q_0}^{q_1}\) acts on \(|q_1\, q_0\rangle\), X is applied to \(q_1\) if \(q_0=1\) and nothing is done otherwise.%
\begin{footnote}[1]\sphinxAtStartFootnote
The notation \sphinxcode{\sphinxupquote{CX}}\(_{q_0}^{q_1}\) is not commonly used.  In many literature, simply \sphinxcode{\sphinxupquote{CX}} is used without specifying which qubit is source, causing confusion. If you are confused, see the corresponding circuit diagram.
%
\end{footnote} Qubit \(q_0\) serves as source and \(q_1\) as target. Mathematically, it is expressed as
\begin{equation*}
\begin{split}
\text{CX}_{q_0}^{q_1} = \text{I} \otimes |0\rangle\langle 0| + \text{X} \otimes |1\rangle\langle 1|
\end{split}
\end{equation*}
\sphinxAtStartPar
Switching source and target qubits,

\sphinxAtStartPar
CX\(_{q_1}^{q_0}|q_1\, q_0\rangle\) means “Apply X to \(q_0\) if \(q_1=1\) and do nothing otherwise.”  Mathematically, it is expressed as
\begin{equation*}
\begin{split}
\text{CX}_{q_1}^{q_0} = |0\rangle\langle 0| \otimes \text{I}   +   |1\rangle\langle 1| \otimes \text{X}
\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}

\sphinxAtStartPar
CX transforms computational basis as follows:
\begin{equation*}
\begin{split}
\begin{align}
\text{CX}_{q_0}^{q_1} \lvert 00\rangle &= \lvert 00\rangle \\
\text{CX}_{q_0}^{q_1} \lvert 01\rangle &= \lvert 11\rangle \\
\text{CX}_{q_0}^{q_1} \lvert 10\rangle &= \lvert 10\rangle \\
\text{CX}_{q_0}^{q_1} \lvert 11\rangle &= \lvert 01\rangle
\end{align}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\begin{align}
\text{CX}_{q_0}^{q_1} \lvert 00\rangle &= \lvert 00\rangle \\
\text{CX}_{q_1}^{q_0} \lvert 01\rangle &= \lvert 01\rangle \\
\text{CX}_{q_1}^{q_0} \lvert 10\rangle &= \lvert 11\rangle \\
\text{CX}_{q_1}^{q_0} \lvert 11\rangle &= \lvert 10\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Matrix representation}
\begin{equation*}
\begin{split}
\text{CX}_{q_0}^{q_1} = \begin{bmatrix} 1&0&0&0\\0&0&0&1\\0&0&1&0\\0&1&0&0\end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
which is default CX in Qiskit.  In many literature, \sphinxcode{\sphinxupquote{CX}} corresponds to:
\begin{equation*}
\begin{split}
\text{CX}_{q_1}^{q_0} = \begin{bmatrix} 1&0&0&0\\0&1&0&0\\0&0&0&1\\0&0&1&0\end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Don’t get confused. Our notation avoids the confusion.

\sphinxAtStartPar
The Qiskit circuit symbol is \sphinxcode{\sphinxupquote{cx}} and it appears in circuit as:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide_input}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} CX\PYGZus{}\PYGZob{}q0,q1\PYGZcb{}}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} CX\PYGZus{}\PYGZob{}q1,q0\PYGZcb{}}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          ┌───┐
q\PYGZus{}0: ──■──┤ X ├
     ┌─┴─┐└─┬─┘
q\PYGZus{}1: ┤ X ├──■──
     └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\subsection{Acting on superposition state}
\label{\detokenize{q2gates/cx:acting-on-superposition-state}}
\sphinxAtStartPar
CX\(_{q_0}^{q_1}\) swaps the coefficients of \(|01\rangle\) and \(|11\rangle\).
\begin{equation*}
\begin{split}
\text{CX}_{q_0}^{q_1} \left (c_{00} |00\rangle + c_{01} |01\rangle + c_{10} |10\rangle + c_{11} |11\rangle \right ) =
c_{00} |00\rangle + c_{11} |01\rangle + c_{10} |10\rangle + c_{01} |11\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Similarly, CX\(_{q_1}^{q_0}\) swaps the coefficients of \(|10\rangle\) and \(|11\rangle\).
\begin{equation*}
\begin{split}
\text{CX}_{q_1}^{q_0} \left (c_{00} |00\rangle + c_{01} |01\rangle + c_{10} |10\rangle + c_{11} |11\rangle \right ) =
c_{00} |00\rangle + c_{01} |01\rangle + c_{11} |10\rangle + c_{10} |11\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
The following Qiskit example demonstrates it.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐┌───┐
q\PYGZus{}0: ┤ X ├┤ H ├
     ├───┤├───┤
q\PYGZus{}1: ┤ X ├┤ H ├
     └───┘└───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\PYG{c+c1}{\PYGZsh{} state before applying CX}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{State before applying CX.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
State before applying CX.
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{1}{2} |00\rangle- \frac{1}{2} |01\rangle- \frac{1}{2} |10\rangle+\frac{1}{2} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐┌───┐
q\PYGZus{}0: ┤ X ├┤ H ├──■──
     ├───┤├───┤┌─┴─┐
q\PYGZus{}1: ┤ X ├┤ H ├┤ X ├
     └───┘└───┘└───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} state after applyiong CX}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{State after applying CX.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
State after applying CX.
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{1}{2} |00\rangle+\frac{1}{2} |01\rangle- \frac{1}{2} |10\rangle- \frac{1}{2} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Compare the states before and after applying \sphinxcode{\sphinxupquote{CX}} and find how the coefficients changed.

\begin{sphinxadmonition}{note}{Source qubit not necessarily preserved by control gates}

\sphinxAtStartPar
The definition of CX seems indicating that only the state of the target qubit is modified and the state of the source qubit remains the same.  Surprisingly, that is not true.  In some cases, the state of the source qubit also changes.

\sphinxAtStartPar
Let us look at the above example more carefully.  The state before applying CX\(_{q_0}^{q_1}\) is
\begin{equation*}
\begin{split}
\frac{1}{2}\left(|00\rangle - |01\rangle - |10\rangle + |11\rangle\right) =
\frac{1}{\sqrt{2}}\left(|0\rangle - |1\rangle\right) \otimes \frac{1}{\sqrt{2}}\left(|0\rangle - |1\rangle\right) = |-\rangle\otimes |-\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
and after applying \sphinxcode{\sphinxupquote{CX}}\(_{q_0}^{q_1}\) ,
\begin{equation*}
\begin{split}
\frac{1}{2}\left(|00\rangle + |01\rangle - |10\rangle - |11\rangle\right) =
\frac{1}{\sqrt{2}}\left(|0\rangle - |1\rangle\right) \otimes \frac{1}{\sqrt{2}}\left(|0\rangle + |1\rangle\right) = |-\rangle\otimes |+\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Notice that the source qubit is transformed from \(|-\rangle\) to \(|+\rangle\).  This kind of transformation is called \sphinxstyleemphasis{phase kickback} since the phase of the source qubit changed.  The phase kickback is a ubiquitous strategy in quantum algorithms.  See the next subsection.
\end{sphinxadmonition}


\subsection{Phase kickback}
\label{\detokenize{q2gates/cx:phase-kickback}}\label{\detokenize{q2gates/cx:ssec-cx-kickback}}
\sphinxAtStartPar
Let us look at the action of CX on z\sphinxhyphen{}basis \(|\pm\pm\rangle\).  We assume that \(q_0\) is the control qubit and \(q_1\) is the target.
\begin{equation*}
\begin{split}
\begin{align}
\text{CX}_{q_0}^{q_1} |++\rangle &= \frac{1}{2} \text{CX}_{q_0}^{q_1} \left(|00\rangle + |01\rangle  + |10\rangle + |11\rangle \right)
&&=  \frac{1}{2} \left(|00\rangle + |11\rangle  + |10\rangle + |01\rangle \right) &= |++\rangle \\
\text{CX}_{q_0}^{q_1} |+-\rangle &= \frac{1}{2} \text{CX}_{q_0}^{q_1} \left(|00\rangle - |01\rangle  + |10\rangle - |11\rangle \right)
&&=  \frac{1}{2} \left(|00\rangle - |11\rangle  + |10\rangle - |11\rangle \right) &= |+-\rangle \\
\text{CX}_{q_0}^{q_1} |-+\rangle &= \frac{1}{2} \text{CX}_{q_0}^{q_1} \left(|00\rangle + |01\rangle  - |10\rangle - |11\rangle \right)
&&=  \frac{1}{2} \left(|00\rangle + |11\rangle  - |10\rangle - |01\rangle \right) &= |--\rangle \\
\text{CX}_{q_0}^{q_1} |--\rangle &= \frac{1}{2} \text{CX}_{q_0}^{q_1} \left(|00\rangle - |01\rangle  - |10\rangle + |11\rangle \right)
&&=  \frac{1}{2} \left(|00\rangle - |11\rangle  - |10\rangle + |01\rangle \right) &= |-+\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
This transformation can be described as “Apply Z to \(q_0\) if \(q_1=-\) and do nothing otherwise.” Interestingly, now \(q_1\) is the control qubit and \(q_0\) is the target.  The gate has not change and  this operation is still “Apply X to \(q_1\) if \(q_0=1\) and do nothing otherwise.”  The two operations are equivalent. The reversal of control\sphinxhyphen{}target relation is known as signature of \sphinxstyleemphasis{phase kickback}.  Other controlled gates also show phase kickback.

\sphinxAtStartPar
Remembering that the Hadamard gate changes basis set from z\sphinxhyphen{}basis to x\sphinxhyphen{}basis and vice versa. Applying H gate before CX we can realize the phase kickback shown above. After the kickback, we can go back to z\sphinxhyphen{}basis by another H gate. Then, we have reversed CX.

\sphinxAtStartPar
In the following example, we start with an initial state \(|10\rangle\). In the first example, the basis is switched to x\sphinxhyphen{}basis by H gate and apply CX\(_{q_0}^{q_1}\). In the second computation, CX\(_{q_1}^{q_0}\) is directly applied. Both get the same result. Try other initial conditions and confirm that the two circuits do the same transformation.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{qr} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
           ░ ┌───┐     ┌───┐
q\PYGZus{}0: ──────░─┤ H ├──■──┤ H ├
     ┌───┐ ░ ├───┤┌─┴─┐├───┤
q\PYGZus{}1: ┤ X ├─░─┤ H ├┤ X ├┤ H ├
     └───┘ ░ └───┘└───┘└───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}None |01\rangle |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
However, this must be equivalent to

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
           ░ ┌───┐
q\PYGZus{}0: ──────░─┤ X ├
     ┌───┐ ░ └─┬─┘
q\PYGZus{}1: ┤ X ├─░───■──
     └───┘ ░
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Change of basis}
\label{\detokenize{q2gates/cx:change-of-basis}}
\sphinxAtStartPar
Suppose that we want to flip \(q_1\)  if \(q_0\) is \(|-\rangle\) and do nothing otherwise.  We change the basis of \(q_0\) using H gate, apply CX\(_{q_0}^{q_1}\), and apply H again to \(q_0\).  Note that the third step bring \(q_0\) back to the original state.  We can generate superposition of Bell states using the circuit.
\begin{equation*}
\begin{split}
\begin{align}
\text{H}_{q_0} \cdot \text{CX}_{q_0}^{q_1} \cdot \text{H}_{q_0} |00\rangle &= \frac{1}{2}\left(|00\rangle + |01\rangle + |10\rangle - |11\rangle \right) = \frac{1}{\sqrt{2}} \left( \Phi^{-} + \Psi^{+} \right) \\
\text{H}_{q_0} \cdot \text{CX}_{q_0}^{q_1} \cdot \text{H}_{q_0} |01\rangle &= \frac{1}{2}\left(|00\rangle - |01\rangle + |10\rangle + |11\rangle \right) = \frac{1}{\sqrt{2}} \left( \Phi^{+} - \Psi^{-} \right) \\
\text{H}_{q_0} \cdot \text{CX}_{q_0}^{q_1} \cdot \text{H}_{q_0} |10\rangle &= \frac{1}{2}\left(|00\rangle + |01\rangle - |10\rangle + |11\rangle \right) = \frac{1}{\sqrt{2}} \left( \Phi^{+} + \Psi^{-} \right) \\
\text{H}_{q_0} \cdot \text{CX}_{q_0}^{q_1} \cdot \text{H}_{q_0} |11\rangle &= \frac{1}{2}\left(-|00\rangle + |01\rangle + |10\rangle + |11\rangle \right) = \frac{1}{\sqrt{2}} \left( -\Phi^{-} + \Psi^{+} \right)
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
If we want to flip the target qubit also in x\sphinxhyphen{}basis, H gate is applied on \(q_1\) before and after CX. as well.  However, this circuit is identical to just a single CX since it does the same transformation simply in a different basis.

\sphinxAtStartPar
The following example generates \(\frac{1}{\sqrt{2}} \left( \Phi^{-} + \Psi^{+} \right)\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐     ┌───┐
q\PYGZus{}0: ┤ H ├──■──┤ H ├
     └───┘┌─┴─┐└───┘
q\PYGZus{}1: ─────┤ X ├─────
          └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\frac{1}{2} |00\rangle+\frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle- \frac{1}{2} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Simple applications}
\label{\detokenize{q2gates/cx:simple-applications}}
\sphinxAtStartPar
As the above example shows, CX gate is used to create Bell states.  In \hyperref[\detokenize{algorithms/intro:chap-algorithms}]{Section \ref{\detokenize{algorithms/intro:chap-algorithms}}}, many quantum strategies that use CX extensively will be discussed.  Here are a few small applications.


\subsubsection{Generating Bell states}
\label{\detokenize{q2gates/cx:generating-bell-states}}
\sphinxAtStartPar
The
No one\sphinxhyphen{}qubit gate can generate an entangled state.  The CX gate is commonly used to generate entangled states from product states.  As discussed in \hyperref[\detokenize{composites/2qubit:sec-2qubits}]{Section \ref{\detokenize{composites/2qubit:sec-2qubits}}}, Bell states play important roles in quantum computation. We can generate all Bell states by by applying CX\_\{q\_0\}\textasciicircum{}\{q\_1\} \textbackslash{}cdot H\_\{q\_0\}\$ to the computational basis vectors.
\begin{equation}\label{equation:q2gates/cx:cbase-Bell}
\begin{split}
\begin{align}
CX_{q_0}^{q_1} \cdot H_{q_0} |00\rangle &= |\Phi^{+}\rangle \\
CX_{q_0}^{q_1} \cdot H_{q_0} |01\rangle &= |\Phi^{-}\rangle \\
CX_{q_0}^{q_1} \cdot H_{q_0} |10\rangle &= |\Psi^{+}\rangle \\
CX_{q_0}^{q_1} \cdot H_{q_0} |11\rangle &= -|\Psi^{-}\rangle
\end{align}
\end{split}
\end{equation}
\sphinxAtStartPar
The last one has unwanted phase “\sphinxhyphen{}”.  We can get rid of it by applying Z on both qubits.  In the following Qiskit code, we generate the singlet state \(|\Psi^{-}\).

\sphinxAtStartPar
\sphinxstylestrong{Exercise}  \hyperref[\detokenize{q2gates/cx:sec-cxgate}]{\ref{\detokenize{q2gates/cx:sec-cxgate}}}.1  Generate \(|\Psi^{\pm}\rangle\) and visualize the results using Qiskit. (HINT: You can flip one of qubits by X gate.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}

\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} generate |11\PYGZgt{}}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} apply CX*H}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} adjust phase}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{z}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\frac{\sqrt{2}}{2} |01\rangle- \frac{\sqrt{2}}{2} |10\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}state\PYGZus{}qsphere}
\PYG{c+c1}{\PYGZsh{} it\PYGZsq{}s an entangled state.  Use qsphere.}
\PYG{n}{plot\PYGZus{}state\PYGZus{}qsphere}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{,}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{cx_24_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Exercise}  \hyperref[\detokenize{q2gates/cp:sec-cpgate}]{\ref{\detokenize{q2gates/cp:sec-cpgate}}}.1  Generate \(|\Phi^{\pm}\rangle\) and visualize the results using Qiskit.


\subsubsection{Bell state measurement}
\label{\detokenize{q2gates/cx:bell-state-measurement}}
\sphinxAtStartPar
We can expand any two qubit states in the Bell basis as
\begin{equation}\label{equation:q2gates/cx:bell-expansion}
\begin{split}
\ket{\psi} = c_{\Phi^+} |\Phi^{+}\rangle + c_{\Phi^-} |\Phi^{-}\rangle + c_{\Psi^+} |\Psi^{+}\rangle + c_{\Psi^-} |\Phi^{-}\rangle .
\end{split}
\end{equation}
\sphinxAtStartPar
Now, we want find the probabilities to find the Bell states. The process is called \sphinxstyleemphasis{Bell measurement}.  After the measurement, the state collapses to a Bell state depending on the outcome of the measurement.  The Bell measurement is commonly used in quantum information processes, such as \sphinxhref{https://en.wikipedia.org/wiki/Quantum\_teleportation}{\sphinxstyleemphasis{quantum teleportation}}.  However, the Bell measurement is not trivial.  Any local measurement fails and thus the standard measurement based on the computational basis does not help.

\sphinxAtStartPar
In the example above, we transformed the computational basis vectors to the Bell states using CX\(_{q_0}^{q_1} \cdot\) H\(_{q_0}\).  By inverting the transformation, we can convert the Bell states to the computational basis.  That is applying H\(_{q_0} \cdot\) CX\(_{q_0}^{q_1}\) to the Bell states
\begin{equation*}
\begin{split}
\begin{align}
\text{H}_{q_0} \cdot \text{CX}_{q_0}^{q_1} |\Phi^{+}\rangle &= |00\rangle \\
\text{H}_{q_0} \cdot \text{CX}_{q_0}^{q_1} |\Phi^{-}\rangle &= |01\rangle \\
\text{H}_{q_0} \cdot \text{CX}_{q_0}^{q_1} |\Psi^{+}\rangle &= |10\rangle \\
\text{H}_{q_0} \cdot \text{CX}_{q_0}^{q_1} |\Phi^{-}\rangle &= -|11\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
Applying \((H \otimes I)\cdot CX\) to the superposition \eqref{equation:q2gates/cx:bell-expansion}, we obtain
\begin{equation}\label{equation:q2gates/cx:comp-expansion}
\begin{split}
(H \otimes I)\cdot CX \ket{\psi} = c_{\Phi^+} |00\rangle + c_{\Phi^-} |10\rangle + c_{\Psi^+} |01\rangle - c_{\Psi^-} |11\rangle .
\end{split}
\end{equation}
\sphinxAtStartPar
The resulting state is a superposition in computational basis but the expansion coefficients are the same as before the transformation.
Now, the standard measurement in the computational basis determine the probabilities of finding the corresponding Bell state.  The actual measurement collapses the state to one of computational basis vectors but the Bell measurement should result in one of the Bell state.
The computational basis vector obtained from the measurement can be transformed back to the corresponding Bell state.


\subsubsection{Addition modulo 2}
\label{\detokenize{q2gates/cx:addition-modulo-2}}
\sphinxAtStartPar
We want to compute modulo\sphinxhyphen{}2 addition of two bits \(x\) and \(y\). We write it \(x \otimes y\).  Its truth table is


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar
\(x\)
&\sphinxstyletheadfamily
\sphinxAtStartPar
\(y\)
&\sphinxstyletheadfamily
\sphinxAtStartPar
\(x\oplus y\)
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
In classical computer, XOR gate calculate it. Unlike classical XOR, quantum computation must be reversible.  Thus we need to retain the values of \(x\) and \(y\). The out needs one qubit.  In total, we need three qubits
\(|z\,y\,x\rangle = |z\rangle \otimes |y\rangle \otimes |x\rangle\) where \(z\) contains \(x \oplus y\) at the end.  We assume that \(z=0\) initially.  We want to construct a quantum circuit which transforms \(|0\,y,x\rangle\) to \(|(x \oplus y)\, y\, x\rangle\).  Writing it explicitly.
\begin{equation*}
\begin{split}
\begin{align}
|000\rangle \quad &\Rightarrow \quad |000\rangle \\
|001\rangle \quad &\Rightarrow \quad |101\rangle \\
|010\rangle \quad &\Rightarrow \quad |110\rangle \\
|011\rangle \quad &\Rightarrow \quad |011\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
The second transformation can be done by CX\(_{q_0}^{q_1}\) and the third transformation can be done by a CX\(_{q_1}^{q_2}\). These two gates also works for the first transformation.  However, it does not work for the last transformation.  It takes more than one step.  It would be nice if \(z\) is directly correlated to \(y\) or \(x\). Let us try CX\(_{q_0}^{q_1}\).
\begin{equation*}
\begin{split}
\begin{align}
\text{CX}_{q_0}^{q_1}|000\rangle = |000\rangle \\
\text{CX}_{q_0}^{q_1}|001\rangle = |011\rangle \\
\text{CX}_{q_0}^{q_1}|010\rangle = |010\rangle \\
\text{CX}_{q_0}^{q_1}|011\rangle = |001\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
Now , the output \(z\) and \(y\) are perfectly correlated.  We can now apply CX\(_{q_1}^{q_2}\) to find \(z\).
\begin{equation*}
\begin{split}
\begin{align}
\text{CX}_{q_1}^{q_2}\text{CX}_{q_0}^{q_1}|000\rangle = \text{CX}_{q_1}^{q_2}|000\rangle = |000\rangle  \\
\text{CX}_{q_1}^{q_2}\text{CX}_{q_0}^{q_1}|001\rangle = \text{CX}_{q_1}^{q_2}|011\rangle = |111\rangle \\
\text{CX}_{q_1}^{q_2}\text{CX}_{q_0}^{q_1}|010\rangle = \text{CX}_{q_1}^{q_2}|010\rangle = |110\rangle \\
\text{CX}_{q_1}^{q_2}\text{CX}_{q_0}^{q_1}|011\rangle = \text{CX}_{q_1}^{q_2}|001\rangle = |001\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
The value of \(z\) is correct but \(x\) and \(y\) are not preserved.  That is not good. Next,we try to recover them by
X\(_{q_0}^{q_1}\).
\begin{equation*}
\begin{split}
\begin{align}
\text{CX}_{q_0}^{q_1} \text{CX}_{q_1}^{q_2}\text{CX}_{q_0}^{q_1}|000\rangle = \text{CX}_{q_0}^{q_1}|000\rangle = |000\rangle  \\
\text{CX}_{q_0}^{q_1} \text{CX}_{q_1}^{q_2}\text{CX}_{q_0}^{q_1}|001\rangle = \text{CX}_{q_0}^{q_1}|111\rangle = |101\rangle \\
\text{CX}_{q_0}^{q_1} \text{CX}_{q_1}^{q_2}\text{CX}_{q_0}^{q_1}|010\rangle = \text{CX}_{q_0}^{q_1}|110\rangle = |110\rangle \\
\text{CX}_{q_0}^{q_1} \text{CX}_{q_1}^{q_2}\text{CX}_{q_0}^{q_1}|011\rangle = \text{CX}_{q_0}^{q_1}|001\rangle =|011\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
Now we have the desired output.  Three CX gates calculate \(x \oplus y\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}


\PYG{c+c1}{\PYGZsh{} loop over all inputs}
\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} generate input state}
        \PYG{k}{if} \PYG{n}{x}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{y}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} compute x \PYGZbs{}oplus y}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} extract output}
        \PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{to\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{psi}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{psi}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x=}\PYG{l+s+si}{\PYGZob{}0:d\PYGZcb{}}\PYG{l+s+s2}{, y=}\PYG{l+s+si}{\PYGZob{}1:d\PYGZcb{}}\PYG{l+s+s2}{, x+y=}\PYG{l+s+si}{\PYGZob{}2:s\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{psi}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x=0, y=0, x+y=0
x=0, y=1, x+y=1
x=1, y=0, x+y=1
x=1, y=1, x+y=0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Swapping qubits}
\label{\detokenize{q2gates/cx:swapping-qubits}}
\sphinxAtStartPar
Swap gate SWAP is defined by SWAP\(|q_1\, q_0\rangle = |q_0\, q_1\rangle\).  When it acts on a superposition state, the coefficients of \(|01\rangle\) and \(|10\rangle\) is swapped.
\begin{equation*}
\begin{split}
\text{SWAP} \left (c_{00} |00\rangle + c_{01} |01\rangle + c_{10} |10\rangle + c_{11} |11\rangle \right ) =
c_{00} |00\rangle + c_{10} |01\rangle + c_{01} |10\rangle + c_{11} |11\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Recall that CX\(_{q_0}^{q_1}\) swaps the coefficients of \(|01\rangle\) and \(|11\rangle\), and  CX\(_{q_1}^{q_0}\) swaps the coefficients of \(|10\rangle\) and \(|11\rangle\).  Using these gates in series, we can create SWAP.
\begin{equation*}
\begin{split}
\begin{align}
&\text{CX}_{q_0}^{q_1} \cdot \text{CX}_{q_1}^{q_0} \cdot \text{CX}_{q_0}^{q_1} \left(c_{00} |00\rangle + c_{01} |01\rangle + c_{10} |10\rangle + c_{11} |11\rangle \right)\\
= &\text{CX}_{q_0}^{q_1} \cdot \text{CX}_{q_1}^{q_0} \left(c_{00} |00\rangle + c_{11} |01\rangle + c_{10} |10\rangle + c_{01} |11\rangle \right) \\
= &\text{CX}_{q_0}^{q_1}  \left(c_{00} |00\rangle + c_{11} |01\rangle + c_{01} |10\rangle + c_{10} |11\rangle \right)\\
= & c_{00} |00\rangle + c_{10} |01\rangle + c_{01} |10\rangle + c_{11} |11\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
which indicates SWAP=\(\text{CX}_{q_0}^{q_1} \cdot  \text{CX}_{q_1}^{q_0} \cdot \text{CX}_{q_0}^{q_1}\). (See the following circuit.)

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide_input}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sawpping qubits}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sawpping qubits
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          ┌───┐
q\PYGZus{}0: ──■──┤ X ├──■──
     ┌─┴─┐└─┬─┘┌─┴─┐
q\PYGZus{}1: ┤ X ├──■──┤ X ├
     └───┘     └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} randomly oriented qubits}
\PYG{n}{a}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{b}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{u}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{a}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{b}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{c}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{u}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get the statevector in dict format}
\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{to\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} evaluate of probabilities}
\PYG{n}{p0} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{psi}\PYG{p}{:}
    \PYG{n}{p0}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}histogram}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{probability distribution before swap}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plot\PYGZus{}histogram}\PYG{p}{(}\PYG{n}{p0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
probability distribution before swap
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{cx_32_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{to\PYGZus{}dict}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{p1} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{psi}\PYG{p}{:}
    \PYG{n}{p1}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{probability distribution after swapping.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plot\PYGZus{}histogram}\PYG{p}{(}\PYG{n}{p1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
probability distribution after swapping.
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{cx_33_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
Last Modified on 08/19/2022.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Controlled\sphinxhyphen{} Z, S, T, P gates}
\label{\detokenize{q2gates/cp:controlled-z-s-t-p-gates}}\label{\detokenize{q2gates/cp:sec-cpgate}}\label{\detokenize{q2gates/cp::doc}}
\sphinxAtStartPar
Recall that that Z, S, and T gates all change the phase of \(|1\rangle\) and that the general phase gate P(\(\theta\)) can replace them as Z = P(\(\pi\)), S = P(\(\pi/2\)), and T = P(\(\pi/4\))  (See \hyperref[\detokenize{q1gates/intro:chap-one-qubit-gates}]{Section \ref{\detokenize{q1gates/intro:chap-one-qubit-gates}}}.)  In this section, controlled\sphinxhyphen{} Z, S, T, and P gates (CZ, CS, CT, and CP, respectively) are introduced.  Since all of them work in the similar manner, only controlled\sphinxhyphen{}P is explained in most parts.

\sphinxAtStartPar
\sphinxstylestrong{Operational Definition}

\sphinxAtStartPar
When gate  CP\(_{q_0}^{q_1}(\theta)\) acts on \(|q_1\, q_0\rangle\), P(\(\theta\)) is applied to \(q_1\) if \(q_0=1\) and nothing is done otherwise. Qubit \(q_0\) serves as source and \(q_1\) as target.  AS shwon bellow, CP\(_{q_0}^{q_1}(\theta) =\) CP\(_{q_1}^{q_0}(\theta)\).  Hence, it is not necessary to specify a source and a target qubit.

\sphinxAtStartPar
Mathematically, it is expressed as
\begin{equation*}
\begin{split}
\text{CP}_{q_0}^{q_1}(\theta)|q_1\, q_0\rangle = \text{I} \otimes |0\rangle\langle 0| + \text{P}(\theta) \otimes |1\rangle\langle 1|
\end{split}
\end{equation*}
\sphinxAtStartPar
Switching source and target qubits,

\sphinxAtStartPar
CP\(_{q_1}^{q_0} (\theta) |q_1\, q_0\rangle\)  applies P(\(\theta\)) to \(q_0\) if \(q_1=1\) and do nothing otherwise.  Mathematically, it is expressed as
\begin{equation*}
\begin{split}
\text{CP}_{q_1}^{q_0}|q_1\, q_0\rangle (\theta) = |0\rangle\langle 0| \otimes \text{I}   +   |1\rangle\langle 1| \otimes \text{P}(\theta)
\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Transformation}

\sphinxAtStartPar
CP\(_{q_0}^{q_1}(\theta)\) and CP\(_{q_1}^{q_0}(\theta)\) transforms computational basis as follows:
\begin{equation*}
\begin{split}
\begin{align}
&\text{CP}_{q_0}^{q_1}(\theta) \lvert 00\rangle = \lvert 00\rangle\\
&\text{CP}_{q_0}^{q_1}(\theta) \lvert 01\rangle = \lvert 01\rangle\\
&\text{CP}_{q_0}^{q_1}(\theta) \lvert 10\rangle = \lvert 00\rangle\\
&\text{CP}_{q_0}^{q_1}(\theta) \lvert 11\rangle = e^{i \theta}\lvert 11\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
Since only \(\lvert 11\rangle\) is affected, \(\text{CP}_{q_0}^{q_1}(\theta)= \text{CP}_{q_1}^{q_0}(\theta)\).

\sphinxAtStartPar
\sphinxstylestrong{Matrix representation}
\begin{equation*}
\begin{split}
\text{CP}_{q_0}^{q_1}(\theta) = \text{CP}_{q_0}^{q_1}(\theta)  = \begin{bmatrix} 1&0&0&0\\0&1&0&0\\0&0&1&0\\0&0&0&e^{i\theta}\end{bmatrix}
\end{split}
\end{equation*}

\subsection{Qiskit circuit functions}
\label{\detokenize{q2gates/cp:qiskit-circuit-functions}}
\sphinxAtStartPar
The Qiskit circuit functions for CZ and CP are \sphinxcode{\sphinxupquote{cz}} and \sphinxcode{\sphinxupquote{cp}}, respectively and it appears in a circuit as follows.  Unlike CX gate, the source and target are not distinguished.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

q0\PYGZus{}0: ─■──■─────
       │  │P(θ)
q0\PYGZus{}1: ─■──■─────

\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Qiskit does not have standard circuit functions for CS and CT but they are predefined in \sphinxcode{\sphinxupquote{qiskit.circuit.library.standard\_gates}}.  You just have to create a shorthand expression from the library and use \sphinxcode{\sphinxupquote{append}} function to add the gate to the circuit. We can always use CP(\(\pi/2\)) and CP(\(\pi/4\)) for CS and CT, respectively.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{circuit}\PYG{n+nn}{.}\PYG{n+nn}{library}\PYG{n+nn}{.}\PYG{n+nn}{standard\PYGZus{}gates} \PYG{k+kn}{import} \PYG{n}{SGate}\PYG{p}{,} \PYG{n}{TGate}

\PYG{n}{cs} \PYG{o}{=} \PYG{n}{SGate}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{control}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} the parameter is the amount of control points you want}
\PYG{n}{ct} \PYG{o}{=} \PYG{n}{TGate}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{control}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cs}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{ct}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

q\PYGZus{}0: ──■────■──
     ┌─┴─┐┌─┴─┐
q\PYGZus{}1: ┤ S ├┤ T ├
     └───┘└───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Acting on superposition state}
\label{\detokenize{q2gates/cp:acting-on-superposition-state}}
\sphinxAtStartPar
CP\(_{q_0}^{q_1}(\theta)\) multiplies phase factor \(e^{i\theta}\) only to \(|11\rangle\).  Other basis vectors are not affected.  Note also that the modulus of the coefficients remain the same and thus probabilities of finding the computational basis vectors are not modified by CP.
\begin{equation*}
\begin{split}
\text{CP}_{q_0}^{q_1} (\theta) \left (c_{00} |00\rangle + c_{01} |01\rangle + c_{10} |10\rangle + c_{11} |11\rangle \right ) =
c_{00} |00\rangle + c_{11} |01\rangle + c_{10} |10\rangle + e^{i \theta} c_{01} |11\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
How can we change the phase of a basis vector other than \(11\tangle\)?  A possible strategy is to transform the target basis vector to \(|11\rangle\), apply CP and transform back to the original basis vector.  For example, if we want to multiply \(i\) to \(|00\rangle\) without changing other basis vector, apply \((\text{X} \otime \text{X}) \cdot \text{CS} \cdot (\text{X} \otimes \text{X})\)

\sphinxAtStartPar
\sphinxstylestrong{Example}How can we change the phase of a basis vector other than \(|11\rangle\)?  A possible strategy is to transform the target basis vector to \(|11\rangle\), apply CP and transform back to the original basis vector.  For example, if we want to multiply \(i\) to \(|00\rangle\) without changing other basis vector, apply \((\text{X} \otimes \text{X}) \cdot \text{CS} \cdot (\text{X} \otimes \text{X})\).  In this example, we start with a product state \(|+\rangle \otimes |+\rangle\).  Then, the above gate is applied to it.  Check that \(i\) is multiplied only to  \(|00\rangle\).  The final state is entangled. (See \hyperref[\detokenize{composites/2qubit:sec-2qubits}]{Section \ref{\detokenize{composites/2qubit:sec-2qubits}}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} prepare a super position state}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{initial state}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
initial state
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{1}{2} |00\rangle+\frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle+\frac{1}{2} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐ ░ ┌───┐         ┌───┐
q\PYGZus{}0: ┤ H ├─░─┤ X ├─■───────┤ X ├
     ├───┤ ░ ├───┤ │P(π/2) ├───┤
q\PYGZus{}1: ┤ H ├─░─┤ X ├─■───────┤ X ├
     └───┘ ░ └───┘         └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{final state}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
final state
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{i}{2} |00\rangle+\frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle+\frac{1}{2} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Exercise}

\sphinxAtStartPar
Construct a circuit that transforms \(\frac{1}{2}\left(|00\rangle + |01\rangle + |10\rangle + |11\rangle\right)\) to \(\frac{1}{2}\left(|00\rangle + |01\rangle - |10\rangle + |11\rangle\right)\).

\sphinxstepscope


\section{SWAP}
\label{\detokenize{q2gates/swap:swap}}\label{\detokenize{q2gates/swap::doc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar
input
&
\sphinxAtStartPar

&\sphinxstyletheadfamily
\sphinxAtStartPar
output
\\
\hline
\sphinxAtStartPar
\(\lvert 00\rangle\)
&
\sphinxAtStartPar
\(\Rightarrow\)
&
\sphinxAtStartPar
\(\lvert 00\rangle\)
\\
\hline
\sphinxAtStartPar
\(\lvert 01\rangle\)
&
\sphinxAtStartPar
\(\Rightarrow\)
&
\sphinxAtStartPar
\(\lvert 10\rangle\)
\\
\hline
\sphinxAtStartPar
\(\lvert 10\rangle\)
&
\sphinxAtStartPar
\(\Rightarrow\)
&
\sphinxAtStartPar
\(\lvert 01\rangle\)
\\
\hline
\sphinxAtStartPar
\(\lvert 11\rangle\)
&
\sphinxAtStartPar
\(\Rightarrow\)
&
\sphinxAtStartPar
\(\lvert 11\rangle\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
SWAP gate can be a native gate for certain types of quantum computer through exchange interaction.  Here we show a circuit equivalent to \sphinxcode{\sphinxupquote{SWAP}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}\PYG{p}{,} \PYG{n}{QuantumRegister}\PYG{p}{,} \PYG{n}{ClassicalRegister}\PYG{p}{,} \PYG{n}{Aer}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{statevector\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Using the built\sphinxhyphen{}in SWAP gate:  |01⟩⇒|10⟩

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qr}  \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      ┌───┐ ░    ┌─┐
q0\PYGZus{}0: ┤ X ├─░──X─┤M├───
      └───┘ ░  │ └╥┘┌─┐
q0\PYGZus{}1: ──────░──X──╫─┤M├
            ░     ║ └╥┘
c0: 2/════════════╩══╩═
                  0  1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result}\PYG{o}{=}\PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}statevector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split} |10\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{itemize}
\item {}
\sphinxAtStartPar
Equivalent circuit to \sphinxcode{\sphinxupquote{SWAP}} using \sphinxcode{\sphinxupquote{CX}}

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qr} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cnot}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cnot}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cnot}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
                ┌───┐
q1\PYGZus{}0: ───────■──┤ X ├──■──
      ┌───┐┌─┴─┐└─┬─┘┌─┴─┐
q1\PYGZus{}1: ┤ X ├┤ X ├──■──┤ X ├
      └───┘└───┘     └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result}\PYG{o}{=}\PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}statevector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split} |01\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Symmetric property: Swapping qubits themselves (not their states) should give the same results.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qr} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cnot}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cnot}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cnot}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      ┌───┐ ░ ┌───┐     ┌───┐
q2\PYGZus{}0: ┤ X ├─░─┤ X ├──■──┤ X ├
      ├───┤ ░ └─┬─┘┌─┴─┐└─┬─┘
q2\PYGZus{}1: ┤ X ├─░───■──┤ X ├──■──
      └───┘ ░      └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result}\PYG{o}{=}\PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}statevector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There is no particular reason to use X direction.  \sphinxcode{\sphinxupquote{CY}} should be able to realize \sphinxcode{\sphinxupquote{SWAP}} as well.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qr} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cy}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cy}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cy}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      ┌───┐ ░ ┌───┐     ┌───┐
q3\PYGZus{}0: ┤ X ├─░─┤ Y ├──■──┤ Y ├
      └───┘ ░ └─┬─┘┌─┴─┐└─┬─┘
q3\PYGZus{}1: ──────░───■──┤ Y ├──■──
            ░      └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result}\PYG{o}{=}\PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}statevector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split} |10\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{Algorithms}

\sphinxstepscope


\chapter{Algorithms}
\label{\detokenize{algorithms/intro:algorithms}}\label{\detokenize{algorithms/intro:chap-algorithms}}\label{\detokenize{algorithms/intro::doc}}
\sphinxAtStartPar
TBW

\sphinxstepscope


\section{Quantum Teleportation}
\label{\detokenize{algorithms/teleportation:quantum-teleportation}}\label{\detokenize{algorithms/teleportation:sec-teleportation}}\label{\detokenize{algorithms/teleportation::doc}}
\sphinxAtStartPar
Suppose that Alice has a qubit in an arbitrary state \(|\psi\rangle\) carrying some information.  She wants to send the information to Bob. In other words, Bob needs to obtain a qubit in the same state \(|\psi\rangle\).  The simple solution is to deliver the Alice’s qubit to Bob.  Let us assume that the Alice’s qubit is not mobile and must stay with her.  What can they do?  First of all, Bob needs a qubit.  It can be any state but let us assume it us in a “reset state” \(|0\rangle\).  Further, we assume that the two qubits are initially not entangled. This assumption allows Bob to bring a qubit from anywhere he likes.  We apply some unitary operation (gates) to the both qubits so that the state of Bob’s qubit  is transformed to \(|\psi\rangle\).  Copying the state from Alice to Bob is not possible due to the no\sphinxhyphen{}cloning theorem.  Applying local unitary operation (one\sphinxhyphen{}qubit gates) to each qubit does not transmit any information and thus the Bob’s qubit is independent of the Alice’s. We need non\sphinxhyphen{}local operation (two\sphinxhyphen{}qubit gates).   We know such a non\sphinxhyphen{}local operation.  The SWAP operation makes the Bob’s qubit \(|\psi\rangle\) and Alice loses the information entirely.  Unfortunately, the SWAP operation works only when the two qubits are close to each other, hence one of them must travel to the other.

\sphinxAtStartPar
Is there a way to create a desired state over a distance by communication?  Classical communication such as telephone call won’t help due to the no\sphinxhyphen{}teleportation theorem. We must use a quantum communication.  That means we need a messenger qubit that can be sent from one cite to another, such as a photon. It turns out that quantum communication along with classical communication \sphinxstyleemphasis{teleport} the state \(|\psi\rangle\) from Alice to Bob over a large distance.  We use three qubits, \(q_A\) for Alice, \(q_B\) for Bob, and \(q_M\) messenger (often called \sphinxstyleemphasis{ancila} qubit).  The protocol is called \sphinxhref{https://en.wikipedia.org/wiki/Quantum\_teleportation}{\sphinxstyleemphasis{quantum teleportation}}.


\subsection{The protocol}
\label{\detokenize{algorithms/teleportation:the-protocol}}
\sphinxAtStartPar
Consider a Hilbert space of three qubits \(\mathcal{H}_A \otimes \mathcal{H}_M \otimes \mathcal{H}_B\).  \(q_A\) is in a arbitrary state
\(\alpha |0\rangle + \beta |1\rangle\), and  \(q_B\) and \(q_M\) are both in \(|0\rangle\).  Thus the initial state is
\begin{equation*}
\begin{split}
|\psi_0\rangle = \left( \alpha |0\rangle + \beta |1\rangle\right) \otimes |00\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
We want find a protocol that makes \(q_B\) becomes \(\left( \alpha |0\rangle + \beta |1\rangle\right)\) at the end.  We don’t care the final state of \(q_A\) and \(q_M\).

\sphinxAtStartPar
\sphinxstylestrong{Step 1}

\sphinxAtStartPar
Assume that \(q_M\) is near by \(q_B\).  Bob applies H and CX on \(q_M\) and \(q_B\) so that they becomes Bell state \(|\Phi^{+}\).(See \eqref{equation:q2gates/cx:cbase-Bell}.)
\begin{equation*}
\begin{split}
|\psi_0\rangle = \left( \alpha |0\rangle + \beta |1\rangle\right) \otimes |00\rangle \quad \Rightarrow \quad  |\psi_1\rangle =\left( \alpha |0\rangle + \beta |1\rangle\right) \otimes |\Phi^{+}\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Step 2}

\sphinxAtStartPar
Now the messenger qubit travels to Alice. In order to distinguish \(\alpha\) and \(\beta\), Alice applies CX\(_{q_A}^{q_M}\).
\$\(
|\psi_1\rangle =\left( \alpha |0\rangle + \beta |1\rangle\right) \otimes |\Phi^{+}\rangle \quad \Rightarrow \quad  |\psi_2\rangle = \alpha |0\rangle \otimes |\Phi^{+}\rangle + \beta |1\rangle \otimes |\Psi^{+}\rangle
\)\$

\sphinxAtStartPar
Note that \(q_M\) and \(q_B\) are separated by a distance, entanglement in the Bell states survives.

\sphinxAtStartPar
\sphinxstylestrong{Step 3}

\sphinxAtStartPar
Alice applies H on \(q_A\) to change the basis of \(q_A\) from the \(z\)\sphinxhyphen{}basis to \(x\)\sphinxhyphen{}basis.
\begin{equation*}
\begin{split}
|\psi_2\rangle = \alpha |0\rangle \otimes |\Phi^{+}\rangle + \beta |1\rangle \otimes |\Psi^{+}\rangle  \quad \Rightarrow \quad |\psi_3\rangle = \alpha |+\rangle \otimes |\Phi^{+}\rangle + \beta |-\rangle \otimes |\Psi^{+}\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Now, we rewrite \(|\psi_3\rangle\) from the Alice’s view
\begin{equation*}
\begin{split}
|\psi_3\rangle = \frac{1}{2}\left[|00\rangle\otimes \left(\alpha|0\rangle + \beta |1\rangle\right) + |01\rangle\otimes \left(\alpha|1\rangle + \beta |0\rangle\right) + |10\rangle\otimes \left(\alpha|0\rangle - \beta |1\rangle\right) + |11\rangle\otimes \left(\alpha|1\rangle + \beta |0\rangle\right) \right]
\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Step 4}

\sphinxAtStartPar
Alice measures \(q_A\) and \(q_M\) in the computational basis.  There are four possible outcomes, \(|00\rangle\), \(|01\rangle\), \(|10\rangle\), and \(|11\rangle\) with the equal probability \(\frac{1}{4}\).  The state vector collapses accordingly.   The outcomes of the measurement are listed in \hyperref[\detokenize{algorithms/teleportation:table-teleport}]{Table \ref{\detokenize{algorithms/teleportation:table-teleport}}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{The outcome of measurement}\label{\detokenize{algorithms/teleportation:table-teleport}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily
\sphinxAtStartPar
Alice’s outcome
&\sphinxstyletheadfamily
\sphinxAtStartPar
Bob’s state
&\sphinxstyletheadfamily
\sphinxAtStartPar
Classical message
\\
\hline
\sphinxAtStartPar
\(\lvert 00\rangle\)
&
\sphinxAtStartPar
\(\alpha \lvert 0\rangle + \beta \lvert 1\rangle\)
&
\sphinxAtStartPar
Do nothing.
\\
\hline
\sphinxAtStartPar
\(\lvert 01\rangle\)
&
\sphinxAtStartPar
\(\alpha \lvert 1\rangle + \beta \lvert 0\rangle\)
&
\sphinxAtStartPar
Apply X.
\\
\hline
\sphinxAtStartPar
\(\lvert 10\rangle\)
&
\sphinxAtStartPar
\(\alpha \lvert 0\rangle - \beta \lvert 1\rangle\)
&
\sphinxAtStartPar
Apply Z.
\\
\hline
\sphinxAtStartPar
\(\lvert 11\rangle\)
&
\sphinxAtStartPar
\(\alpha \lvert 1\rangle - \beta \lvert 0\rangle\)
&
\sphinxAtStartPar
Apply Z\(\cdot\)X
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Step 5}

\sphinxAtStartPar
If Alice obtain \(00\rangle\), then Bob’s qubit is in the desired state.  Otherwise, Bob needs to transform his qubit but he does not know what to do.  Alice sends a message given in \hyperref[\detokenize{algorithms/teleportation:table-teleport}]{Table \ref{\detokenize{algorithms/teleportation:table-teleport}}} to Bob through classical channel (such as telephone). In quantum circuit, this final adjustment can be done by applying CX\(_{q_M}^{q_B}\) and CZ\(_{q_A}^{q_B}\) after the measurement.  Note this CX and CZ are just mimicking the classical communication.

\sphinxAtStartPar
Bob follows the message.  Now, Bob has the desired state in all cases.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}\PYG{p}{,} \PYG{n}{QuantumRegister}\PYG{p}{,} \PYG{n}{ClassicalRegister}\PYG{p}{,} \PYG{n}{Aer}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}\PYG{p}{,} \PYG{n}{partial\PYGZus{}trace}\PYG{p}{,} \PYG{n}{purity}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{statevector\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Generate a state Alice has}
\PYG{c+c1}{\PYGZsh{} set parameters}
\PYG{n}{theta}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}
\PYG{n}{phi}\PYG{o}{=}\PYG{l+m+mf}{0.0}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{u}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{,}\PYG{n}{phi}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{psi0}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Step 1}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Step 2}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Step 3}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Step 4}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Step 5}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cz}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌────────────┐ ░                ┌───┐ ░ ┌─┐
q\PYGZus{}0: ┤ U(π/3,0,0) ├─░─────────────■──┤ H ├─░─┤M├─────────■─
     └────────────┘ ░ ┌───┐     ┌─┴─┐└───┘ ░ └╥┘┌─┐      │
q\PYGZus{}1: ───────────────░─┤ H ├──■──┤ X ├──────░──╫─┤M├──■───┼─
                    ░ └───┘┌─┴─┐└───┘      ░  ║ └╥┘┌─┴─┐ │
q\PYGZus{}2: ───────────────░──────┤ X ├───────────░──╫──╫─┤ X ├─■─
                    ░      └───┘           ░  ║  ║ └───┘
c: 2/═════════════════════════════════════════╩══╩═════════
                                              0  1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result}\PYG{o}{=}\PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{full\PYGZus{}statevector} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}statevector}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} get the density matrix for the first qubit by taking the partial trace}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Alice}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s initial state}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{rhoA} \PYG{o}{=} \PYG{n}{partial\PYGZus{}trace}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{purity=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{purity}\PYG{p}{(}\PYG{n}{rhoA}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{psiA} \PYG{o}{=} \PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{diagonal}\PYG{p}{(}\PYG{n}{rhoA}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{psiA}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Alice\PYGZsq{}s initial state
purity= (1.0000000000000002+0j)
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\sqrt{3}}{2} |0\rangle+\frac{1}{2} |1\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} get the density matrix for the first qubit by taking the partial trace}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bob}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s initial state}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{rhoB} \PYG{o}{=} \PYG{n}{partial\PYGZus{}trace}\PYG{p}{(}\PYG{n}{full\PYGZus{}statevector}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{purity=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{purity}\PYG{p}{(}\PYG{n}{rhoB}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{psiB} \PYG{o}{=} \PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{diagonal}\PYG{p}{(}\PYG{n}{rhoB}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{psiB}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Bob\PYGZsq{}s initial state
purity= (0.9999999999999993+0j)
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\sqrt{3}}{2} |0\rangle+\frac{1}{2} |1\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The result shows that the state of Bob’s qubit is pure and identical to the original state of Alice’s qubit.

\sphinxstepscope


\section{Walsh\sphinxhyphen{}Hadamard Transformation}
\label{\detokenize{algorithms/walshhadamard:walsh-hadamard-transformation}}\label{\detokenize{algorithms/walshhadamard:sec-walsh-hadamard}}\label{\detokenize{algorithms/walshhadamard::doc}}
\sphinxAtStartPar
An integer \(j\) can be expressed in binary bits \(j_{n-1}\,j_{n-2}\,\cdots\,j_{0}\) such that
\begin{equation*}
\begin{split}
j = 2^{n-1} j_{n-1} + 2^{n-2} j_{n-2} + \cdots + j_0 = \sum_{k=0}^{n-1} 2^k j_j
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(j_k = \in \{0,1\}\). The smallest and the largest integers expressed with \(n\) bits are \(0\) and \(2^{n}-1\).  We can encode integers in quantum computation in the same way.  Replacing the bits with qubits \(j_k\),
\begin{equation*}
\begin{split}
|j\rangle_n = |j_{n-1}\,j_{n-2}\,\cdots\,j_{0} \rangle = |j_{n-1} \rangle \otimes  |j_{n-2} \rangle \otimes \cdots \otimes |j_{0}\rangle = \underset{k=0}{\overset{n-1}{\Large\otimes}} |j_k\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(|\cdot\rangle_n\) is a ket in a \(n\)\sphinxhyphen{}dimensional Hilbert space.
For example, integers from 0 to 15 can be encoded in with qubits. Integer \(9\) is expressed as \(|9\rangle_4 = |0\rangle \otimes |1\rangle \otimes |0\rangle \otimes |1\rangle\).

\sphinxAtStartPar
An advantage of quantum computation is quantum parallelism using a super position state. It would be quite useful if we can create a superposition of many intergers
\begin{equation*}
\begin{split}
|\psi\rangle = \frac{1}{\sqrt{2^n}}\left(|0\rangle_n + |1\rangle_n + \cdots + |2^{n-1}\rangle_n \right).
\end{split}
\end{equation*}

\subsection{Walsh\sphinxhyphen{}Hadamard transformation}
\label{\detokenize{algorithms/walshhadamard:id1}}
\sphinxAtStartPar
To find a quantum algorithm, we look at a few small cases. For \(n=1\), the target state is \(\frac{1}{\sqrt{2}}\left(|0\rangle + |1\rangle\right)\).  We are already familiar with this state and \(H|0\rangle\) is the solution.  For \(n=2\), we have
\begin{equation*}
\begin{split}
\begin{align}
\frac{1}{2}\left(|0\rangle_2 + |1\rangle_2 + |2\rangle_2 + |3\rangle_2 \right) &=
\frac{1}{2}\left(|00\rangle + |01\rangle + |10\rangle + |11\rangle\right) \\
& = \frac{1}{\sqrt{2}}\left(|0\rangle + |1\rangle\right) \otimes \frac{1}{\sqrt{2}}\left(|0\rangle + |1\rangle\right) \\
& = H|0\rangle \otimes H|0\rangle = (H\otimes H) |0\rangle_2
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
It is now clear that the desired quantum algorithm for general case is
\begin{equation}\label{equation:algorithms/walshhadamard:walsh-hadamard}
\begin{split}
\begin{align}
|\psi\rangle &= (H \otimes H \otimes \cdots \otimes H) |0\rangle_n \\
& = \frac{1}{\sqrt{2}}\left(|0\rangle + |1\rangle\right) \otimes \frac{1}{\sqrt{2}}\left(|0\rangle + |1\rangle\right) \otimes \cdots \otimes \frac{1}{\sqrt{2}}\left(|0\rangle + |1\rangle\right)
\end{align}
\end{split}
\end{equation}
\sphinxAtStartPar
which is known as \sphinxstyleemphasis{Walsh\sphinxhyphen{}Hadamard} transform.

\sphinxAtStartPar
\sphinxstylestrong{Example} \hyperref[\detokenize{algorithms/walshhadamard:sec-walsh-hadamard}]{\ref{\detokenize{algorithms/walshhadamard:sec-walsh-hadamard}}}.1   The following example calculate the Wals\sphinxhyphen{}Hadamard transform for \(n=3\).  The result should be \(\frac{1}{\sqrt{8}} \left(|000\rangle + |001\rangle + \cdots + |110\rangle + |111\rangle \right)\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐
q\PYGZus{}0: ┤ H ├
     ├───┤
q\PYGZus{}1: ┤ H ├
     ├───┤
q\PYGZus{}2: ┤ H ├
     └───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Show the result of Walsh\PYGZhy{}Hadamard transform}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\frac{\sqrt{2}}{4} |000\rangle+\frac{\sqrt{2}}{4} |001\rangle+\frac{\sqrt{2}}{4} |010\rangle+\frac{\sqrt{2}}{4} |011\rangle+\frac{\sqrt{2}}{4} |100\rangle+\frac{\sqrt{2}}{4} |101\rangle+\frac{\sqrt{2}}{4} |110\rangle+\frac{\sqrt{2}}{4} |111\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Remarks}
\label{\detokenize{algorithms/walshhadamard:remarks}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Recalling that the Hadamard gate changes the basis set, from the computational basis to the \(x\)\sphinxhyphen{}basis.  The Walsh\sphinxhyphen{}Hadamard transformation is simply \(|00 \cdots 00\rangle \Rightarrow |++ \cdots ++\rangle\).  Interestingly, the simple product of \(|+\rangle\) corresponds to the superposition of integer states.  Quantum algorithms use this kind of \sphinxstyleemphasis{tricks} everywhere.

\item {}
\sphinxAtStartPar
The Walsh\sphinxhyphen{}Hadamard transformation generates the superposition state where all terms have the same phase.  Applying phase shifting gates such as \(Z\), \(S\), \(T\), and \(P\), you can modify the phases. Quantum Fourier transform is an example.  See \hyperref[\detokenize{algorithms/qft:sec-qft}]{Section \ref{\detokenize{algorithms/qft:sec-qft}}}.

\end{enumerate}


\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified on 07/23/2022.

\sphinxstepscope


\section{A little example of quantum parallelism}
\label{\detokenize{algorithms/qparallel:a-little-example-of-quantum-parallelism}}\label{\detokenize{algorithms/qparallel:sec-qparallel}}\label{\detokenize{algorithms/qparallel::doc}}
\sphinxAtStartPar
Quantum computer can calculate many different instances simultaneously. Here we consider a simple example.  Suppose that we want to calculate \(z = x \oplus y\) where \(x,\, y,\, z \in \{0,1\}\).  The variables are assigned to three qubits as \(|zyx\rangle = |z\rangle \otimes |y\rangle \otimes |x\rangle\).  Initially, \(z=0\).  The computation corresponds to transformation \(|0\rangle \otimes |y\rangle \otimes |x\rangle \Rightarrow |x \oplus y\rangle \otimes |y\rangle \otimes |x\rangle\).  There are four possible instances:
\begin{equation*}
\begin{split}
\begin{align}
|000\rangle \quad &\Rightarrow \quad |000\rangle \\
|001\rangle \quad &\Rightarrow \quad |101\rangle \\
|010\rangle \quad &\Rightarrow \quad |110\rangle \\
|011\rangle \quad &\Rightarrow \quad |011\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
We want to compute all these four cases at once.  We use a superposition state of the four input states. First we create four possible input states with equal weight and then we compute \(x\oplus y\) for each term:
\begin{equation*}
\begin{split}
\begin{align}
|000\rangle &\Rightarrow |0\rangle \otimes \frac{1}{2}\left(|0\rangle\otimes|0\rangle+|0\rangle\otimes|1\rangle+|1\rangle\otimes|0\rangle + |1\rangle\otimes|1\rangle \right) \\
&\Rightarrow \frac{1}{2}\left(|000\rangle + |101\rangle + |110\rangle + |011\rangle \right)
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
Note that the output does not include all possible states.  For example \(|111\rangle\) does not exist since \(1\oplus 1 \ne 1\).

\sphinxAtStartPar
The first step can be done with the Walsh\sphinxhyphen{}Hadamard transformation.  The addition can be done with thee \(CX\) gates as shown in XXX. The following circuit calculates four cases simultaneously.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐                ░ ┌─┐
q\PYGZus{}0: ┤ H ├──■─────────■───░─┤M├──────
     ├───┤┌─┴─┐     ┌─┴─┐ ░ └╥┘┌─┐
q\PYGZus{}1: ┤ H ├┤ X ├──■──┤ X ├─░──╫─┤M├───
     └───┘└───┘┌─┴─┐└───┘ ░  ║ └╥┘┌─┐
q\PYGZus{}2: ──────────┤ X ├──────░──╫──╫─┤M├
               └───┘      ░  ║  ║ └╥┘
c: 3/════════════════════════╩══╩══╩═
                             0  1  2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{8192}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}histogram}
\PYG{n}{plot\PYGZus{}histogram}\PYG{p}{(}\PYG{n}{counts}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{qparallel_3_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Only four states are obtained and each shows \(z = x \oplus y\). We indeed calculated four different cases at once thanks to the quantum parallelism.


\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified: 07/31/2022

\sphinxstepscope


\section{The Deutsch problem}
\label{\detokenize{algorithms/deutsch:the-deutsch-problem}}\label{\detokenize{algorithms/deutsch:sec-deustch}}\label{\detokenize{algorithms/deutsch::doc}}
\sphinxAtStartPar
We are going to solve a kind of classification problem discussed originally by Deutsch {[}\hyperlink{cite.references:id17}{4}{]}.   The problem itself is rather trivial and not really useful. However, it demonstrates an advantage of quantum computation over classical computation.


\subsection{The problem}
\label{\detokenize{algorithms/deutsch:the-problem}}
\sphinxAtStartPar
Consider a binary function \(x \mapsto f(x)\) where \(x \in \{0,1\}\) and \(f(x)  \in \{0,1\}\). There are only four possible functions, \(f_1,\, f_2,\, f_3,\, f_4\).



\sphinxAtStartPar
An oracle possess one of these functions.  We can ask it questions like “what is the value of \(f(1)\)?”  To find what function it has, we need to ask two questions, “what are \(f(0)\) and \(f(1)\)?”.  Now, let us try a simpler problem.  The outputs of \(f_1\) and \(f_2\) are always the same regardless of the input values.  So, we call them \sphinxstyleemphasis{constant} function.  On the other hand, the outputs of \(f_3\) and \(f_4\) contain both \(0\) and \(1\).  We shall call them \sphinxstyleemphasis{balanced} function.  Now, our task is to determine which type of the functions the oracle possess, constant or balanced. Hence, this is a classification task. Only we need to find out is if \(f(0)=f(1)\) or \(f(0)\ne f(1)\).  How many questions do we need to ask?  Although we don’t have to identify the function, it seems that we still need to ask two questions. It turns out that the Deutsch’s quantum algorithm requires only one question.


\subsection{Encoding the functions}
\label{\detokenize{algorithms/deutsch:encoding-the-functions}}
\sphinxAtStartPar
Before solving the problem, we need to find out how to express a function using gates.  Every gate is a unitary operator and thus the operation is reversible.  While \(f_3\) and \(f_4\) are bijective (invertible), \(f_1\) and \(f_2\) are even not surjective  and thus not invertible.  Here we use a two\sphinxhyphen{}qubit gate \(U_f\) acting on \(|q_0\rangle \otimes |q_1\rangle\) as defined by
\begin{equation*}
\begin{split}
U_f |x\rangle \otimes  |y\rangle = |x\rangle \otimes |y \oplus f(x)\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\oplus\) is modulo\sphinxhyphen{}2 addition.  The qubit \(q_0\) contains the value of \(x\) and its value is not affected by the gate.  The second qubit \(q_1\) is transformed from \(y\) to \(y \otimes f(x)\).  When \(y=0\), the output is simply the function value \(f(x)\).  When \(y=1\), \(1 \oplus f(x) = 1 - f(x)\).   By knowing the value of \(y\) and \(y \oplus f(x)\), we can find \(f(x)\).

\sphinxAtStartPar
Does such a gate exist?  If the gate is invertible, we can construct a unitary operator. Noting that \(z \oplus z = 0\) for any \(z\),
\begin{equation*}
\begin{split}
U_f |x\rangle \otimes |y \oplus f(x)\rangle = |x\rangle \otimes |y \oplus f(x) \oplus f(x)\rangle = |x\rangle \otimes |y \rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
indicating that \(U_f^{-1} = U_f\).  We just make it sure that \(U_f\) is self\sphinxhyphen{}adjoint.  Here we show the actual gates:


\bigskip\hrule\bigskip

\begin{itemize}
\item {}
\sphinxAtStartPar
\(f_1(x)\)

\end{itemize}

\sphinxAtStartPar
Since \(f(x)=0\),
\begin{equation*}
\begin{split}
U_{f_1} |x\rangle \otimes |y\rangle =  |x\rangle \otimes |y \oplus 0\rangle = |x\rangle \otimes |y\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Hence, \(U_{f_1} = I\)  (identity operator).


\bigskip\hrule\bigskip

\begin{itemize}
\item {}
\sphinxAtStartPar
\(f_2(x)\)

\end{itemize}

\sphinxAtStartPar
Since \(f(x) =1\)
\begin{equation*}
\begin{split}
U_{f_2} |x\rangle \otimes |y\rangle =  |x\rangle \otimes |y \oplus 1\rangle = |x\rangle \otimes (X|y\rangle)
= (I \otimes X)  |x\rangle \otimes |y\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Hence, \(U_{f_2} = I \otimes X\).


\bigskip\hrule\bigskip

\begin{itemize}
\item {}
\sphinxAtStartPar
\(f_3(x)\)

\end{itemize}

\sphinxAtStartPar
Since \(f(x) = x\),
\begin{equation*}
\begin{split}
U_{f_3} |x\rangle \otimes |y\rangle =  |x\rangle \otimes |y \oplus x\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
The output is \(|0\rangle \otimes |y\rangle\) if \(x=0\) and  \(|1\rangle \otimes X|y\rangle>\) if \(x=1\).  Hence \(x\) is a control bit and \(y\) flips only when \(x=1\).  This is not the standard control gate.  We need to flip \(q_0\) before  and after applying the control\sphinxhyphen{}\(X\), which is  \(U_{f_3} = (X \otimes I) \cdot CX_{q_0,q_1} \cdot (X \otimes I)\).


\bigskip\hrule\bigskip

\begin{itemize}
\item {}
\sphinxAtStartPar
\(f_4(x)\)

\end{itemize}

\sphinxAtStartPar
Since \(f(x) = 1-x\),
\begin{equation*}
\begin{split}
U_{f_4} |x\rangle \otimes |y\rangle =  |x\rangle \otimes |y \oplus (1-x) \rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
The output is \(0\rangle \otimes X|y\rangle\) if \(x=0\) and  \(|0\rangle \otimes |y\rangle>\) if \(x=1\).  Hence \(x\) is a control bit and \(y\) flips only when \(x=0\).  Thus,  \(U_{f_4} = CX_{q_0,q_1}\).


\bigskip\hrule\bigskip



\subsection{No\sphinxhyphen{}so smart algorithm}
\label{\detokenize{algorithms/deutsch:no-so-smart-algorithm}}
\sphinxAtStartPar
We just showed that how to encode the functions.  However, that is not our task.  The oracle has one of the above gates \(U_{f_i}\).  We want to know if it is constant or balanced.

\sphinxAtStartPar
Let’s us begin with a not\sphinxhyphen{}so\sphinxhyphen{}smart method.  We just ask two questions.  That is to apply \(U_f\) twice, the first one for \(x=0\) and the second for \(x=1\).
\begin{equation*}
\begin{split}
|0\rangle \otimes |0 \rangle \xrightarrow{U_f} |0\rangle \otimes |f(0)\rangle \xrightarrow{X\otimes I} |1\rangle \otimes |f(0)\rangle  \rangle \xrightarrow{U_f} |1\rangle \otimes |f(0) \oplus f(1)\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Now, we measure \(q_1\).  The outcome is \(f(0)\oplus f(1)\) with probability 1 (no error). The oracle has a constant function if the \(f(0)\oplus f(1) = 0\) and a balanced function if  \(f(0)\oplus f(1) = 1\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define functions}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}chose a function at random}
\PYG{n}{k}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{k}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{:}
    \PYG{n}{oracle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{constant}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{elif} \PYG{n}{k}\PYG{o}{==}\PYG{l+m+mi}{2}\PYG{p}{:}
    \PYG{n}{oracle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{constant}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{elif} \PYG{n}{k}\PYG{o}{==}\PYG{l+m+mi}{3}\PYG{p}{:}
    \PYG{n}{oracle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{balanced}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{elif} \PYG{n}{k}\PYG{o}{==}\PYG{l+m+mi}{4}\PYG{p}{:}
    \PYG{n}{oracle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{balanced}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Define Uf (Only Oracle knows it)}
\PYG{k}{def} \PYG{n+nf}{Uf}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} Uf appears between barriers}
    \PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{if} \PYG{n}{k}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{i}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{oracle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{constant}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{elif} \PYG{n}{k}\PYG{o}{==}\PYG{l+m+mi}{2}\PYG{p}{:}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{oracle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{constant}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{elif} \PYG{n}{k}\PYG{o}{==}\PYG{l+m+mi}{3}\PYG{p}{:}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{oracle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{balanced}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{k}{elif} \PYG{n}{k}\PYG{o}{==}\PYG{l+m+mi}{4}\PYG{p}{:}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qr}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{oracle} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{balanced}\PYG{l+s+s2}{\PYGZdq{}}

    \PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Consturct circuit}

\PYG{n}{Uf}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Uf}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      ░       ░ ┌───┐ ░       ░
q\PYGZus{}0: ─░───────░─┤ X ├─░───────░────
      ░ ┌───┐ ░ └───┘ ░ ┌───┐ ░ ┌─┐
q\PYGZus{}1: ─░─┤ X ├─░───────░─┤ X ├─░─┤M├
      ░ └───┘ ░       ░ └───┘ ░ └╥┘
c: 1/════════════════════════════╩═
                                 0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{8192}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} evaluate the probability}
\PYG{n}{p0}\PYG{o}{=}\PYG{n}{counts}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nshots}
\PYG{n}{p1}\PYG{o}{=}\PYG{n}{counts}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nshots}

\PYG{k}{if} \PYG{n}{p0} \PYG{o}{\PYGZgt{}} \PYG{n}{p1}\PYG{p}{:}
    \PYG{n}{answer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{constant}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{elif} \PYG{n}{p0} \PYG{o}{\PYGZlt{}} \PYG{n}{p1}\PYG{p}{:}
    \PYG{n}{answer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{balanced}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{answer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{unknown}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Quantum computer has found that the function is}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{answer}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{oracle}\PYG{o}{==}\PYG{n}{answer}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Correct! Oracle has}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{oracle}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Wrong! Oracle has}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{oracle}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Quantum computer has found that the function is constant .
Correct! Oracle has constant .
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{The Deutsch’s algorithm}
\label{\detokenize{algorithms/deutsch:the-deutsch-s-algorithm}}
\sphinxAtStartPar
Here is a challenge.  Can we solve the problem using \(U_f\) only once? In the previous algorithm, we use \(U_f\) twice, first for \(x=0\) and second for \(x=1\).  The key idea is that \(y\) can be in a superposition state.  If \(|y\rangle = |-\rangle\), what would be the answer from the oracle?

\sphinxAtStartPar
Let us try to find how the oracle responds.
\begin{equation*}
\begin{split}
U_f |x\rangle \otimes |-\rangle = |x \rangle \otimes \frac{1}{\sqrt{2}} \left( |f(x)\rangle - |1\oplus f(x)\rangle\right) = (-1)^{f(x)} |x\rangle \otimes |-\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Depending on the value of \(f(x)\), the gate does nothing or changes the phase.  This trick is known as \sphinxstyleemphasis{phase kickback}.

\sphinxAtStartPar
Now, we replace \(|x\rangle\) with another superposition state \(|+\rangle\).
\begin{equation}\label{equation:algorithms/deutsch:Uf+-}
\begin{split}
U_f |+\rangle \otimes |-\rangle = \frac{1}{\sqrt{2}} \left [ (-1)^{f(0)} |0\rangle \otimes -\rangle + (-1)^{f(1)} | 1 \rangle \otimes |-\rangle \right ]
\end{split}
\end{equation}
\sphinxAtStartPar
If the function is constant, \(f(0)=f(1)\).  Then, Eq. \eqref{equation:algorithms/deutsch:Uf+-} becomes
\begin{equation}\label{equation:algorithms/deutsch:Uf+-constant}
\begin{split}
U_f |+\rangle \otimes |-\rangle = (-1)^{f(0)} |+\rangle \otimes |-\rangle
\end{split}
\end{equation}
\sphinxAtStartPar
In it is balanced, \(f(0)\ne f(1)\), then we have
\begin{equation}\label{equation:algorithms/deutsch:Uf+-balanced}
\begin{split}
U_f |+\rangle \otimes |-\rangle = \pm |-\rangle \otimes |-\rangle
\end{split}
\end{equation}
\sphinxAtStartPar
Apart from the global phase, the difference between Eqs. \eqref{equation:algorithms/deutsch:Uf+-constant} and \eqref{equation:algorithms/deutsch:Uf+-balanced} is the state of \(q_0\).  If it is \(+\rangle\), then the answer is constant. If it is \(|-\rangle\) then, the answer is balanced.  Since we can measure only in the computational basis, we transofrm \(\pm\rangle\) by a Hadamard gate.

\sphinxAtStartPar
Here is the summary of the Deustch’s algorithm.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {}
\sphinxAtStartPar
Prepare \(|+\rangle \otimes |-\rangle\).

\item {}
\sphinxAtStartPar
Apply \(U_f\).

\item {}
\sphinxAtStartPar
Apply \(H \otimes I\)

\item {}
\sphinxAtStartPar
Measure \(q_0\)

\end{enumerate}

\sphinxAtStartPar
We use \(U_f\) only once!   Notice that we calculate \(x=0\) and \(x=1\) simultaneously using the super position state.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{p}{[}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Uf}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐      ░       ░ ┌───┐┌─┐
q\PYGZus{}0: ┤ H ├──────░───────░─┤ H ├┤M├
     ├───┤┌───┐ ░ ┌───┐ ░ └───┘└╥┘
q\PYGZus{}1: ┤ X ├┤ H ├─░─┤ X ├─░───────╫─
     └───┘└───┘ ░ └───┘ ░       ║
c: 1/═══════════════════════════╩═
                                0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{8192}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{p0}\PYG{o}{=}\PYG{n}{counts}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nshots}
\PYG{n}{p1}\PYG{o}{=}\PYG{n}{counts}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nshots}

\PYG{k}{if} \PYG{n}{p0} \PYG{o}{\PYGZgt{}} \PYG{n}{p1}\PYG{p}{:}
    \PYG{n}{answer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{constant}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{elif} \PYG{n}{p0} \PYG{o}{\PYGZlt{}} \PYG{n}{p1}\PYG{p}{:}
    \PYG{n}{answer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{balanced}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{answer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{unknown}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The function is found to be}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{answer}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{( oracle actually has}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{oracle}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
The function is found to be constant ( oracle actually has constant )
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Quantum Fourier Transform}
\label{\detokenize{algorithms/qft:quantum-fourier-transform}}\label{\detokenize{algorithms/qft:sec-qft}}\label{\detokenize{algorithms/qft::doc}}
\sphinxAtStartPar
Fourier transform (FT) is a ubiquitous mathematical tool used in science, engineering and beyond and we are using it every day without knowing it. Whenever digital signals are processed, the Fourier transform is most likely used including WiFi, cell phone, digital music, digital picture, …, to name a few.  We wish to calculate the Fourier transform on a quantum computer.  It turns out that quantum computers are not good at calculating general Fourier transform as explained below.  We will focus on a very special case not for the sake of Fourier transform but for other quantum algorithms such as phase estimation.


\subsection{Discrete Fourier Transform}
\label{\detokenize{algorithms/qft:discrete-fourier-transform}}
\sphinxAtStartPar
The digital signal processes use a particular form  of Fourier transform known as \sphinxstyleemphasis{discrete Fourier transform} defined by
\begin{equation}\label{equation:algorithms/qft:DFT}
\begin{split}
y_n = \frac{1}{\sqrt{N}} \sum_{m=0}^{N-1} x_m e^{2\pi i\, n\, m/N}
\end{split}
\end{equation}
\sphinxAtStartPar
or writing ti in a matrix from
\begin{equation}\label{equation:algorithms/qft:DFT-as-matrix}
\begin{split}
\begin{bmatrix}y_0\\y_1\\ \vdots \\ y_{N-1}\end{bmatrix} = \frac{1}{\sqrt{N}}
\begin{bmatrix} 1 & 1 & \cdots & 1 \\ 1 & e^{2\pi i/N} & \cdots & e^{2\pi i (N-1)/N} \\
\vdots & \vdots & \cdots &\vdots \\ 1 & e^{2\pi i (N-1)/N} &\cdots & e^{2\pi i (N-1)^2/N}
\end{bmatrix}
\begin{bmatrix}x_0\\x_1\\ \vdots \\ x_{N-1}\end{bmatrix}
\end{split}
\end{equation}
\sphinxAtStartPar
where \(x_m \in \mathbb{C}\) is the original signal and \(y_n \in \mathbb{C}\) is its Fourier transform.

\sphinxAtStartPar
Writing the column vectors in kets as
\begin{equation*}
\begin{split}
|x\rangle \doteq \begin{bmatrix}x_0\\x_1\\ \vdots \\ x_{N-1}\end{bmatrix}, \qquad
|y\rangle \doteq \begin{bmatrix}y_0\\y_1\\ \vdots \\ y_{N-1}\end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
and the matrix as an operator
\begin{equation*}
\begin{split}
\mathcal{F}_N \doteq \frac{1}{\sqrt{N}} \begin{bmatrix} 1 & 1 & \cdots & 1 \\ 1 & e^{2\pi i/N} & \cdots & e^{2\pi i (N-1)/N} \\
\vdots & \vdots & \cdots &\vdots \\ 1 & e^{2\pi i (N-1)/N} &\cdots & e^{2\pi i (N-1)^2/N}
\end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
which we shall call \sphinxstyleemphasis{Fourier operator} or \sphinxstyleemphasis{Fourier gate}. Now, the Fourier transform can be written in an abstract form
\begin{equation}\label{equation:algorithms/qft:DFT-as-operator}
\begin{split}
|y\rangle = \mathcal{F}_N |x\rangle .
\end{split}
\end{equation}
\sphinxAtStartPar
It is easy to check that \(\mathcal{F}_N \mathcal{F}_N^\dagger = 1\) and thus \(\mathcal{F}_N\) is unitary. The inverse Fourier transform is done by \(\mathcal{F}^\dagger\) as
\begin{equation}\label{equation:algorithms/qft:DFT-inverse}
\begin{split}
|x\rangle = \mathcal{F}_N^\dagger |y\rangle .
\end{split}
\end{equation}
\sphinxAtStartPar
A unitary transformation in \(N\)\sphinxhyphen{}dimensional Hilbert space can be implemented as a quantum transformation by 1) preparing a quantum state \(|x\rangle\) using a certain basis set, 2) constructing the unitary operator, and 3) reading out \(|y\rangle\).However, we have a couple of issues here.  First of all,  quantum measurement only gives us \(|y_n|\) through the Born rule.  This is not necessarily a fatal limitation since many applications need only the modulus such as power spectrum. Secondly, when \(N\) is very large as in the engineering applications, there is no good way to prepare \(|x\rangle\)  and also finding all \(|y_n|\) requires a huge number of quantum measurement.   Unfortunately, the quantum version of DFT seems not feasible for traditional applications.

\sphinxAtStartPar
Nevertheless, the quantum Fourier transform has several useful application such as phase estimation and period finding. It is worth developing a quantum algorithm for \(\mathcal{F}_N\).  To do so, we consider the Fourier transform of the computational basis \(|u_j\rangle ,\,  j=0,\cdots 2^{n-1}\) where \(n\) is the number of qubits.  Writing them  explicitly in the computational bases,
\begin{equation*}
\begin{split}
|u_j\rangle=|j_n\, j_{n-1}\, \cdots\, j_1\rangle \equiv  |j_n\rangle \otimes |j_{n-1}\rangle \otimes \cdots \otimes |j_1\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
where the individual qubit takes values \(j_i \in \{0,1\}\) and \(j\) is decimal expression of the binary string \(j_1\, j_2,\cdots\, j_n\), that is
\begin{equation}\label{equation:algorithms/qft:decimal-binary}
\begin{split}
j=2^{n-1} j_{n} + 2^{n-2} j_{n-1} +\cdots+ j_1 = \sum_{\ell=1}^{n} 2^{\ell-1} j_\ell
\end{split}
\end{equation}
\sphinxAtStartPar
For \(n=2\), there are four basis kets \(|u_0\rangle=|00\rangle,\, |u_1\rangle=|01\rangle,\,  |u_2\rangle=|10\rangle,\, |u_3\rangle=|11\rangle\).

\sphinxAtStartPar
When the Fourier operator is applied to the computational basis we obtain a new basis
\begin{equation}\label{equation:algorithms/qft:QFT}
\begin{split}
|w_j\rangle = \mathcal{F}_N |u_j\rangle .
\end{split}
\end{equation}
\sphinxAtStartPar
We can construct a quantum circuit for the Fourier operator \(\mathcal{F}_N\) from Eq.  \eqref{equation:algorithms/qft:QFT}.  Once we obtained the circuit or the Fourier gate, we can apply it to other states.In literature  “quantum Fourier transform” often means  Eq.\eqref{equation:algorithms/qft:QFT} or the Fourier gate \(\mathcal{F}_N\) rather than the general Fourier transform \eqref{equation:algorithms/qft:DFT-as-operator}.

\sphinxAtStartPar
\sphinxstylestrong{Exercise} \hyperref[\detokenize{algorithms/qft:sec-qft}]{\ref{\detokenize{algorithms/qft:sec-qft}}}.1   Show that \(|k_j\rangle\) forms an orthonormal basis set.


\subsection{The QFT algorithm}
\label{\detokenize{algorithms/qft:the-qft-algorithm}}
\sphinxAtStartPar
Now we construct the Foureir operator.
First, we compute Eq. \eqref{equation:algorithms/qft:QFT} explicitly in the computational basis.

\sphinxAtStartPar
\sphinxstylestrong{N=2}Let us consider \(n=1\), the simplest QFT transforms the computational basis \(0\rangle\) and \(|1\rangle\) as
\begin{equation}\label{equation:algorithms/qft:qft2}
\begin{split}
\begin{align}
\mathcal{F}_2 |u_0\rangle &= \mathcal{F}_2 |0\rangle = \frac{1}{\sqrt{2}} \left(|0\rangle +  e^{i 0} |1\rangle\right) = \frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right)\\
\mathcal{F}_2 |u_1\rangle &= \mathcal{F}_2 |1\rangle = \frac{1}{\sqrt{2}} \left(|0\rangle + e^{i \pi}|1\rangle\right) = \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right).
\end{align}
\end{split}
\end{equation}
\sphinxAtStartPar
We want to find a quantum circuit that does the same transformation. Recalling that
\begin{equation}\label{equation:algorithms/qft:hgate-as-qft2}
\begin{split}
\begin{align}
H |0\rangle &= \frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right) \\
H |1\rangle &= \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right)
\end{align}
\end{split}
\end{equation}
\sphinxAtStartPar
By direct comparison between Eqs. \eqref{equation:algorithms/qft:qft2} and \eqref{equation:algorithms/qft:hgate-as-qft2}, it is clear that \(\mathcal{F}_2 = H\). We learned in \hyperref[\detokenize{q1gates/h:sec-hgate}]{Section \ref{\detokenize{q1gates/h:sec-hgate}}} that the Hadamard gate transforms the computational basis to the \(x\)\sphinxhyphen{}basis. That transformation turned out to be the lowest order QFT and  we have already computed it.   See \hyperref[\detokenize{q1gates/h:sec-hgate-qft}]{Section \ref{\detokenize{q1gates/h:sec-hgate-qft}}}.

\sphinxAtStartPar
\sphinxstylestrong{N=4}

\sphinxAtStartPar
We need more examples to get an idea of \(\mathcal{F}_N\)..  Let us try \(n=2\).
\begin{equation}\label{equation:algorithms/qft:qft4}
\begin{split}
\begin{align}
\mathcal{F}_2 |u_0\rangle &=\mathcal{F}_2 |00\rangle = \frac{1}{2} \left(|00\rangle + |01\rangle  +|10\rangle + |11\rangle\right)\\ &= \frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right) \otimes
\frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right) \\
\mathcal{F}_2 |u_1\rangle &= \mathcal{F}_2 |01\rangle = \frac{1}{2} \left(|00\rangle + e^{i \pi/2}|01\rangle + e^{i \pi}|10\rangle + e^{i 3\pi/2}|11\rangle \right)\\
&= \frac{1}{2} \left(|00\rangle + i |01\rangle  - |10\rangle  -i |11\rangle \right)\\& = \frac{1}{\sqrt{2}} \left(|0\rangle -  |1\rangle\right) \otimes \frac{1}{\sqrt{2}} \left(|0\rangle + i |1\rangle\right) \\
\mathcal{F}_2 |u_2\rangle &= \mathcal{F}_2 |10\rangle = \frac{1}{2} \left(|00\rangle + e^{i \pi}|01\rangle + e^{2 i \pi}|10\rangle + e^{i 3 \pi}|11\rangle \right) \\
&= \frac{1}{2} \left(|00\rangle - |01\rangle +|10\rangle - |11\rangle \right) \\
&=  \frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right) \otimes \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right)\\
\mathcal{F}_2 |u_3\rangle &= \mathcal{F}_2 |11\rangle = \frac{1}{2} \left(|00\rangle + e^{i 3\pi/2}|01\rangle + e^{3 i \pi}|10\rangle + e^{i 9 \pi/2} |11\rangle \right) \\
&= \frac{1}{2} \left(|00\rangle - i|01\rangle - |10\rangle + i |11\rangle \right) \\
&=  \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right) \otimes \frac{1}{\sqrt{2}} \left(|0\rangle -i |1\rangle\right)
\end{align}
\end{split}
\end{equation}
\sphinxAtStartPar
The corresponding quantum circuit seems complicated since phase factor \(\pm i\) are now involved.  We recall that \(S\) gate does the job.
\begin{equation}\label{equation:algorithms/qft:s-h-gates}
\begin{split}
\begin{align}
S \cdot H |0\rangle &= \frac{1}{\sqrt{2}}\left(|0\rangle + i |1\rangle\right) \\
S \cdot H |1\rangle &= \frac{1}{\sqrt{2}}\left(|0\rangle - i |1\rangle\right)
\end{align}
\end{split}
\end{equation}
\sphinxAtStartPar
Using eqs. \eqref{equation:algorithms/qft:hgate-as-qft2} and \eqref{equation:algorithms/qft:s-h-gates}, we try the following transformations
\begin{equation*}
\begin{split}
\begin{align}
H \otimes H |00\rangle & = \frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right) \otimes
\frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right) \\
(S\cdot H) \otimes H |01\rangle & = \frac{1}{\sqrt{2}}\left(|0\rangle + i |1\rangle\right)  \otimes
 \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right) \\
H \otimes H |10\rangle & = \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right) \otimes
\frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right) \\
(S\cdot H) \otimes H |11\rangle & = \frac{1}{\sqrt{2}}\left(|0\rangle - i |1\rangle\right)  \otimes
 \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right)
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
The results are close to the Fourier transform but the order of the output bits are wrong.  We need to swap the qubits.  Another issue is that \(S\) gates is applied to \(|01\rangle\) and \(|11\rangle\).  Noting that the second qubit is \(1\rangle\).  Hence, we can use the controlled\sphinxhyphen{}S gate with the second qubit as the control.
\begin{equation}\label{equation:algorithms/qft:qft4-gates}
\begin{split}
\begin{align}
SWAP \cdot (H \otimes I) \cdot CS \cdot (I \otimes H) |00\rangle & = \frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right) \otimes
\frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right) \\
SWAP \cdot (H \otimes I) \cdot CS \cdot (I \otimes H)  |01\rangle & = \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right) \otimes  \frac{1} {\sqrt{2}}\left(|0\rangle + i |1\rangle\right)
 \\
SWAP \cdot (H \otimes I) \cdot CS \cdot (I \otimes H) |10\rangle  & = \frac{1}{\sqrt{2}} \left(|0\rangle + |1\rangle\right)  \otimes
 \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right) \\
SWAP \cdot (H \otimes I) \cdot CS \cdot (I \otimes H) |11\rangle & =  \frac{1}{\sqrt{2}} \left(|0\rangle - |1\rangle\right)   \otimes
\frac{1}{\sqrt{2}}\left(|0\rangle - i |1\rangle\right)
\end{align}
\end{split}
\end{equation}
\sphinxAtStartPar
Now, the Fourier transform \eqref{equation:algorithms/qft:qft4} and The circhuit \eqref{equation:algorithms/qft:qft4-gates} produces the same outputs.  Hence, \(\mathcal{F}_4 = SWAP \cdot (H \otimes I) \cdot CS \cdot (I \otimes H)\).

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
               ┌───┐
q\PYGZus{}0: ───────■──┤ H ├─X─
     ┌───┐┌─┴─┐└───┘ │
q\PYGZus{}1: ┤ H ├┤ S ├──────X─
     └───┘└───┘
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
In the following example, all four transformations \eqref{equation:algorithms/qft:qft2} are computed using Qiskit.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c+c1}{\PYGZsh{} qiskit does not have predefined controlled\PYGZhy{}S gate}
\PYG{c+c1}{\PYGZsh{} In this application we use an equivalent gate controlled\PYGZhy{}P gate.}

\PYG{k}{def} \PYG{n+nf}{QFT}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} define the Fourier gate    }
    \PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qc}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} for |00\PYGZgt{}}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} apply the Fourier gate}
\PYG{n}{QFT}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Show the Fourier transform}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fourier transform of |00\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Fourier transform of |00\PYGZgt{}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{1}{2} |00\rangle+\frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle+\frac{1}{2} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} for |01\PYGZgt{}}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{QFT}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fourier transform of |01\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Fourier transform of |01\PYGZgt{}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{1}{2} |00\rangle+\frac{i}{2} |01\rangle- \frac{1}{2} |10\rangle- \frac{i}{2} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} for |10\PYGZgt{}}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{QFT}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fourier transform of |10\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Fourier transform of |10\PYGZgt{}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{1}{2} |00\rangle- \frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle- \frac{1}{2} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} for |11\PYGZgt{}}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{QFT}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{=}\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fourier transform of |10\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{psi}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Fourier transform of |10\PYGZgt{}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{1}{2} |00\rangle- \frac{i}{2} |01\rangle- \frac{1}{2} |10\rangle+\frac{i}{2} |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Higher order QFT}

\sphinxAtStartPar
Now we have some good idea about QFT. Now, we try to find \(\mathcal{F}_N\).  The derivation is a bit complicated but the extension of the \(N=4\) case.  First, we evaluate \(\mathcal{F}_N |j\rangle\).
\begin{equation*}
\begin{split}
\begin{align}
\mathcal{F}_N |j\rangle  = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2\pi i\, j\, k /2^n} |k\rangle \\
& = \sum_{k=0}^{N-1} e^{2\pi i\, j\,\sum_{\ell=1}^{n} k_\ell/2^\ell} |k_1\, k_2\, \cdots\, k_n \rangle \\
& = \left (\sum_{k_1=0}^1 e^{2 \pi i\, j\, k_1/2} |k_1\rangle\right) \otimes \left (\sum_{k_2=0}^1 e^{2 \pi i\, j, k_2/2^2} |k_2\rangle\right)\otimes \cdots \otimes \left (\sum_{k_n=0}^1 e^{2 \pi i\,j\' k_n/2^n} |k_n\rangle\right) \\
& = \left(|0\rangle + e^{2 \pi i\, j /2} |1\rangle \right) \otimes \left(|0\rangle + e^{2 \pi i\, j /2^2 } |1\rangle \right) \otimes \cdots \otimes \left(|0\rangle + e^{2 \pi i\, j /2^n}|1\rangle \right)
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
The results look quite similar to Eq. \eqref{equation:algorithms/qft:qft4}.  Only the difference is the phase angles.  The question is how we calculate the phase angle. Let us take a closer look at a phase factor \(e^{2 \pi i\, j /2^k},\, 1 \le k \le n\).  Using Eq. \eqref{equation:algorithms/qft:decimal-binary},
\begin{equation*}
\begin{split}
e^{2\pi i\, j /2^k} = e^{2 \pi i\, \sum_{\ell=1}^{n} 2^{\ell-1-k} j_\ell } = e^{2\pi i , j_1 /2^k} e^{2\pi i\,j_2/2^{k-1}} \cdots e^{2\pi i\, j_k/2} e^{2 \pi i j_{k+1}} \cdots e^{2\pi i\, j_{n} (n-1-k)} = e^{2\pi i\, j_1/2^k} e^{2\pi i\, j_2 /2^{k-1}} \cdots e^{2\pi i\, j_k/2}
\end{split}
\end{equation*}
\sphinxAtStartPar
We need to apply the phase rotation of angle \(k\) different phase angle \(2\pi j_\ell /2^{ell-1-k},\, 1 \le \ell \le k\).  No rotation is needed when \(\ell > k\) or \(j_\ell=0\).  Hence, we apply the controlled phase gate \(CP(2\pi/2^{\ell-1-k})\) only when \(j_\ell=0\).  In conclusion, apply \(H\) to \(k\)\sphinxhyphen{}th qubit and apply controlled\sphinxhyphen{}\(P\) gate  \(k\) times with appropriate angles.  Repeat this from \(k=n\) to \(k=1\) in the backward so that source qubits of controlled \(P\) gate is not modified before the controlled operation.  As you saw in \(\mathcal{F}_4\), the order of the qubits is wrong after these operations.  Hence, we reverse the order by applying swap gates.

\sphinxAtStartPar
The following circuit is equivalent to \(\mathcal{F}_8\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 3}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 2}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 1}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 0}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} reordering}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mpl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{qft_13_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified: 07\sphinxhyphen{}19\sphinxhyphen{}2022

\sphinxstepscope


\section{Quantum Phase Estimation}
\label{\detokenize{algorithms/qpe:quantum-phase-estimation}}\label{\detokenize{algorithms/qpe:sec-qpe}}\label{\detokenize{algorithms/qpe::doc}}
\sphinxAtStartPar
The problem of quantum phase estimation (QPE) is just a special kind of eigenvalue problem.  However, it plays a quite important role in quantum computation.  It can be considered as a subroutine used in many useful quantum algorithms such as factorization, quantum walks, … So, we need to learn it before other quantum algorithms.


\subsection{The problem}
\label{\detokenize{algorithms/qpe:the-problem}}
\sphinxAtStartPar
Consider a unitary operator \(U\) in a \(2n\)\sphinxhyphen{}dimension Hilbert space \((\mathbb{C}_2)^{\otimes n}\).  Its eigenvector \(|psi_\lambda\rangle\) satisfies the eigenvalue equation \(U |\psi_\lambda\rangle = \lambda |\psi_\lambda\rangle\) where \(\lambda\) is the eigenvalue. The adjoint of the eigenvalue equation is \(\langle \psi_\lambda| U^\dagger = \langle \psi_\lambda| \lambda^*\). The inner product of the two eigenvalue equations is \(\langle \psi_\lambda| U^\dagger U |\psi_\lambda\rangle = |\lambda|^2 \langle\psi_\lambda|\psi_\lambda\rangle\).  Since \(U\) is unitary, \(U\dagger U = I\) and thus \(|\lambda|=1\). So, the eigenvalue equation can be written as
\begin{equation*}
\begin{split}
U|\psi_\theta\rangle = e^{2 \pi i\theta} |\psi_\theta\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(|\psi_\theta\rangle\) is the eigenvector and the corresponding eigenvalue is \(e^{2\pi i\theta}\). Our task is to find the phase variable  \(\theta \in [0,1)\) for a given \(|\psi_\theta\).  Mathematically, it is a trivial problem. Assuming \(|\psi_\theta\rangle\) is normalized, \(e^{2\pi i \theta} =  \langle \psi_\theta | U | \psi_\theta \rangle\), which current quantum computer cannot compute.  Can we find \(\theta\) without computing the inner product?


\subsection{Encoding a continuous number between 0 and 1}
\label{\detokenize{algorithms/qpe:encoding-a-continuous-number-between-0-and-1}}\label{\detokenize{algorithms/qpe:ssec-binary-fraction}}
\sphinxAtStartPar
The value we want to find is not integer.  How can we encode a continuous number between 0 and 1 in qubits? Since it is not possible to encode a true continuous number in digital computers, we approximate it.  In \hyperref[\detokenize{algorithms/walshhadamard:sec-walsh-hadamard}]{Section \ref{\detokenize{algorithms/walshhadamard:sec-walsh-hadamard}}} we encoded integers between \(0\) and \(2^n-1\) in \(n\) qubits as \(|j\rangle_n = |j_{n-1}\,j_{n-2}\,\cdots\,j_{0} \rangle\).  Noting that \( 0 \le 2^n \theta < 2^n\), we can encode \(2^n \theta\) as an integer state \(|j\rangle_n\).  Then, \(\theta = j/2^n\), which is not continuous and there is a gap of \(2^{-n}\).  The gap decreases quickly as \(n\) increases.  If an accurate value of \(\theta\) is needed, we must use a large number of qubits.

\sphinxAtStartPar
Our task is now to find the integer state \(|j\rangle_n\) corresponding to \(\theta\).


\section{}
\label{\detokenize{algorithms/qpe:id1}}

\subsection{The algorithm}
\label{\detokenize{algorithms/qpe:the-algorithm}}
\sphinxAtStartPar
The QPE algorithm was developed by Kitaev in 1995 {[}\hyperlink{cite.references:id18}{5}{]}.

\sphinxAtStartPar
We use \(n+1\) qubits.  The first \(n\) qubits are used to from  the computational basis \(\ell\rangle_n\, \ell=0,\cdots, n-1\) and \(the remaining qubit stores \)|psi\textbackslash{}rangle\$.
The first step of our strategy is to create the following state:
\begin{equation}\label{equation:algorithms/qpe:qpe-step1}
\begin{split}
|\Phi\rangle_{n+1} = \frac{1}{\sqrt{2^n}} \left (|0\rangle_n  + |1\rangle_n + \cdots |n-1\rangle_n \right) \otimes |\psi\rangle = \sum_{\ell=0}^{n-1} |\ell\rangle_n \otimes |\psi\rangle
\end{split}
\end{equation}
\sphinxAtStartPar
We try to find a quantum algorithm that transforms it to \(|j\rangle_n \otimes |\psi\rangle\).  In other words, the algorithm eliminates the integer states expect for \(|j\rangle_n\).  Since there is one term at the end, measurement detects \(|j\rangle_n\) with high certainty.

\sphinxAtStartPar
We can generate \eqref{equation:algorithms/qpe:qpe-step1} using the Walsh\sphinxhyphen{}Hadamard transformation discussed in \hyperref[\detokenize{algorithms/walshhadamard:sec-walsh-hadamard}]{Section \ref{\detokenize{algorithms/walshhadamard:sec-walsh-hadamard}}}.  Furthermore, we know that Eq. \eqref{equation:algorithms/qpe:qpe-step1} is equivalent to
\begin{equation*}
\begin{split}
|\Phi\rangle_{n+1} = \frac{1}{\sqrt{2^{n+1}}} \left(|0\rangle + |1\rangle\right) \otimes \cdots \otimes \left(|0\rangle + |1\rangle\right) \otimes |\psi\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Next we consider a controlled gate \(CU^{2^i}\) which applys the unitary operator \(U\) \(2^i\) times on \(\psi\rangle\) when \(i\)\sphinxhyphen{}th qubit is in \(1\rangle\) and does nothing otherwise.  For example, the \(i\)\sphinxhyphen{}th qubit is transformed as (only the \(i\)\sphinxhyphen{}qubit and \(|psi\rangle\) are shown)
\begin{equation*}
\begin{split}
\begin{align}
CU^{2^i} \left(|0\rangle + |1\rangle\right)_i \otimes |\psi\rangle &=
|0\rangle \otimes |\psi\rangle + |1\rangle \otimes (U^{2^i}|\psi\rangle)
= |0\rangle \otimes |\psi\rangle + |1\rangle \otimes (e^{2\pi i\, \theta\, 2^i} |\psi\rangle) \\
&= \left(|0\rangle + e^{2\pi i\, \theta\, 2^i} |1\rangle\right) \otimes |\psi\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
Applying the gate to all qubits (except for \(|\psi\rangle\)),
\begin{equation*}
\begin{split}
\begin{align}
\overset{n-1}{\underset{i=0}{\Large\otimes}} CU^{2^i} |\Psi\rangle_{n+1}
&= \frac{1}{\sqrt{2^{n+1}}} \left(|0\rangle + e^{2\pi i\, \theta\,2^{n-1}}|1\rangle\right) \otimes \cdots \otimes \left(|0\rangle + e^{2\pi i\, \theta\,2^{0}}|1\rangle\right) \otimes |\psi\rangle \\
& =  \frac{1}{\sqrt{2^{n+1}}} \sum_{\ell=0}^{n-1} e^{2\pi i\, \theta\, \ell} |\ell\rangle \otimes |\psi\rangle =  \frac{1}{\sqrt{2^{n+1}}} \sum_{\ell=0}^{n-1} e^{2\pi i\, 2^n \theta\, \ell/2^n} |\ell\rangle \otimes |\psi\rangle \\
&= \mathcal{F}_{n} |2^n \theta\rangle \otimes |\psi\rangle
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
Recall that \(2^n \theta\) is an integer as discussed in \hyperref[\detokenize{algorithms/qpe:ssec-binary-fraction}]{Section \ref{\detokenize{algorithms/qpe:ssec-binary-fraction}}}.  Hence, we have Fourier transform of a computational basis.

\sphinxAtStartPar
The final step is to apply inverse Fourier transform.
\begin{equation*}
\begin{split}
\mathcal{F}^\dagger_{n} \cdot \overset{n-1}{\underset{i=0}{\Large\otimes}} CU^{2^i} |\Psi\rangle_{n+1} = \mathcal{F}^\dagger _{n} \mathcal{F}_{n} |2^n \theta\rangle \otimes |\psi\rangle =  |2^n \theta\rangle \otimes |\psi\rangle.
\end{split}
\end{equation*}
\sphinxAtStartPar
We have obtained a desired state.  Suppose that we obtain \(|j\rangle\) up on the measurement with high probability, then \(\theta = j/2^n\).

\sphinxAtStartPar
If the number of qubits is not big enough, \(2^n \theta\) can deviate from any integer.  Nevertheless, the chance to find the nearest integer \(j\) is much high than other integers.  Thence, this algorithm gives us a good estimate of \(\theta\).  See the discussion of the error in {[}\hyperlink{cite.references:id5}{6}{]}.


\subsection{Example}
\label{\detokenize{algorithms/qpe:example}}
\sphinxAtStartPar
Consider a unitary operator \(U = T^3\). \(|1\rangle\) is known to be its eigenket.  We want to find the phase of angle \(\theta\) of the corresponding eigenvalue.  Since the value of \(\theta\) is not known, we don’t know how many qubits are needed.  Let us try three qubits for the expression of \(\theta\) and another qubit for \(|psi\rangle\).  We need also three classical bits for measurement. \(T^3\) can be realized by the pase gate \(P(3\pi/4)\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Walsh\PYGZhy{}Hadamard transformation for qubit 0\PYGZhy{}2}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} X for qubit 3 to create |1\PYGZgt{}}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 0}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 1}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 2}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐ ░                                                             »
q\PYGZus{}0: ┤ H ├─░──■──────────────────────────────────────────────────────────»
     ├───┤ ░  │                                                          »
q\PYGZus{}1: ┤ H ├─░──┼─────────■─────────■──────────────────────────────────────»
     ├───┤ ░  │         │         │                                      »
q\PYGZus{}2: ┤ H ├─░──┼─────────┼─────────┼─────────■─────────■─────────■────────»
     ├───┤ ░  │P(3π/4)  │P(3π/4)  │P(3π/4)  │P(3π/4)  │P(3π/4)  │P(3π/4) »
q\PYGZus{}3: ┤ X ├─░──■─────────■─────────■─────────■─────────■─────────■────────»
     └───┘ ░                                                             »
c: 3/════════════════════════════════════════════════════════════════════»
                                                                         »
«                ░
«q\PYGZus{}0: ───────────░─
«                ░
«q\PYGZus{}1: ───────────░─
«                ░
«q\PYGZus{}2: ─■─────────░─
«      │P(3π/4)  ░
«q\PYGZus{}3: ─■─────────░─
«                ░
«c: 3/═════════════
«
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Inverse Fourier transform}

\PYG{c+c1}{\PYGZsh{} SWAP}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 0}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 1}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 2}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     ┌───┐ ░                                                             »
q\PYGZus{}0: ┤ H ├─░──■──────────────────────────────────────────────────────────»
     ├───┤ ░  │                                                          »
q\PYGZus{}1: ┤ H ├─░──┼─────────■─────────■──────────────────────────────────────»
     ├───┤ ░  │         │         │                                      »
q\PYGZus{}2: ┤ H ├─░──┼─────────┼─────────┼─────────■─────────■─────────■────────»
     ├───┤ ░  │P(3π/4)  │P(3π/4)  │P(3π/4)  │P(3π/4)  │P(3π/4)  │P(3π/4) »
q\PYGZus{}3: ┤ X ├─░──■─────────■─────────■─────────■─────────■─────────■────────»
     └───┘ ░                                                             »
c: 3/════════════════════════════════════════════════════════════════════»
                                                                         »
«                ░    ┌───┐                                         ░ ┌─┐
«q\PYGZus{}0: ───────────░──X─┤ H ├─■──────────────■────────────────────────░─┤M├──────
«                ░  │ └───┘ │P(\PYGZhy{}π/2) ┌───┐ │                        ░ └╥┘┌─┐
«q\PYGZus{}1: ───────────░──┼───────■────────┤ H ├─┼─────────■──────────────░──╫─┤M├───
«                ░  │                └───┘ │P(\PYGZhy{}π/4)  │P(\PYGZhy{}π/2) ┌───┐ ░  ║ └╥┘┌─┐
«q\PYGZus{}2: ─■─────────░──X──────────────────────■─────────■────────┤ H ├─░──╫──╫─┤M├
«      │P(3π/4)  ░                                            └───┘ ░  ║  ║ └╥┘
«q\PYGZus{}3: ─■─────────░──────────────────────────────────────────────────░──╫──╫──╫─
«                ░                                                  ░  ║  ║  ║
«c: 3/═════════════════════════════════════════════════════════════════╩══╩══╩═
«                                                                      0  1  2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{8192}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}histogram}
\PYG{n}{plot\PYGZus{}histogram}\PYG{p}{(}\PYG{n}{counts}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{qpe_8_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We obtain \(|011\rangle = |3\rangle_3\)  with unit probability.   The quantum algorithm has selected \(j=3\) out of 8 integers. Hence, \(\theta = 3 / 2^3 = 3/8\).  The result is in perfect agreement with the actual eigenvalue \(e^{i \pi 3/4} = e^{2\pi i 3/8}\).

\sphinxAtStartPar
What will happen if we use more qubits than necessary?  Let us try 4 qubits.  There are 16 integer numbers to chose.  If \(j=6\) is selected, we should get the same answer.  The following code indeed finds 6 as the answer.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Walsh\PYGZhy{}Hadamard transformation for qubit 0\PYGZhy{}2}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} X for qubit 3 to create |1\PYGZgt{}}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}

\PYG{c+c1}{\PYGZsh{} qubit 0}
    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} SWAP}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 0}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 1}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 2}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 3}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{8192}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}histogram}
\PYG{n}{plot\PYGZus{}histogram}\PYG{p}{(}\PYG{n}{counts}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{qpe_10_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now we got \(|0110\rangle = |6\rangle\) from which we find \(\theta = 6/2^4 = 3/8\).  The result does not change.


\subsection{Irrational value}
\label{\detokenize{algorithms/qpe:irrational-value}}
\sphinxAtStartPar
If the eigenvalue is \(e^{2\pi i /3}\), \(theta=1/3\) cannot be expressed by the finite binary fractions and thus it is not possible to get the perfect answer using the current algorithm.  Let us consider \(U=P(2\pi/3)\) and \(\psi\rangle=|1\rangle\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{cr}\PYG{o}{=}\PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qr}\PYG{o}{=}\PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{=}\PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,}\PYG{n}{cr}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Walsh\PYGZhy{}Hadamard transformation for qubit 0\PYGZhy{}2}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} X for qubit 3 to create |1\PYGZgt{}}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}

\PYG{c+c1}{\PYGZsh{} qubit 0}
    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} SWAP}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 0}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 1}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 2}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} qubit 3}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Chose a general quantum simulator without noise.}
\PYG{c+c1}{\PYGZsh{} The simulator behaves as an ideal quantum computer.}
\PYG{n}{backend} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qasm\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} set number of tries}
\PYG{n}{nshots}\PYG{o}{=}\PYG{l+m+mi}{8192}

\PYG{c+c1}{\PYGZsh{} execute the quantum circuit and store the outcome}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{backend}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{,}\PYG{n}{shots}\PYG{o}{=}\PYG{n}{nshots}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} extract the result}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} count the outcome}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}histogram}
\PYG{n}{plot\PYGZus{}histogram}\PYG{p}{(}\PYG{n}{counts}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{qpe_13_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Clearly \(|0101\rangle = |5\rangle\) is dominant. It corresponds to \(\theta = 5/2^4 = 0.3125\).  The exact answer is \(1/3=0.3333...\).  The agreement is not bad and the error can be reduced by using more qubits.


\bigskip\hrule\bigskip


\sphinxAtStartPar
Last modified on 07/24/2022.

\sphinxstepscope


\part{Backmatters}

\sphinxstepscope


\chapter{References}
\label{\detokenize{references:references}}\label{\detokenize{references::doc}}
\begin{sphinxthebibliography}{1}
\bibitem[1]{references:id4}
\sphinxAtStartPar
Jürgen Audretsch. \sphinxstyleemphasis{Entangled Systems \sphinxhyphen{} New Directions in Quantum Physics}. Wiley\sphinxhyphen{}VHC, 2007. ISBN 978\sphinxhyphen{}3\sphinxhyphen{}527\sphinxhyphen{}40684\sphinxhyphen{}5.
\bibitem[2]{references:id20}
\sphinxAtStartPar
Nicolas Gisin. \sphinxstyleemphasis{Quantum Chance}. Springer International Publishing, 2014. \sphinxhref{https://doi.org/10.1007/978-3-319-05473-5}{doi:10.1007/978\sphinxhyphen{}3\sphinxhyphen{}319\sphinxhyphen{}05473\sphinxhyphen{}5}.
\bibitem[3]{references:id19}
\sphinxAtStartPar
N. David Mermin. What's wrong with this pillow? \sphinxstyleemphasis{Physics Today}, 42(4):9–11, April 1989. URL: \sphinxurl{https://doi.org/10.1063/1.2810963}, \sphinxhref{https://doi.org/10.1063/1.2810963}{doi:10.1063/1.2810963}.
\bibitem[4]{references:id17}
\sphinxAtStartPar
David Deutsch and Roger Penrose. Quantum theory, the church\sphinxhyphen{}turing principle and the universal quantum computer. \sphinxstyleemphasis{Proceedings of the Royal Society of London. A. Mathematical and Physical Sciences}, 400(1818):97–117, July 1985. URL: \sphinxurl{https://doi.org/10.1098/rspa.1985.0070}, \sphinxhref{https://doi.org/10.1098/rspa.1985.0070}{doi:10.1098/rspa.1985.0070}.
\bibitem[5]{references:id18}
\sphinxAtStartPar
A. Yu. Kitaev. Quantum measurements and the abelian stabilizer problem. \sphinxstyleemphasis{arXiv}, pages quant–ph/9511026, 1995. \sphinxhref{https://doi.org/10.48550/ARXIV.QUANT-PH/9511026}{doi:10.48550/ARXIV.QUANT\sphinxhyphen{}PH/9511026}.
\bibitem[6]{references:id5}
\sphinxAtStartPar
M. A. Nielsen and I. L. Chuang. \sphinxstyleemphasis{Quantum Computation and Quantum Information}. Cambridge University Press, 2000. ISBN 0\sphinxhyphen{}521\sphinxhyphen{}63503\sphinxhyphen{}9.
\end{sphinxthebibliography}







\renewcommand{\indexname}{Index}
\printindex
\end{document}